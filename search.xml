<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>分布式锁Redisson</title>
      <link href="/2022/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Redisson/"/>
      <url>/2022/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Redisson/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Redis主从、哨兵</title>
      <link href="/2022/11/10/%E6%B5%85%E8%B0%88Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5/"/>
      <url>/2022/11/10/%E6%B5%85%E8%B0%88Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="主从"><a class="header-anchor" href="#主从">¶</a>主从</h2><p>先说说主从吧。单机的Redis，能够承载的QPS就在上万到几万不等。但对于缓存来说，本来就是用于高并发的读写的，毕竟不像Mysql那样。</p><p>因此，需要将架构提升到，主从(master-slave)架构：一主多从，主读，从写，达到读写分离的效果。所有的读的请求全部走从节点，也可以很轻松的实现水平扩容，支撑住高并发。</p><h3 id="Redis-replication-的核心机制"><a class="header-anchor" href="#Redis-replication-的核心机制">¶</a>Redis replication 的核心机制</h3><ul><li>Redis采用异步的方式复制数据到<code>slave</code>节点，(从Redis2.8开始，slave node 会周期性地确认自己和master node上的数据是否保持一致)</li><li>一个master node 可以配置多个slave node</li><li>slave node 也可以连接其他的 slave  node（slave node 之间的通讯）</li><li>slave node 节点在复制数据的时候，不会 block master node</li><li>slave node 节点在复制数据的时候，也不会block 自己的查询操作，它会先用之前的旧数据集来提供服务；<br>但是复制完成的时候，需要删除旧数据集，这个时候就会暂停对外服务了；</li></ul><p>有一点挺重要的，如果采用了master—slave架构，<strong>那么建议开启 master node 的持久化</strong>，<strong>并且不建议使用 slave node 做 master node 的数据热备</strong>，因为那样的话，如果我们关闭了master的持久化，可能在master重启的时候数据是空的，那么slave复制过来的数据也是空的，数据丢失。</p><h3 id="Redis-主从复制的原理"><a class="header-anchor" href="#Redis-主从复制的原理">¶</a>Redis 主从复制的原理</h3><p>当启动一个slave node 时，他会发送一个<code>PSYNC</code>命令给master node</p><ol><li>slave连接到master ——&gt; 触发一次 <code>full resynchronization</code>全复制</li><li>master就启动一个后台线程，生成一份<code>RDB</code>快照文件 ——&gt; 发给slave</li><li>然后slave node 收到这个快照文件过后，将他写入磁盘中。完了过后，将这份数据持久到内存中。</li><li>紧接着，master会讲 <strong>内存中 缓存的 写命令</strong> 发送到slave，slave会同步这些数据。</li></ol><p>如果slave node 跟master node 出现了网络故障，断开了连接，会自动重连，重连过后 master node 仅仅会复制给slave部分缺少的数据</p><h3 id="主从复制的断点续传"><a class="header-anchor" href="#主从复制的断点续传">¶</a>主从复制的断点续传</h3><blockquote><p>从Redis2.8开始，Redis就支持所谓的<strong>主从复制的断点续传</strong></p></blockquote><p>什么意思呢，如果主从复制的过程当中，由于网络IO等各种原因，导致复制过程中断，name可以接着上次复制的点，继续复制下去，而不是从头开始复制一份</p><p><strong>原理如下：</strong></p><blockquote><p>master node  会在内从中维护一个<code>backlog</code>，master 和 slave 都会保存一个 <code>replica offset</code>还有一个个<code>master run id</code> ，<code>offset</code>就是保存在<code>backlog</code>中的</p><p><code>backlog</code>中，如果master和slave网络中断了，slave会让master从上次<code>replica offset</code>开始继续复制，如果没有找到对应的<code>offset</code>，那么就会执行一次<code>resynchronization</code></p><p>如果根据<code>host+ip</code>定位master node ，是不靠谱的，土规 master node  重启或者数据出现了变化，那么slave node 应该根据不同的run id区分</p></blockquote><h3 id="过期Key的处理"><a class="header-anchor" href="#过期Key的处理">¶</a>过期Key的处理</h3><p>slave 不会过期key，主从主从，仆人肯定是听从主人的嘛，slave只会等待master过期key。如果master过期了一个key，后者通过LRU淘汰了一个key，那么会模拟一条类似于<code>del</code>的指令发送给slave去删除过期的kwy</p><h3 id="那么Redis如何才能做到高可用呢"><a class="header-anchor" href="#那么Redis如何才能做到高可用呢">¶</a>那么Redis如何才能做到高可用呢</h3><p>如果一个系统在356天，有99.99%的时间内，都是可以对外提服务的，那么就是说这个系统是高可用的</p><p>一个slave挂掉了，是不会影响到系统的可用性，因为还有其他的slave在提供服务</p><p>那么，吐过master node 寄了呢，没办法写数据了，写缓存的时候，全部都是失效了。slave node 就没什么作用了，毕竟没有master 给他们复制数据了，这就是所谓群龙无首，遮掩搞得系统相当于不可用</p><hr><p>这就需要设计Redis的高可用架构，<strong>故障转移</strong>，也可以叫做<strong>主备切换</strong></p><p>存在故障转移过后，master node 寄，系统自动监测，并且将某个slave node 自动切换为 master node ，类似于继承？或者说是选举更合适一点。</p><p>这个过程中，就实现了Redis 的主从架构的高可用。</p><p>要完成这样的架构设计，就需要接下来要说到了哨兵机制了……</p><h2 id="哨兵"><a class="header-anchor" href="#哨兵">¶</a>哨兵</h2><h3 id="什么是哨兵？"><a class="header-anchor" href="#什么是哨兵？">¶</a>什么是哨兵？</h3><blockquote><p>Sentinle，中文名是哨兵</p></blockquote><p>哨兵是Redis集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控Redis master node 和 slave node 是否正常工作</li><li>消息通知：如果某个node有故障，那么哨兵负责发送消息作为警报通知给Mng</li><li>故障转移：如果master node 寄了，会自动将某个slave node 选举为 新的master</li><li>配置中心：如果股中航转移发生了，通知client客户端新的master的<code>address</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通讯与TPC/IP</title>
      <link href="/2022/10/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8ETPC-IP/"/>
      <url>/2022/10/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8ETPC-IP/</url>
      
        <content type="html"><![CDATA[<h1>网络通信与TCP/IP</h1><p>什么是计算机的网络？<br>老套路、官方话：</p><blockquote><p>利用通信线路将地理上分散的、具有独立功能的计算机系统和通信设备按不同的形式连接起来，以功能完善的网络软件及协议实现资源共享和信息传递的系统。</p></blockquote><p><strong>主要的网络</strong>：</p><ol><li>局域网</li><li>城域网</li><li>广域网</li><li>无线网</li><li>…</li></ol><p>P话就不多说了，直接进入主题吧</p><p>首先是，网络通讯的鼻祖、<strong>OSI七层模型</strong>：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015165435767.png" alt="image-20221015165435767" align="left" style="zoom: 50%;" /><p>再到我们现在的<strong>TCP/IP五层模型</strong>：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015165526473.png" alt="image-20221015165526473"  align="left" style="zoom:71%;" /><p>从图片中可以看出来，TCPIP只是把OSI的上三层合并为了一层，应用层。</p><p>方便记忆：</p><ul><li>应用层：平时我们访问使用的http(bushi)、https协议；或者远程连接的Mysql；远程连接的SSH…</li><li>传输层：<ul><li>TCP协议：面向连接的、可靠的流协议</li><li>UDP协议：面向无连接的通讯协议</li></ul></li><li>网络层：IP地址</li><li>数据链路层：硬件驱动程序，追究到底还是</li><li>物理层：网卡</li></ul><p>有些说法是吧最底层的物理层+数据链路层合成一层，但其实不是…</p><h2 id="浅谈TCP-UDP"><a class="header-anchor" href="#浅谈TCP-UDP">¶</a>浅谈TCP/UDP</h2><p>从上文看到，TCP协议是面向连接的、可靠的流协议；而UDP是面向无连接的通讯协议</p><p>TCP首先是要建立连接的，他会有我们平常所说的3次握手，</p><p>为什么要建立连接呢？</p><blockquote><p>1.更好的保证可靠性: 建立连接的过程其实就是让通信双方验证各自的发送能力和接受能力是否正常<br>2.协商一些重要参数 (如: 序号的初始值)</p></blockquote><p>具体怎么建立连接？</p><blockquote><p>栗子：</p><p>A给B打电话，打电话同样要同样给自己以及对方的话筒是否正常工作</p><p>第一次握手：刚开始，A不知道自己和B书籍的听筒的话筒是否正常，所以A说：“喂喂喂？？？”</p><p>第二次握手：B听到过后，说明A的话筒和B的听筒正常，但B还需要进一步的检查自己的话筒是否正常；同时B吧A话筒正常和自己听筒正常的消息传给A；于是B：”干嘛？你爹！”</p><p>第三次握手：A收到了B的消息后，就证明了A听筒正常，B听筒正常</p></blockquote><p>这就类似于网络建立连接的三次握手…</p><p>所以，网络中传输数据整体过程是这样的：</p><blockquote><p>又是一个栗子：在消息发送的过程中</p><p>首先我们吧消息编辑好，点击发送button，此时，这个消息还处于<strong>应用层</strong>。点击button后，进入传输层，被解析成，计算机唯一认识的01二进制，再加上大概20个字节的TCP首部，形成<strong>报文</strong>，或者是所谓的<strong>消息</strong>；</p><p>然后，传进网络层，加上IP包首部——&gt;报文段</p><p>传进数据链路层，加上以太网首部——&gt;数据报</p><p>最后进入物理层，通过网卡等硬件，带上型信号，传进以太网电缆。</p><p>等这个<strong>帧</strong>，被甲方接收到过后，通过以上的顺序的反解析，一步一步脱壳成最初我们所编辑的数据包，展示在甲方的应用层上。这时，甲方手机上显现一个：“我是你爹”<br>的时候就</p><p>完成的数据(消息)的传输</p></blockquote><hr><p><strong>而UDP</strong></p><p>他最主要的特点就是、UDP是无连接的，就是发送数据之前不需要建立连接，这也是与TCP协议的本质区别，当然，发送数据结束的时候也没有连接可以释放，一次，就减少了开销和发送数据之前的延迟，</p><p>目前QQ，微信，语音电话、视频……之类的通讯大都基于UDP的通信协议，因为大都人不会因为你那一个像素点，一句话两句话听不清楚就抱怨什么(没有针对一些比较紧急的场景)</p><h2 id="网络通讯中的地址与端口号"><a class="header-anchor" href="#网络通讯中的地址与端口号">¶</a>网络通讯中的地址与端口号</h2><h3 id="地址Address"><a class="header-anchor" href="#地址Address">¶</a>地址Address</h3><ul><li>IP地址和MAC地址</li></ul><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015185133497.png" alt="image-20221015185133497" align="left" style="zoom:60%; " /><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015185221395.png" alt="image-20221015185221395" align="left" style="zoom:50%; " /><p>打开<strong>win</strong>的<strong>powerShell</strong>，输入：<code>ipconfig</code>可以看到自己设备信息</p><p>这里的物理地址就是MAC地址。MAC地址是厂商开始创建这个设备的时候就将其写在点的硬件上的。所以每个设备只有一个MAC地址，还是不能修改的(除非说是你通过物理手段，修改BIOS，修改MAC地址)，所以MAC地址实在TCP的数据链路层上用的，也可以理解成数据链路层的地址。</p><p>看到我电脑上无线局局域网Adapter (WALN) 下的MAC地址是：E0-D4-64-31-CA-13，前一半是<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A">IEEE</a>给每个厂商一个，后面一半由厂商自己分配</p><p>IPV4就不用说了，没有IPV4是没法上网的，这个东西要么手动获取，要么DHCP服务器给分配IPV4</p><ul><li><p>MAC地址与IPV4的区别</p><blockquote><ol><li>MAC地址不能随意更换，IPV4可以</li><li>MAC地址48位，IPV4是32位</li><li>MAC地址工作在数据链路层，IPV4工作在网络层</li></ol></blockquote></li></ul><h3 id="端口Port"><a class="header-anchor" href="#端口Port">¶</a>端口Port</h3><p>官方：</p><blockquote><p>用来识别同一台计算机设备设备中不同的应用程序，也被称之为应用程序地址</p></blockquote><ul><li><p>为什么端口号有65535个？</p><blockquote><p>因为TCP和UDP协议里面报文头中吗，有专门的的字段来存这个端口号，这个字段头只有2个字节，2^16 = 65536 ，但是一般端口0只带本设备上所有的端口。</p><p>所以端口号只有65536 - 1 =  65535个</p></blockquote></li><li><p>一台设备上最多只能有65535个TCP连接嘛？</p><blockquote><p>这是可笑的，</p><p>一个栗子：现有10个客户端连接一台机器上的Mysql，Mysql也只是接收到了3306这个端口上发送来的数据，</p><p>所以，一台设备上所能接收到的链接，与端口号数没有必然关系。</p></blockquote></li></ul><p>再者，一个通讯在网络中是由5个元组识别：</p><ol><li>源IP</li><li>目标IP</li><li>TCP协议号</li><li>源端口</li><li>目标端口</li></ol><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015200329440.png" alt="image-20221015200329440"></p><h3 id="TCP三次握手建立连接"><a class="header-anchor" href="#TCP三次握手建立连接">¶</a>TCP三次握手建立连接</h3><p>图片来自：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=65&amp;vd_source=61258a05469482a4381c086011c25c18">https://www.bilibili.com/video/BV1c4411d7jb?p=65&amp;vd_source=61258a05469482a4381c086011c25c18</a></p><p>TCP报文的首部格式</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015203150879.png" alt="image-20221015203150879"></p><p>至于三次握手的流程我就懒得用文字来描述了，用图片的方式可能更好记忆一点(可能纯粹就是懒吧…)</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015204050802.png" alt="image-20221015204050802" align="left" style="zoom:70%;" />其中SYN是TCP报文里面某一个bit的站位标志。</p><p>出于这样的连接方式，TCP的三次握手也是会有漏洞，——SYN洪泛攻击</p><p><strong>SYN洪泛攻击</strong>，是通过网络服务所在的端口发送大量伪造源地址的攻击报文，发送到服务端，造成服务端上的<strong>半开连接</strong>，队列被占满，从而组织其他用户进行访问。</p><p><strong>原理</strong></p><blockquote><p>攻击者客户端利用为伪造的IP地址想服务端发出请求(第一次)。而服务端的响应(第二次)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(其实永远不会有的，毕竟是伪造的)，服务端在这种半开的链接过程中小号了资源，如果有成千上万的这样链接，主机资源将被耗尽，从而发达到攻击的目的，就有点像DDOS攻击，都是发送大量的数据包。</p></blockquote><p><strong>解决方案</strong></p><blockquote><ul><li>无效连接监控释放</li><li>延缓TCB分配方法</li><li>防火墙</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
          <category> 重修 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-所有权</title>
      <link href="/2022/10/03/Rust-%E6%89%80%E6%9C%89%E6%9D%83/"/>
      <url>/2022/10/03/Rust-%E6%89%80%E6%9C%89%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>在所有程序执行过程中，与计算机内存的暧昧行为早已被默认。但如何与其保持着敌进我退，敌退我进的距离，——在内存中申请内存来执行程序；在执行完过后，不需要的时候再释放这段内存，成为了重中之重。这也是设计编程语言过程中的一座高山。于是，三种主流的模式应运而生：</p><ul><li><p>GC：垃圾回收机制，在程序运行的同时，无时无刻的想办法找那些不被利用，并且以后也不再使用的内存，回收起来，例如最经典的Java(Jvm)，Go，C#</p></li><li><p>显示操作：回收，申请内存这些操作改成了由程序员自己手动操作，(比起GC的耗性能，我果然还是接收不了自己手动操作对象空间的申请与释放)，C++</p></li><li><blockquote><p><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查(这里就直接把原话复制过来吧)</p></blockquote></li></ul><p>而Rust正好就是第三种，对内存的管理机制——<strong>所有权</strong></p><p>这种机制，早在编译的时候就确立好了这段内存由谁来支配，大大的挽回了内存的损失。</p><hr><p>在说所有权之前先谈谈栈和堆吧</p><h3 id="栈、堆"><a class="header-anchor" href="#栈、堆">¶</a>栈、堆</h3><ul><li><p>栈</p><blockquote><p>这个东西，数据结构的角度看栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表的子集。他们是操作受限的线性表…</p><p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。出于这样的存储方式，在栈中的数据必须有明确的大小，并且在之后的操作中不得改变(明确，固定)，假设数据是未知的，那么在取出数据时，将无法获取想要的数据。</p></blockquote></li><li><p>堆</p><blockquote><p>相对于栈，我们(哪儿来的们🐟)对堆的认识往往并不多，可能是出于平常使用的编程语言并不要求我们对栈堆有多大的掌握。扯远了…</p><p>与栈不同，对于未知数据的存储，我们需要将它存到堆中。在存数据的过程中，OS首先在堆中找到一份它觉得合适大小的空间，将它标记为——&gt;已使用，并返回这段空间的指针地址，该过程称之为——&gt;<strong>分配</strong>。接着，让数据占用这段空间。</p><p>当我们访问这段空间想拿到数据时，只需要找到刚刚被分配到栈中的指针，去找地址就好了。</p><p>(这个例子以后还会提到)就好像我们去餐厅吃饭，服务员问我们几个人，我们说6个，那她就会带我们去大概6 7个位置左右的餐桌，这个过程就是分配。完了过后，要是有人迟到了，想找到我们，只需要我们发短信给他一个餐桌号，他就可以顺利的找到我们，这个过程就是拿数据。</p></blockquote></li></ul><h3 id="所有权机制"><a class="header-anchor" href="#所有权机制">¶</a><strong>所有权机制</strong></h3><blockquote><ul><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</li></ul></blockquote><h3 id="浅谈一下String"><a class="header-anchor" href="#浅谈一下String">¶</a>浅谈一下String</h3><p>在rust里面，当我们在编译器里输入<code>let s =&quot;hello&quot;</code>时，s这个变量是直接被硬编码到程序里面去的(类型为：<code>&amp;str</code>)，也叫作<strong>字符串字面量</strong>，字符串字面量是很方便的，但是在有些时候，这个方便并没有体现到位，原因是：</p><ul><li>由于是直接被硬编码到程序当中去，所以他是不可变的</li><li>并非所有字面量都能在编写代码的时候得知他的值</li></ul><p>于是就有了动态字符串类型：<code>String</code></p><p>这个类型被分配到堆空间上，所以可以动态的伸缩，也就可以存储位置大小的文本。</p><p>在rust中，想要得到一个String类型的变量很简单：<code>let s = String::new(&quot;yxyl&quot;);</code></p><h3 id="浅拷贝和深拷贝"><a class="header-anchor" href="#浅拷贝和深拷贝">¶</a>浅拷贝和深拷贝</h3><h4 id="拷贝-浅拷贝"><a class="header-anchor" href="#拷贝-浅拷贝">¶</a>(拷贝)浅拷贝</h4><p>先讲讲浅拷贝吧，浅拷贝只是发生在栈上，因此，性能很高，就比如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>这段代码就是很实在的浅拷贝，因为整形这个数据类型大小是已知的，会被存储在栈上，所以浅拷贝也是快速的、这意味着没有理由在创建<code>y</code>过后，<code>x</code>失效</p><h4 id="克隆-深拷贝"><a class="header-anchor" href="#克隆-深拷贝">¶</a>(克隆)深拷贝</h4><p>没有人会做出有损自己利益的事情，rust也一样，rust不会主动进行数据的深拷贝，他是低效且耗性能的，就像如果想要复制String类型的变量时候，通常会用<code>clone()</code>这样一个方法，他不仅仅是复制栈上的数据，深度copy了堆上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>您的设计模式-单例模式</title>
      <link href="/2022/09/19/%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/19/%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1>单例模式【Singleton Pattern】</h1><blockquote><p>这个模式是很有意思，而且比较简单，但是我还是要说因为它使用的是如此的广泛，如此的有人缘， 单例就是单一、独苗的意思，那什么是独一份呢？你的思维是独一份，除此之外还有什么不能山寨的呢？ 我们举个比较难复制的对象：皇帝  中国的历史上很少出现两个皇帝并存的时期，是有，但不多，那我们就认为皇帝是个单例模式，在这 个场景中，有皇帝，有大臣，大臣是天天要上朝参见皇帝的，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，单例模式，绝对的单例模式， 先看类图：</p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220919101551388.png" alt="image-20220919101551388"></p><p><strong>然后我们看程序实现，先定一个皇帝：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 中国的历史上一般都是一个朝代一个皇帝，有两个皇帝的话，必然要PK出一个皇帝出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emperor</span> &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Emperor</span> <span class="variable">emperor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个皇帝放在那里，然后给这个皇帝名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Emperor</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="comment">//世俗和道德约束你，目的就是不让你产生第二个皇帝</span></span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(emperor == <span class="literal">null</span>)&#123; <span class="comment">//如果皇帝还没有定义，那就定一个</span></span><br><span class="line">         emperor = <span class="keyword">new</span> <span class="title class_">Emperor</span>(); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">return</span> emperor; </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//皇帝叫什么名字呀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">emperorInfo</span><span class="params">()</span>&#123; </span><br><span class="line">     System.out.println(<span class="string">&quot;我就是皇帝某某某....&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后定义大臣：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 大臣是天天要面见皇帝，今天见的皇帝和昨天的，前天不一样那就出问题了！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Minister</span> &#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     <span class="comment">//第一天</span></span><br><span class="line">     Emperor emperor1=Emperor.getInstance(); </span><br><span class="line">     emperor1.emperorInfo(); <span class="comment">//第一天见的皇帝叫什么名字呢？</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//第二天</span></span><br><span class="line">     Emperor emperor2=Emperor.getInstance(); </span><br><span class="line">     Emperor.emperorInfo(); </span><br><span class="line"></span><br><span class="line">     <span class="comment">//第三天</span></span><br><span class="line">     Emperor emperor3=Emperor.getInstance(); </span><br><span class="line">     emperor2.emperorInfo(); </span><br><span class="line"></span><br><span class="line">     <span class="comment">//三天见的皇帝都是同一个人，荣幸吧！</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>看到没，大臣天天见到的都是同一个皇帝，不会产生错乱情况，反正都是一个皇帝，是好是坏就这一 个，只要提到皇帝，大家都知道指的是谁，清晰，而又明确。问题是这是通常情况，还有个例的，如同一 个时期同一个朝代有两个皇帝，怎么办？</strong></p><p><strong>单例模式很简单，就是在构造函数中多了加一个构造函数，访问权限是 private 的就可以了，这个模式是简单，但是简单中透着风险，风险？什么风险？在一个 B/S 项目中，每个 HTTP Request 请求到 J2EE 的容器上后都创建了一个线程,每个线程都要创建同一个单例对象,怎么办?,好,我们写一个通用的单例程 序,然后分析一下:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 通用单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern singletonPattern= <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123; </span><br><span class="line"></span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">this</span>.singletonPattern == <span class="literal">null</span>)&#123; <span class="comment">//如果还没有实例，则创建一个</span></span><br><span class="line">     <span class="built_in">this</span>.singletonPattern = <span class="keyword">new</span> <span class="title class_">SingletonPattern</span>(); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.singletonPattern; </span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​假如现在有两个线程 A 和线程 B，线程 A 执行到 <code>this.singletonPattern =  new SingletonPattern()</code>，正在申请内存分配，可能需要 0.001 微秒，就在这 0.001 微秒之内，线程 B 执 行到 <code>if(this.singletonPattern == null)</code>，你说这个时候这个判断条件是 true 还是 false？是 true，那然后呢？线程 B 也往下走，于是乎就在内存中就有两个 <code>SingletonPattern</code> 的实例了，看看是不是出问题了？</p><p>​如果你这个单例是去拿一个序列号或者创建一个信号资源的时候，会怎么样？业务逻辑混乱！数据一致性校验失败！最重要的是你从代码上还看不出什么问题，这才是最要命的！因为这种情况基本上你是重现不 了的，不寒而栗吧，那怎么修改？有很多种方案，我就说一种，能简单的、彻底解决问题的方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 通用单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonPattern singletonPattern= <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">SingletonPattern</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123; </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="keyword">return</span> singletonPattern; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接 new 一个对象传递给类的成员变量 <code>singletonpattern</code>，你要的时候 <code>getInstance()</code>直接返回给你，解决问题！</p>]]></content>
      
      
      <categories>
          
          <category> 您的设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S笔记1</title>
      <link href="/2022/09/18/K8S%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/09/18/K8S%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1>Kubernetes</h1><blockquote><p>K8S</p><p>一项基于生产环境级别下容器化编排自动化部署技术</p><p>这里的编排指的是：</p><ul><li>按照一定的目的一次排列</li><li>调配、安排</li></ul></blockquote><h2 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h2><p><strong>Master</strong></p><blockquote><p>K8S集群控制节点。管理已安装好的集群，对其调度管理，接收用户集群操作</p></blockquote><p><strong>Node</strong></p><blockquote><p>集群工作基点，在此环境上部署集群服务，运行集群容器</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务简单部署</title>
      <link href="/2022/09/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/09/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1>微服务简单部署</h1><h2 id="📋：Docker-Conpose"><a class="header-anchor" href="#📋：Docker-Conpose">¶</a>📋：Docker-Conpose</h2><ul><li>Docker-Compose是一个用来定义和运行复杂应用的docker工具。一个使用Docker容器的应用，一般是由多个容器组成。使用Docker-Compose就不用写多个shell脚本来启动管理容器了。</li></ul><ol><li>查看docker版本：<br><code>docker -version </code></li><li>安装docker-compose<br><code>sudo apt install docker-compose</code></li><li>查看docker-compose版本<br><code>docker-compose -version</code></li></ol><h2 id="➰：打包"><a class="header-anchor" href="#➰：打包">¶</a>➰：打包</h2><ul><li>在项目目录下创建image包，放每个微服务打包好的镜像，可选择每个微服务单独一个包，以便于以后微服务版本的维护，回滚。</li></ul><h2 id="🚉：Dockerfile"><a class="header-anchor" href="#🚉：Dockerfile">¶</a>🚉：Dockerfile</h2><ul><li><p>在每个微服务包下编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre</span><br><span class="line"><span class="keyword">ENV</span> APP_PATH=/apps</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$APP_PATH</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> xxx-1.0-SNAPSHOT.jar <span class="variable">$APP_PATH</span>/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> $&#123;PORT&#125;</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="上传Docker-Compose文件"><a class="header-anchor" href="#上传Docker-Compose文件">¶</a>上传Docker-Compose文件</h2><ul><li><p>在<code>Docker-Compose</code>文件中编写服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#定义docker网络</span></span><br><span class="line">  <span class="attr">yingxue_network:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#挂载数据卷</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">  <span class="attr">redisdata:</span></span><br><span class="line">  <span class="attr">mqdata:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment">#每个服务</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:2.0.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JVM_XMS=256m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JVM_XMX=256m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MODE=standalone&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yingxue_network</span></span><br><span class="line">        </span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yingxue_network</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./yingxue.sql:/docker-entrypoint-initdb.d/yingxue.sql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MYSQL_ROOT_PASSWORD=&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MYSQL_DATABASE=yingxue&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisdata:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="string">xxx服务:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">./images/xxx</span></span><br><span class="line">  <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;xxxx:xxxx&quot;</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">  <span class="string">-mysql</span></span><br><span class="line">  <span class="string">-redis</span></span><br><span class="line">  <span class="string">-rebbitmq</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">....</span></span><br></pre></td></tr></table></figure><p>这里是将每个软件服务和写的微服务写在同一个<code>docker-compose</code>文件中，可以的分成两个<code>docker-compose</code>，可将其划分成：</p><ol><li>docker-compose-app.yml：微服务</li><li>docker-compose-env.yml：环境服务</li></ol></li></ul><h2 id="🚀：点火"><a class="header-anchor" href="#🚀：点火">¶</a>🚀：点火</h2><ul><li>cd到docker-compose文件，</li><li><code>docker-compose up -d</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway自定义网关Filter</title>
      <link href="/2022/09/18/Gateway%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%85%B3Filter/"/>
      <url>/2022/09/18/Gateway%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%85%B3Filter/</url>
      
        <content type="html"><![CDATA[<h1>SpringCloud-Gateway自定义网关Filter</h1><p>自定义filter可以实现两种，一种是全局生效的，一种是局部生效的，需要配置。</p><p>🖕：这边自定义下局部的</p><ol><li><p>首先命名为：<code>xxxGatewayFilterFactory</code>比如<code>TokenGatewayFilterFactory</code>，<code>AddLogGatewayFilterFactory</code>等等，再注入IOC管理</p></li><li><p>然后，通过看其他自带的局部(全局)Filter类可以看出，他们都继承了<code>AbstractGatewayFilterFactory</code>这个抽象类，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;TokenGatewayFilterFactory.Config&gt;</span><br></pre></td></tr></table></figure><p>其中的泛型是Filter类中自定义的内部类<code>Config</code></p></li><li><p>重写<code>apply()</code>，<code>shortcutFieldOrder()</code>方法，</p><ul><li>其中apply是核心方法，它决定着我们需要的过滤业务，</li><li>shortcutFieldOrder()方法可根据自定义顺序接收我们从配置文件传过来的value</li></ul></li><li><p>创建Filter构造方法，可以传进来需要用到的工具类等等…</p></li></ol><p>🆗：Filter over后，需要我们在网关配置文件中每个需要Filter的路由中进行配置了，可传的参数由shortcutFieldOrder决定。</p>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2022/09/17/JUC/"/>
      <url>/2022/09/17/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="🌠-JUC是什么"><a class="header-anchor" href="#🌠-JUC是什么">¶</a>🌠:JUC是什么</h2><p>JUC是<code>java.util.concurrent</code>包的缩写，这个包里包含了各种各样的关于线程通讯，控制同步的工具类——&gt;即Java并发工具包。</p><p>另外，JUC的框架结构，并不是我们常见的继承实现框架结构。JUC底层在Java中是unsafe，unsafe是jvm的实现。有了unsafe的支持，才出现可以进行原子操作的Atomic原子类…最后才到我们的Utils。</p><h2 id="🚀-进程和线程"><a class="header-anchor" href="#🚀-进程和线程">¶</a>🚀:进程和线程</h2><blockquote><p>官方：进程是CPU分配资源的最小单元，线程是CPU调度资源的最小单位</p></blockquote><p>Java默认有2个线程：mian(主线程)、GC(守护线程)</p><h2 id="🚢-并发和并行"><a class="header-anchor" href="#🚢-并发和并行">¶</a>🚢:并发和并行</h2><ul><li>并发（多个线程操作一个资源）：CPU一核，模拟出来多个线程</li><li>并行（多个人一起行走）：CPU多核，执行多条线程</li></ul><blockquote><p>线程有6个状态：</p></blockquote><ol><li><strong>NEW-&gt;新生</strong></li><li><strong>RUNNABLE-&gt;运行</strong></li><li><strong>BLOCKED-&gt;阻塞</strong></li><li><strong>WAITING-&gt;等待</strong></li><li><strong>TIMED_WAITING-&gt;死等</strong></li><li><strong>TERMINATED-&gt;终结</strong></li></ol><blockquote><p>wait/sleep区别</p></blockquote><ul><li>wait：<br>要释放锁<br>不需要捕获异常<br>只能在静态代码块中(<code>static</code>)</li><li>sleep：<br>不释放锁<br>需要捕获异常<br>任意地方都可以<strong>睡</strong></li></ul><h2 id="🔒-Lock-锁"><a class="header-anchor" href="#🔒-Lock-锁">¶</a>🔒:Lock(锁)</h2><blockquote><p>传统synchronized 本质：队列+锁 ——&gt; 排队</p></blockquote><p><code>java.util.concurrent.locks.Lock</code></p><p>其子类：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220915205227492.png" alt="image-20220915205227492"></p><blockquote><p>synchronized和lock的区别</p></blockquote><ul><li>synchronized  是关键字；lock是类</li><li>synchronized  不能判断锁的状态；lock可以判断锁</li><li>synchronized  自动释放锁；lock必须手动释放锁，不释放的话–&gt;死锁</li><li>synchronized  Thread1堵塞–&gt;Thread2等待；lock不一定等</li><li>synchronized  适合少代码同步；lock适合大量代码同步</li><li><strong>…</strong></li></ul><h2 id="⭐-JUC版的PC问题"><a class="header-anchor" href="#⭐-JUC版的PC问题">¶</a>⭐:JUC版的PC问题</h2><blockquote><p>通过lock找到Condition<br>condition来对线程进行监视操作(等待，唤醒…)<br>condition操作线程，可以精准的对线程的唤醒</p></blockquote><p><strong>资源类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里看到判断线程操作资源等待的条件使用<code>while</code>判断而不用<code>if</code>，为了防止虚假唤醒的问题。</strong></p><h2 id="💦-集合类不安全"><a class="header-anchor" href="#💦-集合类不安全">¶</a>💦:集合类不安全</h2><p>我们知道在多线程下进行任何操作都是令人胆战心惊的。</p><p>多线程下，对集合CRUD，难免会遇到<code>ConcurrentModificationException</code>线程操作异常，是因为我们平常使用的ArrayList底层的数据操作方法都是单线程的，没有对线程进行处理。</p><p>针对这点，有3个常见的解决方案(仅基于Java层面)：</p><ol><li>使用Vector集合类，Vector集合类底层对集合操作进行了synchronized锁处理，但相对来说效率较低<br><code>List list = new Vector&lt;&gt;();</code></li><li>使用集合工具类中的**“锁集合”**，<code>Collections.synchronizedList(....);</code></li><li>使用<strong>读写锁集合(JUC)</strong>，<code>CopyOnWriteArrayList</code>底层对数据的集合操使用了JUC中的Lock锁类，效率较Vector自然<strong>upup</strong><br><code>List list = new CopyOnWriteArrayList();</code></li></ol><h2 id="🍶-线程池"><a class="header-anchor" href="#🍶-线程池">¶</a>🍶:线程池</h2><p>写到这里突然想起来那天学长面试的问题——说下线程的创建方法吧</p><p>头一次感受到当时开学用一个月学Java这门编程语言的时候到如今这样一个不太正式的面试，面临如此基础简单的问题 时是多么的无力…</p><p>创建线程一共有4个方法，但万变不离其宗，完全可以总结为一个方法——其最终都是执行的<code>Thread.start()</code>当中的<code>run()</code>方法</p><ol><li><p>实现<code>Runable</code>接口，重写<code>Run()</code>方法</p></li><li><p>实现<code>Callable</code>接口，重写<code>Call()</code>方法</p><ul><li><blockquote><p>与（1）不同的是，<code>Call()</code>方法是有返回值的，其类型由我们创建匿名内部类的时候指定泛型。而<code>Callable接口</code>本身并不是<code>Runable</code>的子类，创建线程可以通过该方法是因为：Thread在创建的时候是需要将<code>Runable</code>或其子类传入，其中包含了子类<code>FutureTask</code>这样一个类，在创建这个类时可将Callable接口的实现当做构造参数传进去，以达到创建线程的目的…</p></blockquote></li></ul></li><li><p>💩直接New Thread</p></li><li><p>通过线程池创建…</p></li></ol><hr><p><strong>池化技术</strong></p><blockquote><p>程序运行的本质是：占用OS的资源，而优化资源的使用——&gt;池化技术</p><p>事先准备好一些资源，需要用的话从我这儿拿，用完还我</p></blockquote><p>其优点：</p><ul><li>降低资源的消耗：本质即优化资源的使用效率</li><li>方便线程管理：创建线程池初始化事先线程</li><li>提高响应速度：不用频繁的创建和销毁线程</li></ul><h3 id="线程池的3个Func"><a class="header-anchor" href="#线程池的3个Func">¶</a>线程池的3个Func</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); -- 单例线程</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); -- 固定线程</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); --弹性</span><br></pre></td></tr></table></figure><h3 id="线程池的7个参数"><a class="header-anchor" href="#线程池的7个参数">¶</a>线程池的7个参数</h3><p>通过三个Func可以看出来，<code>Executors.newCachedThreadPool(); --弹性</code>这样一个方法是值得我们青睐的，</p><p>其构造方法：</p><img src="C:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20220918095441793.png" alt="image-20220918095441793" style="zoom: 65%;" /><blockquote><p>但是读源码我们可以看到</p></blockquote><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220918094909666.png" alt="image-20220918094909666" style="zoom: 80%;" /><blockquote><p>这里<strong>允许的创建线程数量</strong>是：<code>Integer.MAX_VALUE</code> = 2^31 - 1 ——&gt;<strong>可能会堆积大量的请求，从而导致 OOM！</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220918095025854.png" alt="image-20220918095025854"></p><blockquote><p>这也是阿里巴巴开发手册里面提到的，线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 这样一个原生的方式来创建线程。</p></blockquote><hr><p>归言：其7个参数分别：</p><ol><li>int <code>corePoolSize</code>：<strong>核心线程数</strong></li><li>int <code>maximumPoolSize</code>：<strong>最大创建线程数</strong></li><li>long <code>keepAliveTime</code>：<strong>存活时间</strong></li><li>TimeUnit <code>unit</code>：<strong>Time类管理工具</strong></li><li>BlockingQueue<Runnable> <code>workQueue</code>：指定阻塞队列</li><li>ThreadFactory <code>threadFactory</code>：<strong>线程工厂</strong></li><li>RejectedExecutionHandler <code>handler</code>：<strong>拒绝策略</strong></li></ol><h3 id="线程池的4中拒绝策略"><a class="header-anchor" href="#线程池的4中拒绝策略">¶</a>线程池的4中拒绝策略</h3><ul><li><code>new ThreadPoolExecutor.AbortPolicy()</code> // 银行满了，还有人进来，不处理这个人的，抛出异常</li><li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code> //哪来的去哪里!</li><li><code>new ThreadPoolExecutor.DiscardPolicy()</code> //队列满了，丢掉任务，不会抛出异常!</li><li><code>new ThreadPoolExecutor.DiscardoldestPolicyO()</code> //队列满了，尝试去和最早的竞争，也不会抛出异常!</li></ul><h2 id="📼-JMM"><a class="header-anchor" href="#📼-JMM">¶</a>📼:JMM</h2><blockquote><p>JMM(Java Memory Model)：Java内存模型</p></blockquote><p>它实现了Java程序在各种平台上都能达到一定的并发效果</p><p>每个Java程序都有<strong>主内存</strong>，以及<strong>每条线程的工作内存</strong></p><p>每天线程获取资源都会有相应的交互操作规范：</p><h3 id="8种内存交互模型"><a class="header-anchor" href="#8种内存交互模型">¶</a>8种内存交互模型</h3><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>JMM对8种内存交互操作制定的规则：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="Volatile"><a class="header-anchor" href="#Volatile">¶</a>Volatile</h2><blockquote><p><code>Volatile</code>是Jvm虚拟机提供的轻量级的同步机制</p></blockquote><p>特点：</p><ol><li>不保证原子性<ul><li>这里的原子性：<strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</strong></li></ul></li><li>禁止指令重排<ul><li>利用CPU的内存屏障，避免指令重排现象出现</li></ul></li><li>指令可见性<ul><li>当线程还正在消费主线程资源时，资源发生更改，<code>volatile</code>保证<strong>这个更改</strong>及时<strong>通知</strong>到线程</li></ul></li></ol><h2 id="CAS"><a class="header-anchor" href="#CAS">¶</a>CAS</h2><blockquote><p>CAS的全称为<code>compare and swap</code> 或者<code>compare and exchange</code>,意思为比较和交换</p><ul><li>比较：比较当前线程工作内存中的值&lt;——&gt;和主内存中的值</li><li>交换：若为期望——&gt;则执行操作；若不是期望，由于底层是自旋锁，会无线循环</li></ul><p><strong>本质</strong>上即是，对乐观锁思想的实际实现…</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1000</span>);<span class="comment">//原子类</span></span><br><span class="line"><span class="comment">//CAS操作</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">1000</span>, <span class="number">2000</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(integer.getAndIncrement());<span class="comment">//2000</span></span><br><span class="line">System.out.println(integer);<span class="comment">//2001</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">1000</span>, <span class="number">2000</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="CAS实现原子操作的问题"><a class="header-anchor" href="#CAS实现原子操作的问题">¶</a>CAS实现原子操作的问题</h3><p>ABA问题：</p><blockquote><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了</p></blockquote><p>解决ABA问题：使用带版本号机制的——&gt;原子应用类</p><p><strong>这里仅搬出简单的一类解决方案，类似于乐观锁的思想——&gt;基于版本号控制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; atomicReference</span><br><span class="line">                = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;Integer&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span></span><br><span class="line">            , atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line"></span><br><span class="line">    atomicReference.compareAndSet(<span class="number">102</span>, <span class="number">100</span></span><br><span class="line">            , atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">105</span></span><br><span class="line">            , stamp, stamp + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line">&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
