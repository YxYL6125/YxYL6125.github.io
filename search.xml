<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>WebFlux——响应式编程</title>
      <link href="/2022/12/10/WebFlux/"/>
      <url>/2022/12/10/WebFlux/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><p>响应式编程打破了传统的<strong>同步阻塞式编程模型</strong>，而这样往往对性能的消耗是过大的（相对来说嘛），但是基于<strong>响应式数据流</strong>和<strong>背压机制</strong>实现了<strong>异步非阻塞式</strong>的网络通讯、数据访问和事件驱动架构，能减轻服务器资源之间的竞争关系，从而提高服务的响应能力。</p><p>这也是<strong>WebFlux</strong>——Spring出产的基于响应式编程的一套<strong>应用程序框架模型</strong>，的诞生之际……</p><h2 id="背压"><a class="header-anchor" href="#背压">¶</a>背压</h2><p>首先先讲讲<strong>背压</strong></p><p>我们明确，纯“推”的模式下，数据流会有很多不可控制的因素，所以我们需要实现流量控制，这个时候，背压就出来了</p><p>背压，简单来说就是下游能够向上游反馈流量请求的机制。如果消费者消费数据的速度 &lt; 生产者生产数据的速度时，他就会持续消耗系统的资源，知道这些资源被消耗殆尽。这里指的是生产者消耗资源。这个时候，需要一种机制来使得消费者可根据自身当前的处理能力通知生产者来调整生产数据的速度，这种机制就是背压。</p><p>消费者会根据自身的处理能力来请求数据，而生产者也会以根据消费者的消费速度来生产数据，从而在两者之间达成一种动态的平衡，确保系统的及时响应性。</p><h2 id="应用场景"><a class="header-anchor" href="#应用场景">¶</a>应用场景</h2><p>本质上，响应式编程是一种编程技术，还更是一种架构设计的系统方法。所以可以应用于任何地方，简单的Web应用程序，大型企业的解决方案。当然我们也完全可以基于他来构建流式系统或者大数据系统</p><h3 id="Netflix-Hystrix-中的滑动窗口"><a class="header-anchor" href="#Netflix-Hystrix-中的滑动窗口">¶</a>Netflix Hystrix 中的滑动窗口</h3><p>在Spring Cloud中，Hystrix 是奈飞的一个开源容错库，使用了<code>HystrixCircuitBreaker</code>这个类来实现熔断器。</p><p>这个类是通过一个<code>circuitOpen</code>状态位来控制着整个熔断过程，而这个状态位本身的状态值则取决于系统目前的执行数据和健康指标</p><p>那么如何来实现着滑动窗口呢？系统运行时的每一个数据都被视为一个个的<code>event</code>，滑动窗口中的每一个桶——<code>Bucket</code> 都来自源源不断的事件。在技术实现的选型上，Hystrix 采用的基于响应式编程思想的<strong>RxJava</strong>。</p><p>……</p><p>作为总结，Hystrix巧妙的使用了RxJava的 <code>window</code>、<code>flatMap</code> 等操作符来将单位窗口时间内的事件，以及将一个窗口大小内的<code>Bucket</code>聚集到一起形成滑动窗口，并基于滑动窗口继承指标数据，</p><h2 id="Flux-Mono"><a class="header-anchor" href="#Flux-Mono">¶</a>Flux &amp; Mono</h2><p><img src="https://img-blog.csdnimg.cn/3570da1e74d0443cb298fc0df5f824ec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loal85MTE=,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>Flux 是一个发出(emit)0-N个元素组成的异步序列的Publisher<T>,可以被onComplete信号或者onError信号所终止。在响应流规范中存在三种给下游消费者调用的方法 onNext, onComplete, 和onError。</p><p>Mono 是一个发出(emit)0-1个元素的Publisher<T>,可以被onComplete信号或者onError信号所终止。<br>这里就不翻译了，整体和Flux差不多，只不过这里只会发出0-1个元素。也就是说不是有就是没有。</p></blockquote><p>Flux和Mono是Java响应式中的重要概念，这其实是规定了两种流式范式，这种范式让数据具有一些新的特性，比如基于发布订阅的事件驱动，异步流、背压等等。另外数据是推送（Push）给消费者的以区别于平时我们的拉（Pull）模式。同时我们可以像Stream Api一样使用类似map、flatmap等操作符（operator）来操作它们。</p><h3 id="创建Flux-Mono"><a class="header-anchor" href="#创建Flux-Mono">¶</a>创建Flux&amp;Mono</h3><blockquote><p>2022-12-10 22:23:21 先run，等明天起来再写(明天桌子和鼠标垫就到了，到时候直接原地起飞🚀)</p></blockquote><blockquote><p>2022-12-11 08:26:25 起来了，坏消息，今天桌子很有可能到不了。（以后买东西死都不买南京发货的的了）</p></blockquote><p>这里分为静态以及动态创建</p><h4 id="静态创建"><a class="header-anchor" href="#静态创建">¶</a>静态创建</h4><p>静态创建Flux和Mono的方式都是一样的</p><h5 id="just"><a class="header-anchor" href="#just">¶</a>just</h5><p><strong>Flux</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">//观察者监听被观察者(消费者)</span></span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用可变参数创建Flux</span></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用just创建Mono</span></span><br><span class="line">Mono.just(<span class="string">&quot;1s&quot;</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"> Mono.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>Mono</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">//观察者监听被观察者(消费者)</span></span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用可变参数创建Flux</span></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用just创建Mono</span></span><br><span class="line">Mono.just(<span class="string">&quot;1s&quot;</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"> Mono.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>像这样使用<code>just</code>静态创建Flux和Mono，前提需要知道内容和大小的数据</p><h5 id="fromIterable"><a class="header-anchor" href="#fromIterable">¶</a>fromIterable</h5><p>使用fromIteratble从可迭代对象中创建Flux</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//从可迭代的对象中创建Flux</span></span><br><span class="line">Flux.fromIterable(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Flux&lt;Integer&gt; flux = Flux.fromIterable(list);</span><br><span class="line"><span class="comment">//在创建Flux后追加元素</span></span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">flux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="fromStream"><a class="header-anchor" href="#fromStream">¶</a>fromStream</h5><p>使用fromStream从集合流中创建Flux</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.fromStream(Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">               .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="range"><a class="header-anchor" href="#range">¶</a>range</h5><p>创建一个范围内迭代的Flux</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="动态创建"><a class="header-anchor" href="#动态创建">¶</a>动态创建</h4><p>动态创建有时候更容易满足我们发开时的需求</p><h5 id="generate"><a class="header-anchor" href="#generate">¶</a>generate</h5><p><code>generate()</code>方法生成Flux序列依赖于Reactor所提供的<code>SynchronousSink</code>组件，他的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="title function_">generate</span><span class="params">(Consumer&lt;SynchronousSink&lt;T&gt;&gt; generator)</span></span><br></pre></td></tr></table></figure><p><code>SynchronousSink</code>组件，看名字就能知道他是一个同步的Sink组件，也就是说元素的生成过程是同步执行的。</p><p>这个组件包括三个核心方法：</p><ol><li><code>next()</code></li><li><code>complete()</code></li><li><code>error()</code></li></ol><p>使用<code>generate()</code>方法创建Flux的实例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步动态创建， next() 方法只能最多被调用一次</span></span><br><span class="line">Flux.generate(sink -&gt; &#123;</span><br><span class="line">sink.next(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//第二次会报错:</span></span><br><span class="line"><span class="comment">//java.lang.IllegalStateException: More than one call to onNext</span></span><br><span class="line"><span class="comment">//sink.next(&quot;2&quot;);</span></span><br><span class="line"><span class="comment">//如果不调用 complete() 方法，那么就会生成一个所有元素均为“1”的无界数据流</span></span><br><span class="line">sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="create"><a class="header-anchor" href="#create">¶</a>create</h5><p><code>create()</code>方法和<code>generate()</code>是方法比较类似，但是他使用的是一个<code>FluxSink</code>组件，他的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="title function_">create</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> FluxSink&lt;T&gt;&gt; emitter)</span></span><br></pre></td></tr></table></figure><p>与<code>generate()</code>不同的是，<code>create()</code>方法定义了我们上面所讲到的背压机制，并且一次调用可以产生多个元素。使用它创建Flux的实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                sink.next(<span class="string">&quot;Tang&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符"><a class="header-anchor" href="#操作符">¶</a>操作符</h3><p>这里只列举出一些简单常用的操作符，包括<code>buffer</code>，<code>window</code>，<code>take</code>……</p><h4 id="buffer"><a class="header-anchor" href="#buffer">¶</a>buffer</h4><p><code>buffer</code>以及其相关的操作符都是将当前流中的元素收集到集合中，并把集合对象作为流中的新元素。buffer 相关操作符的使用示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).buffer(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">Flux.intervalMillis(<span class="number">100</span>).bufferMillis(<span class="number">1001</span>).take(<span class="number">2</span>).toStream().forEach(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferUntil(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferWhile(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="filter"><a class="header-anchor" href="#filter">¶</a>filter</h4><p>响应式流中的<code>filter</code>操作符和stream流中的<code>filter</code>操作符的作用以及使用是差不多甚至是一样的，就不在赘述了</p><h4 id="window"><a class="header-anchor" href="#window">¶</a>window</h4><p><code>window</code>操作符的作用类似于<code>buffer</code>，所不同的是<code>window</code>操作符是将当前流中的元素收集到另外的Flux序列汇总，一次返回值类型是<code>Flux&lt;Flux&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).window(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">Flux.intervalMillis(<span class="number">100</span>).windowMillis(<span class="number">1001</span>).take(<span class="number">2</span>).toStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="take"><a class="header-anchor" href="#take">¶</a>take</h4><p><code>take</code>系列操作符用来从当前流中提取元素，提取的方式可以用很多种</p><p>这里的提取，无非就是一些消费</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">takeLast(<span class="type">long</span> n)：提取流中的最后 N 个元素。</span><br><span class="line">takeUntil(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)：提取元素直到 Predicate 返回 <span class="literal">true</span>。</span><br><span class="line">takeWhile(Predicate&lt;? <span class="built_in">super</span> T&gt; continuePredicate)： 当 Predicate 返回 <span class="literal">true</span> 时才进行提取。</span><br><span class="line">takeUntilOther(Publisher&lt;?&gt; other)：提取元素直到另外一个流开始产生元素。</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a class="header-anchor" href="#flatMap">¶</a>flatMap</h4><p><code>flatMap</code>可以说是经常使用的操作符了</p><p><code>flatMap</code>和<code>flatMapSequential</code>操作符吧流中的每一个元素转换成一个流，在吧所有流中的元素进行合并</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        .flatMap(x -&gt; Flux.intervalMillis(x * <span class="number">10</span>, <span class="number">100</span>).take(x))</span><br><span class="line">        .toStream()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>到这里，响应式流的操作符(API)，就差不多(其实差的还是有点多~ . ~)了</p><h2 id="RSocket"><a class="header-anchor" href="#RSocket">¶</a>RSocket</h2><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><p>我们知道常用的HTTP协议的优势在于其广泛的适用性，有很多的服务器和客户端实现工具的支持，但是HTTP协议本身比较简单，只支持<strong>请求-响应</strong>模式，而这种模式对于很多应用场景来说是不合适的</p><p>比如说消息推送</p><blockquote><p>以HTTP为例，如果客户端需要获取最新的推送消息，就必须使用轮询。客户端不断地发送请求到服务器来检查更新，这无疑造成了大量的资源浪费。</p></blockquote><p>这个时候，响应式规范后面的开发团队理解了</p><ol><li>跨网络</li><li>异步</li><li>低延迟通信</li></ol><p>的必要性了。</p><p>2015年，<strong>RSocket</strong>协议就在这样的背景下，破壳……</p><p>RSocket是一个二进制的协议，以异步消息的方式提供4种交互模式</p><ul><li>请求-响应模式：这个也是最经典也最常见的模式，发送方在发送消息给接收方之后，等待与之对应的响应消息</li><li>请求-响应<strong>流</strong>模式：以消息流作为响应</li><li>即发-即忘模式：发送方的请求消息没有与之对应的响应</li><li>通道模式：在发送方和接收方之间建立一个双向传输的通道</li></ul><h3 id="如何使用"><a class="header-anchor" href="#如何使用">¶</a>如何使用</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.rsocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rsocket-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.rsocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rsocket-transport-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想以Spring框架集成</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-rsocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>构建一个简单的<code>DemoController</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@MessageMapping(&quot;hello&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">hello</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.just(<span class="string">&quot;Hello: &quot;</span> + input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>@MassageMapping</code>是Spring提供的一个注解，用来指定WebSocket、RSocket等协议中消息处理的目的地</p><p>为了访问这个RSocket端点，我们需要创建一个<code>RSocketRequester</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RSocketRequester.Builder builder;</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">RSocketRequester</span> <span class="variable">requester</span> <span class="operator">=</span> builder.dataMimeType(MimeTypeUtils.TEXT_PLAIN)</span><br><span class="line">                .connect(TcpClientTransport.create(<span class="number">7000</span>)).block();</span><br><span class="line"></span><br><span class="line">    Mono&lt;String&gt; response = requester.route(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">            .data(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">            .retrieveMono(String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成中间件"><a class="header-anchor" href="#集成中间件">¶</a>集成中间件</h2><ul><li>MongoDB集成</li><li>Redis集成</li><li>R2DBC集成</li><li>MQ集成</li><li>……</li></ul><p>这里关于中间件的集成，我更愿意给出类似于官方的官方<a href="https://hantsy.github.io/spring-reactive-sample/">文档</a></p><p>这里面包含了中间件的继承过程</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221211091923548.png" alt="image-20221211091923548"></p><h2 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h2><p>相对于WebMVC这样一个众所周知的，在全世界有超过十年以上的广泛应用的框架，WebFlux倒是显得有点乳臭了。</p><p>毕竟，对异步、非阻塞的编程，不管是在编码上，维护上，还是在调试上都是一件很困难的事情。因为异步编程是基于回调的，由一个时间循环驱动，在尝试跟踪请求时，事件循环的堆栈跟踪毫无意义。正是因为处理的是事件和回调，很少用工具可以帮助调试。</p><p>边界情况、未处理的异常以及错误处理的状态更改会创建悬空资源，从而导致内存泄漏、文件描述符泄漏或丢失响应等……</p><p>以后：</p><blockquote><p>尽可能的适应，并采用响应式编程来代替目前的编程模型，达到全栈式的响应式应用程序的编写。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 响应式编程 </category>
          
          <category> WebFlux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二寒假TOTO-LIST</title>
      <link href="/2022/12/07/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87TOTO-LIST/"/>
      <url>/2022/12/07/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87TOTO-LIST/</url>
      
        <content type="html"><![CDATA[<h1>大二寒假TOTO-LIST</h1><p>2022-12-7 19:08:45</p><h2 id="技术栈"><a class="header-anchor" href="#技术栈">¶</a>技术栈</h2><ul><li><p>[x] WebFlux</p><ul><li>[x] Reactor操作</li><li>[x] 集成组件<ul><li>[ ] Redis</li><li>[x] MongoDB</li><li>[ ] R2DBC</li><li>[ ] MQ</li></ul></li></ul></li><li><p>[ ] 并发编程</p><ul><li>[ ] Java并发线程池底层原理</li><li>[ ] JUC并发集合底层原理</li><li>[ ] CASAtomic</li><li>[ ] JMM并发三大特性</li><li>[ ] 锁机制</li></ul></li><li><p>[ ] Mysql-Tomcat</p><ul><li>[ ] Mysql性能优化</li><li>[ ] Tomcat整体机构</li><li>[ ] Tomcat线程模型</li></ul></li><li><p>[ ] Jvm</p><ul><li>[ ] JVM类加载机制</li><li>[ ] JVM对象创建和内存分配机制</li><li>[ ] class字节码文件结构</li><li>[ ] 垃圾回收</li><li>[ ] JVM调优</li><li>[ ] JTM</li><li>[ ] Cloud-Native Java虚拟</li><li>[ ] Hotspot</li></ul></li><li><p>[ ] Redis</p><ul><li>[ ] Cluster集群</li><li>[ ] 核心数据结构</li><li>[ ] 分布式锁</li></ul></li><li><p>[ ] MongoDB(暂定)</p></li><li><p>[ ] Sharding-Sphere</p><ul><li>[ ] 简单实操——不准备研究源码以及于原理</li><li>[ ] Sharding-Proxy （?暂定）</li></ul></li><li><p>[ ] Netty</p><ul><li>[ ] 常见的组件使用</li><li>[ ] 核心线程模型</li><li>[ ] 底层数据交互</li></ul></li></ul><p>我不准备在这个时间段去研究源码，一是因为我本来就是个不爱看书的人，直接喊我去看源码，研究别人怎么实现的大概率会打瞌睡，二是顾虑到怕本来底层都没研究清楚就去看源码的话，到时候说不定会本末倒置……</p><h2 id="课程学习"><a class="header-anchor" href="#课程学习">¶</a>课程学习</h2><p>说来好笑，本就已经不听课了，但奈何nmmd邮专非得下学期来了才考试，非暑假复习不可，不然得挂了，我还是想明年的这个时候还是有至少1000的慰藉吧。</p><ul><li>线性代数</li><li>数据结构</li><li>大学物理</li><li>编程基础</li><li>离散数学</li><li>CET6</li><li>工程伦理</li><li>工程管理与经济决策</li></ul><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>等到时候要开学了我再来写……</p>]]></content>
      
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地虚拟机搭建k8s集群</title>
      <link href="/2022/11/19/%E6%9C%AC%E5%9C%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/11/19/%E6%9C%AC%E5%9C%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1>本地虚拟机搭建k8s集群</h1><p>为什么是虚拟机呢</p><ul><li>没钱</li><li>没钱</li><li>…</li></ul><p>其实就是没钱买aliyun下同网段的机器，目前只有一个马ht机器，和阿里机器，没有在一个网段上，而虚拟机正好可以很简单直接的解决我的问题</p><p>开始之前，部署k8s集群的机器要满足：</p><ul><li>一台或多台机器</li><li>2GB或者更多的RAM，2个或者更多CUP，30G以上的ROM</li><li>集群中所有机器之前可以网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h2 id="准备好Linux"><a class="header-anchor" href="#准备好Linux">¶</a>准备好Linux</h2><h3 id="首先：得到一-多-份双网卡Centos"><a class="header-anchor" href="#首先：得到一-多-份双网卡Centos">¶</a>首先：得到一(多)份双网卡Centos</h3><p>创建虚拟机的过程就不说了</p><p>这里就直接说配置静态id</p><h4 id="查看本地Vmnet8"><a class="header-anchor" href="#查看本地Vmnet8">¶</a>查看本地Vmnet8</h4><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221119095421318.png" alt="image-20221119095421318" style="zoom:75%;" align="left" /><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221119095700546.png" alt="image-20221119095700546" align="left"   /><p>偶对了，在创建虚拟机的时候，选择网卡：Vmnet8，这样才能联通网</p><h4 id="接着修改ip地址"><a class="header-anchor" href="#接着修改ip地址">¶</a>接着修改ip地址</h4><p><strong>进入存放修改ip地址的目录：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><p><strong>修改文件：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></table></figure><ol><li><p>修改BOOTPROTO=static</p></li><li><p>在下面添加内容：IP地址、子网掩码、网关、dns服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IPADDR=192.168.75.100 ——&gt; 前面三个和网关一样</span><br><span class="line">GATEWAY=192.168.75.2 ——&gt; 上面提到的Gateway</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=218.4.4.4</span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure></li></ol><p><strong>重启网络服务</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h3 id="再配置免密登录-远程连接"><a class="header-anchor" href="#再配置免密登录-远程连接">¶</a>再配置免密登录+远程连接</h3><p>先鸽…</p><p>2022-11-19 12:10:31</p><h2 id="开始搭建集群"><a class="header-anchor" href="#开始搭建集群">¶</a>开始搭建集群</h2><h3 id="安装docker环境"><a class="header-anchor" href="#安装docker环境">¶</a>安装docker环境</h3><ol><li><p>移除以前docker的相关包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li><li><p>配置yum源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装docker(这里安装的是20.10.7版本的)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以下是在安装k8s的时候使用</span></span><br><span class="line">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure></li><li><p>配置加速</p><blockquote><p>这里额外添加了docker的生产环境核心配置cgroup</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://82m9ar63.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>docker环境成功，可以试一试命令了…</p></li></ol><h3 id="安装kubectl、kubeadm、kubelet"><a class="header-anchor" href="#安装kubectl、kubeadm、kubelet">¶</a>安装kubectl、kubeadm、kubelet</h3><h4 id="基础环境"><a class="header-anchor" href="#基础环境">¶</a>基础环境</h4><blockquote><p>所有机器都要执行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">各个机器设置自己的域名</span></span><br><span class="line">hostnamectl set-hostname xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭swap</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许 iptables 检查桥接流量</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><h3 id="使用kubeadm引导集群"><a class="header-anchor" href="#使用kubeadm引导集群">¶</a>使用kubeadm引导集群</h3><h4 id="下载各个机器需要的镜像"><a class="header-anchor" href="#下载各个机器需要的镜像">¶</a>下载各个机器需要的镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tee ./images.sh &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName</span><br><span class="line">done</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure><h4 id="初始化主节点"><a class="header-anchor" href="#初始化主节点">¶</a>初始化主节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有机器添加master域名映射，以下需要修改为自己的</span></span><br><span class="line">echo &quot;172.31.0.4  cluster-endpoint&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主节点初始化</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=172.31.0.4 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有网络范围不重叠</span></span><br></pre></td></tr></table></figure><p>接下来就会：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and then running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3</span><br></pre></td></tr></table></figure><p>看到里面说：<code>Alternatively, if you are the root user, you can run:</code>吧</p><p>那就执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>这样，主节点就初始化完成了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看集群所有节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据配置文件，给集群创建资源</span></span><br><span class="line">kubectl apply -f xxxx.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看集群部署了哪些应用？</span></span><br><span class="line">docker ps   ===   kubectl get pods -A</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行中的应用在docker里面叫容器，在k8s里面叫Pod</span></span><br><span class="line">kubectl get pods -A</span><br></pre></td></tr></table></figure><h4 id="安装网络组件"><a class="header-anchor" href="#安装网络组件">¶</a>安装网络组件</h4><p>这里选择<code>calico</code>当然也可以选择<code>flannel</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果你使用的是1.20版本的k8s，可安装v3.21版本的Calico，</span><br><span class="line">curl https://docs.projectcalico.org/archive/v3.21/manifests/calico.yaml -O</span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><p>这样就会创建<code>calico</code>的<code>deployment</code>，等待所有的<code>pod</code>都<code>running</code>过后，就让node加入集群</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token x5g4uy.wpjjdbgra92s25pp \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:6255797916eaee52bf9dda9429db616fcd828436708345a308f4b917d3457a22</span><br></pre></td></tr></table></figure><p>一系列操作完了过后，就可以在集群节点状态中看到两个节点的<code>Ready</code>了</p><h3 id="部署dashboard"><a class="header-anchor" href="#部署dashboard">¶</a>部署dashboard</h3><blockquote><p>k8s官方提供的可视化界面</p><p><a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>如果下不了就：</p><ol><li><code>vim recommended.yaml</code></li><li><code>kubectl apply -f recommended.yaml</code></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright 2017 The Kubernetes Authors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-csrf</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">csrf:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-key-holder</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-settings</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get, update and delete Dashboard exclusive secrets.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;kubernetes-dashboard-key-holder&quot;</span>, <span class="string">&quot;kubernetes-dashboard-certs&quot;</span>, <span class="string">&quot;kubernetes-dashboard-csrf&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">    <span class="comment"># Allow Dashboard to get and update &#x27;kubernetes-dashboard-settings&#x27; config map.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;configmaps&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;kubernetes-dashboard-settings&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">    <span class="comment"># Allow Dashboard to get metrics.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;services&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;heapster&quot;</span>, <span class="string">&quot;dashboard-metrics-scraper&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;proxy&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;services/proxy&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;heapster&quot;</span>, <span class="string">&quot;http:heapster:&quot;</span>, <span class="string">&quot;https:heapster:&quot;</span>, <span class="string">&quot;dashboard-metrics-scraper&quot;</span>, <span class="string">&quot;http:dashboard-metrics-scraper&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Metrics Scraper to get metrics from the Metrics server</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;metrics.k8s.io&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>, <span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubernetesui/dashboard:v2.3.1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--auto-generate-certificates</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--namespace=kubernetes-dashboard</span></span><br><span class="line">            <span class="comment"># Uncomment the following line to manually specify Kubernetes API server Host</span></span><br><span class="line">            <span class="comment"># If not specified, Dashboard will attempt to auto discover the API server and connect</span></span><br><span class="line">            <span class="comment"># to it. Uncomment only if the default does not work.</span></span><br><span class="line">            <span class="comment"># - --apiserver-host=http://my-address:port</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/certs</span></span><br><span class="line">              <span class="comment"># Create on-disk volume to store exec logs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">1001</span></span><br><span class="line">            <span class="attr">runAsGroup:</span> <span class="number">2001</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;kubernetes.io/os&quot;:</span> <span class="string">linux</span></span><br><span class="line">      <span class="comment"># Comment the following tolerations if Dashboard must not be deployed on master</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">seccomp.security.alpha.kubernetes.io/pod:</span> <span class="string">&#x27;runtime/default&#x27;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubernetesui/metrics-scraper:v1.0.6</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8000</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">1001</span></span><br><span class="line">            <span class="attr">runAsGroup:</span> <span class="number">2001</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;kubernetes.io/os&quot;:</span> <span class="string">linux</span></span><br><span class="line">      <span class="comment"># Comment the following tolerations if Dashboard must not be deployed on master</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>启动pod过后，就可以设置访问端口：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><blockquote><p>type: ClusterIP 改为 type: NodePort</p></blockquote><p><strong>完了过户，执行下面的命令找到端口：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get svc -A |grep kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 找到端口，在安全组放行</span></span></span><br></pre></td></tr></table></figure><p>这样就可以在任何节点通过<code>host+port</code>访问<code>dashboard</code>了</p><p>但是我们还需要一个访问账号</p><p><strong>创建访问账号</strong></p><ol><li><code>vim dash.yaml</code></li><li><code>kubectl apply -f dash.yaml</code></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建访问账号，准备一个yaml文件； vi dash.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p><strong>执行下面命令获取访问token</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取访问令牌</span></span><br><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=&quot;&#123;.secrets[0].name&#125;&quot;) -o go-template=&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6InpXSkU0TjhCUmVKQzBJaC03Nk9ES2NMZ1daRTRmQ1FMZU9rRUJ3VXRnM3MifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXgyczhmIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzOTZmYjdlNS0wMjA2LTQxMjctOGQzYS0xMzRlODVmYjU0MDAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.Hf5mhl35_R0iBfBW7fF198h_klEnN6pRKfk_roAzOtAN-Aq21E4804PUhe9Rr9e_uFzLfoFDXacjJrHCuhiML8lpHIfJLK_vSD2pZNaYc2NWZq2Mso-BMGpObxGA23hW0nLQ5gCxlnxIAcyE76aYTAB6U8PxpvtVdgUknBVrwXG8UC_D8kHm9PTwa9jgbZfSYAfhOHWmZxNYo7CF2sHH-AT_WmIE8xLmB7J11vDzaunv92xoUoI0ju7OBA2WRr61bOmSd8WJgLCDcyBblxz4Wa-3zghfKlp0Rgb8l56AAI7ML_snF59X6JqaCuAcCJjIu0FUTS5DuyIObEeXY-z-Rw</span><br></pre></td></tr></table></figure><p><strong>进入</strong><code>dashboard</code></p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221119123545481.png" alt="image-20221119123545481" style="zoom:150%;" /><h1>⭐完成~⭐</h1>]]></content>
      
      
      <categories>
          
          <category> k8s </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 运维 </tag>
            
            <tag> k8s </tag>
            
            <tag> 部署 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式锁Redisson</title>
      <link href="/2022/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Redisson/"/>
      <url>/2022/11/12/%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81Redisson/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Redis主从、哨兵</title>
      <link href="/2022/11/10/%E6%B5%85%E8%B0%88Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5/"/>
      <url>/2022/11/10/%E6%B5%85%E8%B0%88Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="主从"><a class="header-anchor" href="#主从">¶</a>主从</h2><p>先说说主从吧。单机的Redis，能够承载的QPS就在上万到几万不等。但对于缓存来说，本来就是用于高并发的读写的，毕竟不像Mysql那样。</p><p>因此，需要将架构提升到，主从(master-slave)架构：一主多从，主读，从写，达到读写分离的效果。所有的读的请求全部走从节点，也可以很轻松的实现水平扩容，支撑住高并发。</p><h3 id="Redis-replication-的核心机制"><a class="header-anchor" href="#Redis-replication-的核心机制">¶</a>Redis replication 的核心机制</h3><ul><li>Redis采用异步的方式复制数据到<code>slave</code>节点，(从Redis2.8开始，slave node 会周期性地确认自己和master node上的数据是否保持一致)</li><li>一个master node 可以配置多个slave node</li><li>slave node 也可以连接其他的 slave  node（slave node 之间的通讯）</li><li>slave node 节点在复制数据的时候，不会 block master node</li><li>slave node 节点在复制数据的时候，也不会block 自己的查询操作，它会先用之前的旧数据集来提供服务；<br>但是复制完成的时候，需要删除旧数据集，这个时候就会暂停对外服务了；</li></ul><p>有一点挺重要的，如果采用了master—slave架构，<strong>那么建议开启 master node 的持久化</strong>，<strong>并且不建议使用 slave node 做 master node 的数据热备</strong>，因为那样的话，如果我们关闭了master的持久化，可能在master重启的时候数据是空的，那么slave复制过来的数据也是空的，数据丢失。</p><h3 id="Redis-主从复制的原理"><a class="header-anchor" href="#Redis-主从复制的原理">¶</a>Redis 主从复制的原理</h3><p>当启动一个slave node 时，他会发送一个<code>PSYNC</code>命令给master node</p><ol><li>slave连接到master ——&gt; 触发一次 <code>full resynchronization</code>全复制</li><li>master就启动一个后台线程，生成一份<code>RDB</code>快照文件 ——&gt; 发给slave</li><li>然后slave node 收到这个快照文件过后，将他写入磁盘中。完了过后，将这份数据持久到内存中。</li><li>紧接着，master会讲 <strong>内存中 缓存的 写命令</strong> 发送到slave，slave会同步这些数据。</li></ol><p>如果slave node 跟master node 出现了网络故障，断开了连接，会自动重连，重连过后 master node 仅仅会复制给slave部分缺少的数据</p><h3 id="主从复制的断点续传"><a class="header-anchor" href="#主从复制的断点续传">¶</a>主从复制的断点续传</h3><blockquote><p>从Redis2.8开始，Redis就支持所谓的<strong>主从复制的断点续传</strong></p></blockquote><p>什么意思呢，如果主从复制的过程当中，由于网络IO等各种原因，导致复制过程中断，那么可以接着上次复制的点，继续复制下去，而不是从头开始复制一份</p><p><strong>原理如下：</strong></p><blockquote><p>master node  会在内存中维护一个<code>backlog</code>，master 和 slave 都会保存一个 <code>replica offset</code>还有一个个<code>master run id</code> ，<code>offset</code>就是保存在<code>backlog</code>中的</p><p><code>backlog</code>中，如果master和slave网络中断了，slave会让master从上次<code>replica offset</code>开始继续复制，如果没有找到对应的<code>offset</code>，那么就会执行一次<code>resynchronization</code></p><p>如果根据<code>host+ip</code>定位master node ，是不靠谱的，土规 master node  重启或者数据出现了变化，那么slave node 应该根据不同的run id区分</p></blockquote><h3 id="过期Key的处理"><a class="header-anchor" href="#过期Key的处理">¶</a>过期Key的处理</h3><p>slave 不会过期key，主从主从，仆人肯定是听从主人的嘛，slave只会等待master过期key。如果master过期了一个key，后者通过LRU淘汰了一个key，那么会模拟一条类似于<code>del</code>的指令发送给slave去删除过期的kwy</p><h3 id="那么Redis如何才能做到高可用呢"><a class="header-anchor" href="#那么Redis如何才能做到高可用呢">¶</a>那么Redis如何才能做到高可用呢</h3><p>如果一个系统在356天，有99.99%的时间内，都是可以对外提服务的，那么就是说这个系统是高可用的</p><p>一个slave挂掉了，是不会影响到系统的可用性，因为还有其他的slave在提供服务</p><p>那么，吐过master node 寄了呢，没办法写数据了，写缓存的时候，全部都是失效了。slave node 就没什么作用了，毕竟没有master 给他们复制数据了，这就是所谓群龙无首，遮掩搞得系统相当于不可用</p><hr><p>这就需要设计Redis的高可用架构，<strong>故障转移</strong>，也可以叫做<strong>主备切换</strong></p><p>存在故障转移过后，master node 寄，系统自动监测，并且将某个slave node 自动切换为 master node ，类似于继承？或者说是选举更合适一点。</p><p>这个过程中，就实现了Redis 的主从架构的高可用。</p><p>要完成这样的架构设计，就需要接下来要说到了哨兵机制了……</p><h2 id="哨兵"><a class="header-anchor" href="#哨兵">¶</a>哨兵</h2><h3 id="什么是哨兵？"><a class="header-anchor" href="#什么是哨兵？">¶</a>什么是哨兵？</h3><blockquote><p>Sentinle，中文名是哨兵</p></blockquote><p>哨兵是Redis集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控Redis master node 和 slave node 是否正常工作</li><li>消息通知：如果某个node有故障，那么哨兵负责发送消息作为警报通知给Mng</li><li>故障转移：如果master node 寄了，会自动将某个slave node 选举为 新的master</li><li>配置中心：如果股中航转移发生了，通知client客户端新的master的<code>address</code></li></ul><p>哨兵是用来实现Redis集群的高可用的，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作</p><ul><li>故障转移的时候，判断一个master node 是否宕机了，需要大部分的哨兵都同意才可以，涉及到了分布式的选举的问题了，这个后面会提</li><li>即使部分哨兵的node 寄了，哨兵集群还是能正常工作的</li></ul><p>介绍完哨兵是什么过后，来说说哨兵的核心知识</p><h3 id="哨兵的核心知识"><a class="header-anchor" href="#哨兵的核心知识">¶</a>哨兵的核心知识</h3><ol><li>哨兵至少需要3个实例，来保证自己的健壮性</li><li>哨兵+Redis主从的部署架构，是保证数据不丢失的，只能保障Redis集群的高可用性</li></ol><p>哨兵集群必须部署2个以上的节点，如果哨兵集群仅仅部署了2个哨兵实例，quorum = 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure><p>配置<code>quorum = 1</code>，如果，master宕机了，s1 s2 中只能有1个哨兵认为master宕机了，就可以进行切换，同时s1 和 s2 会选举出一个哨兵来执行故障转移，但是同时这个时候，需要<code>majority</code>，也就是大多数哨兵都是运行的，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 个哨兵，majority=2</span><br><span class="line">3 个哨兵，majority=2</span><br><span class="line">4 个哨兵，majority=2</span><br><span class="line">5 个哨兵，majority=3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说到这里，什么是<code>quorum</code>和<code>majority</code>呢</p><h4 id="quorum和majority"><a class="header-anchor" href="#quorum和majority">¶</a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为<code>odown</code>，然后选举出一个哨兵来做切换，这个哨兵还需要得到majority哨兵的授权，才能正式执行切换</p><ul><li>如果quorum &lt; majority ， 比如说 5个哨兵， majority = 3， quorum = 2，那么3个哨兵授权就可以执行切换</li><li>但是如果 quorum &gt;= majority，那么必须quorum 数量的哨兵都授权，比如5个哨兵，quorum = 5 ，那么必须5个哨兵都同意授权，才能执行切换</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> 缓存 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通讯与TPC/IP</title>
      <link href="/2022/10/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8ETPC-IP/"/>
      <url>/2022/10/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8ETPC-IP/</url>
      
        <content type="html"><![CDATA[<h1>网络通信与TCP/IP</h1><p>什么是计算机的网络？<br>老套路、官方话：</p><blockquote><p>利用通信线路将地理上分散的、具有独立功能的计算机系统和通信设备按不同的形式连接起来，以功能完善的网络软件及协议实现资源共享和信息传递的系统。</p></blockquote><p><strong>主要的网络</strong>：</p><ol><li>局域网</li><li>城域网</li><li>广域网</li><li>无线网</li><li>…</li></ol><p>P话就不多说了，直接进入主题吧</p><p>首先是，网络通讯的鼻祖、<strong>OSI七层模型</strong>：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015165435767.png" alt="image-20221015165435767" align="left" style="zoom: 50%;" /><p>再到我们现在的<strong>TCP/IP五层模型</strong>：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015165526473.png" alt="image-20221015165526473"  align="left" style="zoom:71%;" /><p>从图片中可以看出来，TCPIP只是把OSI的上三层合并为了一层，应用层。</p><p>方便记忆：</p><ul><li>应用层：平时我们访问使用的http(bushi)、https协议；或者远程连接的Mysql；远程连接的SSH…</li><li>传输层：<ul><li>TCP协议：面向连接的、可靠的流协议</li><li>UDP协议：面向无连接的通讯协议</li></ul></li><li>网络层：IP地址</li><li>数据链路层：硬件驱动程序，追究到底还是</li><li>物理层：网卡</li></ul><p>有些说法是吧最底层的物理层+数据链路层合成一层，但其实不是…</p><h2 id="浅谈TCP-UDP"><a class="header-anchor" href="#浅谈TCP-UDP">¶</a>浅谈TCP/UDP</h2><p>从上文看到，TCP协议是面向连接的、可靠的流协议；而UDP是面向无连接的通讯协议</p><p>TCP首先是要建立连接的，他会有我们平常所说的3次握手，</p><p>为什么要建立连接呢？</p><blockquote><p>1.更好的保证可靠性: 建立连接的过程其实就是让通信双方验证各自的发送能力和接受能力是否正常<br>2.协商一些重要参数 (如: 序号的初始值)</p></blockquote><p>具体怎么建立连接？</p><blockquote><p>栗子：</p><p>A给B打电话，打电话同样要同样给自己以及对方的话筒是否正常工作</p><p>第一次握手：刚开始，A不知道自己和B书籍的听筒的话筒是否正常，所以A说：“喂喂喂？？？”</p><p>第二次握手：B听到过后，说明A的话筒和B的听筒正常，但B还需要进一步的检查自己的话筒是否正常；同时B吧A话筒正常和自己听筒正常的消息传给A；于是B：”干嘛？你爹！”</p><p>第三次握手：A收到了B的消息后，就证明了A听筒正常，B听筒正常</p></blockquote><p>这就类似于网络建立连接的三次握手…</p><p>所以，网络中传输数据整体过程是这样的：</p><blockquote><p>又是一个栗子：在消息发送的过程中</p><p>首先我们吧消息编辑好，点击发送button，此时，这个消息还处于<strong>应用层</strong>。点击button后，进入传输层，被解析成，计算机唯一认识的01二进制，再加上大概20个字节的TCP首部，形成<strong>报文</strong>，或者是所谓的<strong>消息</strong>；</p><p>然后，传进网络层，加上IP包首部——&gt;报文段</p><p>传进数据链路层，加上以太网首部——&gt;数据报</p><p>最后进入物理层，通过网卡等硬件，带上型信号，传进以太网电缆。</p><p>等这个<strong>帧</strong>，被甲方接收到过后，通过以上的顺序的反解析，一步一步脱壳成最初我们所编辑的数据包，展示在甲方的应用层上。这时，甲方手机上显现一个：“我是你爹”<br>的时候就</p><p>完成的数据(消息)的传输</p></blockquote><hr><p><strong>而UDP</strong></p><p>他最主要的特点就是、UDP是无连接的，就是发送数据之前不需要建立连接，这也是与TCP协议的本质区别，当然，发送数据结束的时候也没有连接可以释放，一次，就减少了开销和发送数据之前的延迟，</p><p>目前QQ，微信，语音电话、视频……之类的通讯大都基于UDP的通信协议，因为大都人不会因为你那一个像素点，一句话两句话听不清楚就抱怨什么(没有针对一些比较紧急的场景)</p><h2 id="网络通讯中的地址与端口号"><a class="header-anchor" href="#网络通讯中的地址与端口号">¶</a>网络通讯中的地址与端口号</h2><h3 id="地址Address"><a class="header-anchor" href="#地址Address">¶</a>地址Address</h3><ul><li>IP地址和MAC地址</li></ul><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015185133497.png" alt="image-20221015185133497" align="left" style="zoom:60%; " /><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015185221395.png" alt="image-20221015185221395" align="left" style="zoom:50%; " /><p>打开<strong>win</strong>的<strong>powerShell</strong>，输入：<code>ipconfig</code>可以看到自己设备信息</p><p>这里的物理地址就是MAC地址。MAC地址是厂商开始创建这个设备的时候就将其写在点的硬件上的。所以每个设备只有一个MAC地址，还是不能修改的(除非说是你通过物理手段，修改BIOS，修改MAC地址)，所以MAC地址实在TCP的数据链路层上用的，也可以理解成数据链路层的地址。</p><p>看到我电脑上无线局局域网Adapter (WALN) 下的MAC地址是：E0-D4-64-31-CA-13，前一半是<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A">IEEE</a>给每个厂商一个，后面一半由厂商自己分配</p><p>IPV4就不用说了，没有IPV4是没法上网的，这个东西要么手动获取，要么DHCP服务器给分配IPV4</p><ul><li><p>MAC地址与IPV4的区别</p><blockquote><ol><li>MAC地址不能随意更换，IPV4可以</li><li>MAC地址48位，IPV4是32位</li><li>MAC地址工作在数据链路层，IPV4工作在网络层</li></ol></blockquote></li></ul><h3 id="端口Port"><a class="header-anchor" href="#端口Port">¶</a>端口Port</h3><p>官方：</p><blockquote><p>用来识别同一台计算机设备设备中不同的应用程序，也被称之为应用程序地址</p></blockquote><ul><li><p>为什么端口号有65535个？</p><blockquote><p>因为TCP和UDP协议里面报文头中吗，有专门的的字段来存这个端口号，这个字段头只有2个字节，2^16 = 65536 ，但是一般端口0只带本设备上所有的端口。</p><p>所以端口号只有65536 - 1 =  65535个</p></blockquote></li><li><p>一台设备上最多只能有65535个TCP连接嘛？</p><blockquote><p>这是可笑的，</p><p>一个栗子：现有10个客户端连接一台机器上的Mysql，Mysql也只是接收到了3306这个端口上发送来的数据，</p><p>所以，一台设备上所能接收到的链接，与端口号数没有必然关系。</p></blockquote></li></ul><p>再者，一个通讯在网络中是由5个元组识别：</p><ol><li>源IP</li><li>目标IP</li><li>TCP协议号</li><li>源端口</li><li>目标端口</li></ol><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015200329440.png" alt="image-20221015200329440"></p><h3 id="TCP三次握手建立连接"><a class="header-anchor" href="#TCP三次握手建立连接">¶</a>TCP三次握手建立连接</h3><p>图片来自：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=65&amp;vd_source=61258a05469482a4381c086011c25c18">https://www.bilibili.com/video/BV1c4411d7jb?p=65&amp;vd_source=61258a05469482a4381c086011c25c18</a></p><p>TCP报文的首部格式</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015203150879.png" alt="image-20221015203150879"></p><p>至于三次握手的流程我就懒得用文字来描述了，用图片的方式可能更好记忆一点(可能纯粹就是懒吧…)</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015204050802.png" alt="image-20221015204050802" align="left" style="zoom:70%;" />其中SYN是TCP报文里面某一个bit的站位标志。</p><p>出于这样的连接方式，TCP的三次握手也是会有漏洞，——SYN洪泛攻击</p><p><strong>SYN洪泛攻击</strong>，是通过网络服务所在的端口发送大量伪造源地址的攻击报文，发送到服务端，造成服务端上的<strong>半开连接</strong>，队列被占满，从而组织其他用户进行访问。</p><p><strong>原理</strong></p><blockquote><p>攻击者客户端利用为伪造的IP地址想服务端发出请求(第一次)。而服务端的响应(第二次)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(其实永远不会有的，毕竟是伪造的)，服务端在这种半开的链接过程中小号了资源，如果有成千上万的这样链接，主机资源将被耗尽，从而发达到攻击的目的，就有点像DDOS攻击，都是发送大量的数据包。</p></blockquote><p><strong>解决方案</strong></p><blockquote><ul><li>无效连接监控释放</li><li>延缓TCB分配方法</li><li>防火墙</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计网 </category>
          
          <category> 重修 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-所有权</title>
      <link href="/2022/10/03/Rust-%E6%89%80%E6%9C%89%E6%9D%83/"/>
      <url>/2022/10/03/Rust-%E6%89%80%E6%9C%89%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>在所有程序执行过程中，与计算机内存的暧昧行为早已被默认。但如何与其保持着敌进我退，敌退我进的距离，——在内存中申请内存来执行程序；在执行完过后，不需要的时候再释放这段内存，成为了重中之重。这也是设计编程语言过程中的一座高山。于是，三种主流的模式应运而生：</p><ul><li><p>GC：垃圾回收机制，在程序运行的同时，无时无刻的想办法找那些不被利用，并且以后也不再使用的内存，回收起来，例如最经典的Java(Jvm)，Go，C#</p></li><li><p>显示操作：回收，申请内存这些操作改成了由程序员自己手动操作，(比起GC的耗性能，我果然还是接收不了自己手动操作对象空间的申请与释放)，C++</p></li><li><blockquote><p><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查(这里就直接把原话复制过来吧)</p></blockquote></li></ul><p>而Rust正好就是第三种，对内存的管理机制——<strong>所有权</strong></p><p>这种机制，早在编译的时候就确立好了这段内存由谁来支配，大大的挽回了内存的损失。</p><hr><p>在说所有权之前先谈谈栈和堆吧</p><h3 id="栈、堆"><a class="header-anchor" href="#栈、堆">¶</a>栈、堆</h3><ul><li><p>栈</p><blockquote><p>这个东西，数据结构的角度看栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表的子集。他们是操作受限的线性表…</p><p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。出于这样的存储方式，在栈中的数据必须有明确的大小，并且在之后的操作中不得改变(明确，固定)，假设数据是未知的，那么在取出数据时，将无法获取想要的数据。</p></blockquote></li><li><p>堆</p><blockquote><p>相对于栈，我们(哪儿来的们🐟)对堆的认识往往并不多，可能是出于平常使用的编程语言并不要求我们对栈堆有多大的掌握。扯远了…</p><p>与栈不同，对于未知数据的存储，我们需要将它存到堆中。在存数据的过程中，OS首先在堆中找到一份它觉得合适大小的空间，将它标记为——&gt;已使用，并返回这段空间的指针地址，该过程称之为——&gt;<strong>分配</strong>。接着，让数据占用这段空间。</p><p>当我们访问这段空间想拿到数据时，只需要找到刚刚被分配到栈中的指针，去找地址就好了。</p><p>(这个例子以后还会提到)就好像我们去餐厅吃饭，服务员问我们几个人，我们说6个，那她就会带我们去大概6 7个位置左右的餐桌，这个过程就是分配。完了过后，要是有人迟到了，想找到我们，只需要我们发短信给他一个餐桌号，他就可以顺利的找到我们，这个过程就是拿数据。</p></blockquote></li></ul><h3 id="所有权机制"><a class="header-anchor" href="#所有权机制">¶</a><strong>所有权机制</strong></h3><blockquote><ul><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</li></ul></blockquote><h3 id="浅谈一下String"><a class="header-anchor" href="#浅谈一下String">¶</a>浅谈一下String</h3><p>在rust里面，当我们在编译器里输入<code>let s =&quot;hello&quot;</code>时，s这个变量是直接被硬编码到程序里面去的(类型为：<code>&amp;str</code>)，也叫作<strong>字符串字面量</strong>，字符串字面量是很方便的，但是在有些时候，这个方便并没有体现到位，原因是：</p><ul><li>由于是直接被硬编码到程序当中去，所以他是不可变的</li><li>并非所有字面量都能在编写代码的时候得知他的值</li></ul><p>于是就有了动态字符串类型：<code>String</code></p><p>这个类型被分配到堆空间上，所以可以动态的伸缩，也就可以存储位置大小的文本。</p><p>在rust中，想要得到一个String类型的变量很简单：<code>let s = String::new(&quot;yxyl&quot;);</code></p><h3 id="浅拷贝和深拷贝"><a class="header-anchor" href="#浅拷贝和深拷贝">¶</a>浅拷贝和深拷贝</h3><h4 id="拷贝-浅拷贝"><a class="header-anchor" href="#拷贝-浅拷贝">¶</a>(拷贝)浅拷贝</h4><p>先讲讲浅拷贝吧，浅拷贝只是发生在栈上，因此，性能很高，就比如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>这段代码就是很实在的浅拷贝，因为整形这个数据类型大小是已知的，会被存储在栈上，所以浅拷贝也是快速的、这意味着没有理由在创建<code>y</code>过后，<code>x</code>失效</p><h4 id="克隆-深拷贝"><a class="header-anchor" href="#克隆-深拷贝">¶</a>(克隆)深拷贝</h4><p>没有人会做出有损自己利益的事情，rust也一样，rust不会主动进行数据的深拷贝，他是低效且耗性能的，就像如果想要复制String类型的变量时候，通常会用<code>clone()</code>这样一个方法，他不仅仅是复制栈上的数据，深度copy了堆上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>您的设计模式-单例模式</title>
      <link href="/2022/09/19/%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/19/%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1>单例模式【Singleton Pattern】</h1><blockquote><p>这个模式是很有意思，而且比较简单，但是我还是要说因为它使用的是如此的广泛，如此的有人缘， 单例就是单一、独苗的意思，那什么是独一份呢？你的思维是独一份，除此之外还有什么不能山寨的呢？ 我们举个比较难复制的对象：皇帝  中国的历史上很少出现两个皇帝并存的时期，是有，但不多，那我们就认为皇帝是个单例模式，在这 个场景中，有皇帝，有大臣，大臣是天天要上朝参见皇帝的，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，单例模式，绝对的单例模式， 先看类图：</p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220919101551388.png" alt="image-20220919101551388"></p><p><strong>然后我们看程序实现，先定一个皇帝：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 中国的历史上一般都是一个朝代一个皇帝，有两个皇帝的话，必然要PK出一个皇帝出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emperor</span> &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Emperor</span> <span class="variable">emperor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个皇帝放在那里，然后给这个皇帝名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Emperor</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="comment">//世俗和道德约束你，目的就是不让你产生第二个皇帝</span></span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(emperor == <span class="literal">null</span>)&#123; <span class="comment">//如果皇帝还没有定义，那就定一个</span></span><br><span class="line">         emperor = <span class="keyword">new</span> <span class="title class_">Emperor</span>(); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">return</span> emperor; </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//皇帝叫什么名字呀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">emperorInfo</span><span class="params">()</span>&#123; </span><br><span class="line">     System.out.println(<span class="string">&quot;我就是皇帝某某某....&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后定义大臣：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 大臣是天天要面见皇帝，今天见的皇帝和昨天的，前天不一样那就出问题了！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Minister</span> &#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     <span class="comment">//第一天</span></span><br><span class="line">     Emperor emperor1=Emperor.getInstance(); </span><br><span class="line">     emperor1.emperorInfo(); <span class="comment">//第一天见的皇帝叫什么名字呢？</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//第二天</span></span><br><span class="line">     Emperor emperor2=Emperor.getInstance(); </span><br><span class="line">     Emperor.emperorInfo(); </span><br><span class="line"></span><br><span class="line">     <span class="comment">//第三天</span></span><br><span class="line">     Emperor emperor3=Emperor.getInstance(); </span><br><span class="line">     emperor2.emperorInfo(); </span><br><span class="line"></span><br><span class="line">     <span class="comment">//三天见的皇帝都是同一个人，荣幸吧！</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>看到没，大臣天天见到的都是同一个皇帝，不会产生错乱情况，反正都是一个皇帝，是好是坏就这一 个，只要提到皇帝，大家都知道指的是谁，清晰，而又明确。问题是这是通常情况，还有个例的，如同一 个时期同一个朝代有两个皇帝，怎么办？</strong></p><p><strong>单例模式很简单，就是在构造函数中多了加一个构造函数，访问权限是 private 的就可以了，这个模式是简单，但是简单中透着风险，风险？什么风险？在一个 B/S 项目中，每个 HTTP Request 请求到 J2EE 的容器上后都创建了一个线程,每个线程都要创建同一个单例对象,怎么办?,好,我们写一个通用的单例程 序,然后分析一下:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 通用单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern singletonPattern= <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123; </span><br><span class="line"></span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">this</span>.singletonPattern == <span class="literal">null</span>)&#123; <span class="comment">//如果还没有实例，则创建一个</span></span><br><span class="line">     <span class="built_in">this</span>.singletonPattern = <span class="keyword">new</span> <span class="title class_">SingletonPattern</span>(); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.singletonPattern; </span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​假如现在有两个线程 A 和线程 B，线程 A 执行到 <code>this.singletonPattern =  new SingletonPattern()</code>，正在申请内存分配，可能需要 0.001 微秒，就在这 0.001 微秒之内，线程 B 执 行到 <code>if(this.singletonPattern == null)</code>，你说这个时候这个判断条件是 true 还是 false？是 true，那然后呢？线程 B 也往下走，于是乎就在内存中就有两个 <code>SingletonPattern</code> 的实例了，看看是不是出问题了？</p><p>​如果你这个单例是去拿一个序列号或者创建一个信号资源的时候，会怎么样？业务逻辑混乱！数据一致性校验失败！最重要的是你从代码上还看不出什么问题，这才是最要命的！因为这种情况基本上你是重现不 了的，不寒而栗吧，那怎么修改？有很多种方案，我就说一种，能简单的、彻底解决问题的方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 通用单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonPattern singletonPattern= <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">SingletonPattern</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123; </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="keyword">return</span> singletonPattern; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接 new 一个对象传递给类的成员变量 <code>singletonpattern</code>，你要的时候 <code>getInstance()</code>直接返回给你，解决问题！</p>]]></content>
      
      
      <categories>
          
          <category> 您的设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K8S笔记1</title>
      <link href="/2022/09/18/K8S%E7%AC%94%E8%AE%B01/"/>
      <url>/2022/09/18/K8S%E7%AC%94%E8%AE%B01/</url>
      
        <content type="html"><![CDATA[<h1>Kubernetes</h1><blockquote><p>K8S</p><p>一项基于生产环境级别下容器化编排自动化部署技术</p><p>这里的编排指的是：</p><ul><li>按照一定的目的一次排列</li><li>调配、安排</li></ul></blockquote><h2 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h2><p><strong>Master</strong></p><blockquote><p>K8S集群控制节点。管理已安装好的集群，对其调度管理，接收用户集群操作</p></blockquote><p><strong>Node</strong></p><blockquote><p>集群工作基点，在此环境上部署集群服务，运行集群容器</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> K8S </category>
          
      </categories>
      
      
        <tags>
            
            <tag> K8S </tag>
            
            <tag> 学习笔记 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务简单部署</title>
      <link href="/2022/09/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/09/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1>微服务简单部署</h1><h2 id="📋：Docker-Conpose"><a class="header-anchor" href="#📋：Docker-Conpose">¶</a>📋：Docker-Conpose</h2><ul><li>Docker-Compose是一个用来定义和运行复杂应用的docker工具。一个使用Docker容器的应用，一般是由多个容器组成。使用Docker-Compose就不用写多个shell脚本来启动管理容器了。</li></ul><ol><li>查看docker版本：<br><code>docker -version </code></li><li>安装docker-compose<br><code>sudo apt install docker-compose</code></li><li>查看docker-compose版本<br><code>docker-compose -version</code></li></ol><h2 id="➰：打包"><a class="header-anchor" href="#➰：打包">¶</a>➰：打包</h2><ul><li>在项目目录下创建image包，放每个微服务打包好的镜像，可选择每个微服务单独一个包，以便于以后微服务版本的维护，回滚。</li></ul><h2 id="🚉：Dockerfile"><a class="header-anchor" href="#🚉：Dockerfile">¶</a>🚉：Dockerfile</h2><ul><li><p>在每个微服务包下编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre</span><br><span class="line"><span class="keyword">ENV</span> APP_PATH=/apps</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$APP_PATH</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> xxx-1.0-SNAPSHOT.jar <span class="variable">$APP_PATH</span>/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> $&#123;PORT&#125;</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="上传Docker-Compose文件"><a class="header-anchor" href="#上传Docker-Compose文件">¶</a>上传Docker-Compose文件</h2><ul><li><p>在<code>Docker-Compose</code>文件中编写服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#定义docker网络</span></span><br><span class="line">  <span class="attr">yingxue_network:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#挂载数据卷</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">  <span class="attr">redisdata:</span></span><br><span class="line">  <span class="attr">mqdata:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment">#每个服务</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:2.0.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JVM_XMS=256m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JVM_XMX=256m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MODE=standalone&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yingxue_network</span></span><br><span class="line">        </span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yingxue_network</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./yingxue.sql:/docker-entrypoint-initdb.d/yingxue.sql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MYSQL_ROOT_PASSWORD=&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MYSQL_DATABASE=yingxue&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisdata:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="string">xxx服务:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">./images/xxx</span></span><br><span class="line">  <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;xxxx:xxxx&quot;</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">  <span class="string">-mysql</span></span><br><span class="line">  <span class="string">-redis</span></span><br><span class="line">  <span class="string">-rebbitmq</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">....</span></span><br></pre></td></tr></table></figure><p>这里是将每个软件服务和写的微服务写在同一个<code>docker-compose</code>文件中，可以的分成两个<code>docker-compose</code>，可将其划分成：</p><ol><li>docker-compose-app.yml：微服务</li><li>docker-compose-env.yml：环境服务</li></ol></li></ul><h2 id="🚀：点火"><a class="header-anchor" href="#🚀：点火">¶</a>🚀：点火</h2><ul><li>cd到docker-compose文件，</li><li><code>docker-compose up -d</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway自定义网关Filter</title>
      <link href="/2022/09/18/Gateway%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%85%B3Filter/"/>
      <url>/2022/09/18/Gateway%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%85%B3Filter/</url>
      
        <content type="html"><![CDATA[<h1>SpringCloud-Gateway自定义网关Filter</h1><p>自定义filter可以实现两种，一种是全局生效的，一种是局部生效的，需要配置。</p><p>🖕：这边自定义下局部的</p><ol><li><p>首先命名为：<code>xxxGatewayFilterFactory</code>比如<code>TokenGatewayFilterFactory</code>，<code>AddLogGatewayFilterFactory</code>等等，再注入IOC管理</p></li><li><p>然后，通过看其他自带的局部(全局)Filter类可以看出，他们都继承了<code>AbstractGatewayFilterFactory</code>这个抽象类，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;TokenGatewayFilterFactory.Config&gt;</span><br></pre></td></tr></table></figure><p>其中的泛型是Filter类中自定义的内部类<code>Config</code></p></li><li><p>重写<code>apply()</code>，<code>shortcutFieldOrder()</code>方法，</p><ul><li>其中apply是核心方法，它决定着我们需要的过滤业务，</li><li>shortcutFieldOrder()方法可根据自定义顺序接收我们从配置文件传过来的value</li></ul></li><li><p>创建Filter构造方法，可以传进来需要用到的工具类等等…</p></li></ol><p>🆗：Filter over后，需要我们在网关配置文件中每个需要Filter的路由中进行配置了，可传的参数由shortcutFieldOrder决定。</p>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2022/09/17/JUC/"/>
      <url>/2022/09/17/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="🌠-JUC是什么"><a class="header-anchor" href="#🌠-JUC是什么">¶</a>🌠:JUC是什么</h2><p>JUC是<code>java.util.concurrent</code>包的缩写，这个包里包含了各种各样的关于线程通讯，控制同步的工具类——&gt;即Java并发工具包。</p><p>另外，JUC的框架结构，并不是我们常见的继承实现框架结构。JUC底层在Java中是unsafe，unsafe是jvm的实现。有了unsafe的支持，才出现可以进行原子操作的Atomic原子类…最后才到我们的Utils。</p><h2 id="🚀-进程和线程"><a class="header-anchor" href="#🚀-进程和线程">¶</a>🚀:进程和线程</h2><blockquote><p>官方：进程是CPU分配资源的最小单元，线程是CPU调度资源的最小单位</p></blockquote><p>Java默认有2个线程：mian(主线程)、GC(守护线程)</p><h2 id="🚢-并发和并行"><a class="header-anchor" href="#🚢-并发和并行">¶</a>🚢:并发和并行</h2><ul><li>并发（多个线程操作一个资源）：CPU一核，模拟出来多个线程</li><li>并行（多个人一起行走）：CPU多核，执行多条线程</li></ul><blockquote><p>线程有6个状态：</p></blockquote><ol><li><strong>NEW-&gt;新生</strong></li><li><strong>RUNNABLE-&gt;运行</strong></li><li><strong>BLOCKED-&gt;阻塞</strong></li><li><strong>WAITING-&gt;等待</strong></li><li><strong>TIMED_WAITING-&gt;死等</strong></li><li><strong>TERMINATED-&gt;终结</strong></li></ol><blockquote><p>wait/sleep区别</p></blockquote><ul><li>wait：<br>要释放锁<br>不需要捕获异常<br>只能在静态代码块中(<code>static</code>)</li><li>sleep：<br>不释放锁<br>需要捕获异常<br>任意地方都可以<strong>睡</strong></li></ul><h2 id="🔒-Lock-锁"><a class="header-anchor" href="#🔒-Lock-锁">¶</a>🔒:Lock(锁)</h2><blockquote><p>传统synchronized 本质：队列+锁 ——&gt; 排队</p></blockquote><p><code>java.util.concurrent.locks.Lock</code></p><p>其子类：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220915205227492.png" alt="image-20220915205227492"></p><blockquote><p>synchronized和lock的区别</p></blockquote><ul><li>synchronized  是关键字；lock是类</li><li>synchronized  不能判断锁的状态；lock可以判断锁</li><li>synchronized  自动释放锁；lock必须手动释放锁，不释放的话–&gt;死锁</li><li>synchronized  Thread1堵塞–&gt;Thread2等待；lock不一定等</li><li>synchronized  适合少代码同步；lock适合大量代码同步</li><li><strong>…</strong></li></ul><h2 id="⭐-JUC版的PC问题"><a class="header-anchor" href="#⭐-JUC版的PC问题">¶</a>⭐:JUC版的PC问题</h2><blockquote><p>通过lock找到Condition<br>condition来对线程进行监视操作(等待，唤醒…)<br>condition操作线程，可以精准的对线程的唤醒</p></blockquote><p><strong>资源类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里看到判断线程操作资源等待的条件使用<code>while</code>判断而不用<code>if</code>，为了防止虚假唤醒的问题。</strong></p><h2 id="💦-集合类不安全"><a class="header-anchor" href="#💦-集合类不安全">¶</a>💦:集合类不安全</h2><p>我们知道在多线程下进行任何操作都是令人胆战心惊的。</p><p>多线程下，对集合CRUD，难免会遇到<code>ConcurrentModificationException</code>线程操作异常，是因为我们平常使用的ArrayList底层的数据操作方法都是单线程的，没有对线程进行处理。</p><p>针对这点，有3个常见的解决方案(仅基于Java层面)：</p><ol><li>使用Vector集合类，Vector集合类底层对集合操作进行了synchronized锁处理，但相对来说效率较低<br><code>List list = new Vector&lt;&gt;();</code></li><li>使用集合工具类中的**“锁集合”**，<code>Collections.synchronizedList(....);</code></li><li>使用<strong>读写锁集合(JUC)</strong>，<code>CopyOnWriteArrayList</code>底层对数据的集合操使用了JUC中的Lock锁类，效率较Vector自然<strong>upup</strong><br><code>List list = new CopyOnWriteArrayList();</code></li></ol><h2 id="🍶-线程池"><a class="header-anchor" href="#🍶-线程池">¶</a>🍶:线程池</h2><p>写到这里突然想起来那天学长面试的问题——说下线程的创建方法吧</p><p>头一次感受到当时开学用一个月学Java这门编程语言的时候到如今这样一个不太正式的面试，面临如此基础简单的问题 时是多么的无力…</p><p>创建线程一共有4个方法，但万变不离其宗，完全可以总结为一个方法——其最终都是执行的<code>Thread.start()</code>当中的<code>run()</code>方法</p><ol><li><p>实现<code>Runable</code>接口，重写<code>Run()</code>方法</p></li><li><p>实现<code>Callable</code>接口，重写<code>Call()</code>方法</p><ul><li><blockquote><p>与（1）不同的是，<code>Call()</code>方法是有返回值的，其类型由我们创建匿名内部类的时候指定泛型。而<code>Callable接口</code>本身并不是<code>Runable</code>的子类，创建线程可以通过该方法是因为：Thread在创建的时候是需要将<code>Runable</code>或其子类传入，其中包含了子类<code>FutureTask</code>这样一个类，在创建这个类时可将Callable接口的实现当做构造参数传进去，以达到创建线程的目的…</p></blockquote></li></ul></li><li><p>💩直接New Thread</p></li><li><p>通过线程池创建…</p></li></ol><hr><p><strong>池化技术</strong></p><blockquote><p>程序运行的本质是：占用OS的资源，而优化资源的使用——&gt;池化技术</p><p>事先准备好一些资源，需要用的话从我这儿拿，用完还我</p></blockquote><p>其优点：</p><ul><li>降低资源的消耗：本质即优化资源的使用效率</li><li>方便线程管理：创建线程池初始化事先线程</li><li>提高响应速度：不用频繁的创建和销毁线程</li></ul><h3 id="线程池的3个Func"><a class="header-anchor" href="#线程池的3个Func">¶</a>线程池的3个Func</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); -- 单例线程</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); -- 固定线程</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); --弹性</span><br></pre></td></tr></table></figure><h3 id="线程池的7个参数"><a class="header-anchor" href="#线程池的7个参数">¶</a>线程池的7个参数</h3><p>通过三个Func可以看出来，<code>Executors.newCachedThreadPool(); --弹性</code>这样一个方法是值得我们青睐的，</p><p>其构造方法：</p><img src="C:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20220918095441793.png" alt="image-20220918095441793" style="zoom: 65%;" /><blockquote><p>但是读源码我们可以看到</p></blockquote><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220918094909666.png" alt="image-20220918094909666" style="zoom: 80%;" /><blockquote><p>这里<strong>允许的创建线程数量</strong>是：<code>Integer.MAX_VALUE</code> = 2^31 - 1 ——&gt;<strong>可能会堆积大量的请求，从而导致 OOM！</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220918095025854.png" alt="image-20220918095025854"></p><blockquote><p>这也是阿里巴巴开发手册里面提到的，线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 这样一个原生的方式来创建线程。</p></blockquote><hr><p>归言：其7个参数分别：</p><ol><li>int <code>corePoolSize</code>：<strong>核心线程数</strong></li><li>int <code>maximumPoolSize</code>：<strong>最大创建线程数</strong></li><li>long <code>keepAliveTime</code>：<strong>存活时间</strong></li><li>TimeUnit <code>unit</code>：<strong>Time类管理工具</strong></li><li>BlockingQueue<Runnable> <code>workQueue</code>：指定阻塞队列</li><li>ThreadFactory <code>threadFactory</code>：<strong>线程工厂</strong></li><li>RejectedExecutionHandler <code>handler</code>：<strong>拒绝策略</strong></li></ol><h3 id="线程池的4中拒绝策略"><a class="header-anchor" href="#线程池的4中拒绝策略">¶</a>线程池的4中拒绝策略</h3><ul><li><code>new ThreadPoolExecutor.AbortPolicy()</code> // 银行满了，还有人进来，不处理这个人的，抛出异常</li><li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code> //哪来的去哪里!</li><li><code>new ThreadPoolExecutor.DiscardPolicy()</code> //队列满了，丢掉任务，不会抛出异常!</li><li><code>new ThreadPoolExecutor.DiscardoldestPolicyO()</code> //队列满了，尝试去和最早的竞争，也不会抛出异常!</li></ul><h2 id="📼-JMM"><a class="header-anchor" href="#📼-JMM">¶</a>📼:JMM</h2><blockquote><p>JMM(Java Memory Model)：Java内存模型</p></blockquote><p>它实现了Java程序在各种平台上都能达到一定的并发效果</p><p>每个Java程序都有<strong>主内存</strong>，以及<strong>每条线程的工作内存</strong></p><p>每天线程获取资源都会有相应的交互操作规范：</p><h3 id="8种内存交互模型"><a class="header-anchor" href="#8种内存交互模型">¶</a>8种内存交互模型</h3><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>JMM对8种内存交互操作制定的规则：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="Volatile"><a class="header-anchor" href="#Volatile">¶</a>Volatile</h2><blockquote><p><code>Volatile</code>是Jvm虚拟机提供的轻量级的同步机制</p></blockquote><p>特点：</p><ol><li>不保证原子性<ul><li>这里的原子性：<strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</strong></li></ul></li><li>禁止指令重排<ul><li>利用CPU的内存屏障，避免指令重排现象出现</li></ul></li><li>指令可见性<ul><li>当线程还正在消费主线程资源时，资源发生更改，<code>volatile</code>保证<strong>这个更改</strong>及时<strong>通知</strong>到线程</li></ul></li></ol><h2 id="CAS"><a class="header-anchor" href="#CAS">¶</a>CAS</h2><blockquote><p>CAS的全称为<code>compare and swap</code> 或者<code>compare and exchange</code>,意思为比较和交换</p><ul><li>比较：比较当前线程工作内存中的值&lt;——&gt;和主内存中的值</li><li>交换：若为期望——&gt;则执行操作；若不是期望，由于底层是自旋锁，会无线循环</li></ul><p><strong>本质</strong>上即是，对乐观锁思想的实际实现…</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1000</span>);<span class="comment">//原子类</span></span><br><span class="line"><span class="comment">//CAS操作</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">1000</span>, <span class="number">2000</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(integer.getAndIncrement());<span class="comment">//2000</span></span><br><span class="line">System.out.println(integer);<span class="comment">//2001</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">1000</span>, <span class="number">2000</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="CAS实现原子操作的问题"><a class="header-anchor" href="#CAS实现原子操作的问题">¶</a>CAS实现原子操作的问题</h3><p>ABA问题：</p><blockquote><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了</p></blockquote><p>解决ABA问题：使用带版本号机制的——&gt;原子应用类</p><p><strong>这里仅搬出简单的一类解决方案，类似于乐观锁的思想——&gt;基于版本号控制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; atomicReference</span><br><span class="line">                = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;Integer&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span></span><br><span class="line">            , atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line"></span><br><span class="line">    atomicReference.compareAndSet(<span class="number">102</span>, <span class="number">100</span></span><br><span class="line">            , atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">105</span></span><br><span class="line">            , stamp, stamp + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line">&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
