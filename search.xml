<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Jvm类加载机制</title>
      <link href="/2022/12/30/Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2022/12/30/Jvm%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="类加载运行全过程"><a class="header-anchor" href="#类加载运行全过程">¶</a>类加载运行全过程</h2><p>当我们用java命令运行某个类的main函数启动程序的时候，首先需要通过<strong>类加载器</strong>吧主类加载到JVM</p><p>通过Java指令执行代码的大体流程如下：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230100805505.png" alt="image-20221230100805505"></p><ul><li>其中在C++层面的：<ul><li>通过java.exe调用底层的<code>jvm.dll</code>文件创建Java虚拟机</li><li>创建一个<strong>引导类加载器实例</strong>(C++)</li></ul></li><li>Java层面：<ul><li>由加载完所有需要使用到的类</li><li>执行<code>main</code>方法</li><li>java程序执行结束，JVM销毁</li></ul></li></ul><p>其中<code>loadClass</code>的类加载过程有如下几步：</p><blockquote><p>**加载&gt;&gt;验证&gt;&gt;准备&gt;&gt;解析&gt;&gt;初始化&gt;&gt;**使用&gt;&gt;卸载</p></blockquote><ul><li>加载：在磁盘上查找并通过IO读入字节码文件</li><li>验证：校验字节码文件的正确性</li><li>准备：给类的静态变量分配内存，<strong>并赋予默认值</strong></li><li>解析：将符号引用替换为直接引用，这个阶段会把一些静态方法替换为执行数据所存内存的指针或句柄等，这是所谓的静态链接过程(类加载器期间完成)，<strong>动态链接</strong>是指在程序运行期间完成的将符号引用替换为直接引用</li><li>初始化：对垒的静态变量初始化为指定的值(即在代码中的赋值操作)，执行静态代码块(<code>static</code>)</li></ul><h2 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制">¶</a>双亲委派机制</h2><p>Jvm类加载器是有亲子层级关系结构的：<br><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230143652368.png" alt="image-20221230143652368"></p><p>这里类加载其实就有一个<strong>双亲委派机制</strong>，加载某个类时会先委托附加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径都找不到目标类，则在自己的类加载路径中查找并载入目标类</p><p>双亲委派机制简单来说就是：</p><blockquote><p>先找父类加载，找不到再由子类自己加载</p></blockquote><p><strong>AppClassLoader</strong>的<code>loadClass</code>方法最终会调用其父类<strong>ClassLoader</strong>的<code>loadClass</code>方法，该方法的大体逻辑：</p><ol><li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回</li><li>如果这个类没有被加载过，那么再判断一下是否有父加载器；如果有父加载器，则由附加器加载(即调用<code>parent.loadClass(name,false);</code>)。或者是调用<code>Bootstrap类加载器</code>来加载</li><li>如果父加载器及Bootstrap加载器都没有找到指定类，那么则调用当前类加载器了的<code>findClass</code>方法来完成类加载</li></ol><blockquote><p>整体来说就像是个闭环</p><p>第一个去趟是必经的，</p><p>后面如果发现指定类已经被加载过了，就直接返回；</p><p>如果没有，最多不过回来的那一趟最后返回；</p><p>之后的在后面去的那一趟必返回指定类，因为肯定被加载过了</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line"><span class="comment">// 检查当前类加载器是否已经加载了该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123; <span class="comment">//如果当前加载器父加载器不为空则委托父加载器加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non‐null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 ‐ t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123; <span class="comment">//不会执行</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h3><p>那么为什么要设计双亲委派机制呢：</p><ul><li>沙箱安全机制：比如，自己写的<strong>java.lang.String.class</strong>类不会被加载，这样就可以防止核心API库被随意纂改，防止黑客写后门</li><li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子<strong>ClassLoader</strong>在加载一次，保证被加载类的唯一性</li></ul><p>以下代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"> 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> 否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure><h3 id="全盘负责委托机制"><a class="header-anchor" href="#全盘负责委托机制">¶</a>全盘负责委托机制</h3><p><strong>“全盘负责”<strong>是指当一个</strong>ClassLoader</strong>装载一个类的时候，除非显式的使用另一个<strong>ClassLoader</strong>，该类所依赖及其引用的类也由这个<strong>ClassLoader</strong>加载/载入</p><h3 id="自定义类加载器"><a class="header-anchor" href="#自定义类加载器">¶</a>自定义类加载器</h3><p>自定义类加载器只需要继承<code>java.lang.ClassLoader</code>类，这个类有两个核心方法</p><ul><li><code>loadClass(String, boolean)</code>：实现了双亲委派机制</li><li><code>findClass</code>：默认是现实空方法，所以我们自定义类加载器主要是重写<code>findClass</code>方法</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: GroovyProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-30 13:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classPath + <span class="string">&quot;/&quot;</span> + name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.available();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        fis.read(data);</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = loadByte(name);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;C:\\Users\\雷神战机\\Desktop&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;AtomicIntegerFieldUpdaterTest&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz.getClassLoader().getClass().getName() = &quot;</span> + clazz.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过debug我们会发现，在加载的时候，最终会调到我们自定义的findClass方法，通过调用loadClass方法，得到指定类信息。</p><blockquote><p>根据双亲委派机制我们知道，首先会让<strong>BootstrapClassLoader</strong>去加载，再<strong>ExtClassLoader</strong>，再<strong>APPClassLoder</strong>，最后再是自己定义的类加载器，</p><p>所以，我们测试的时候，需要将指定类的class字节码文件放到扫描路径下，并把指定类从项目中删除</p><p>这样，才不会被开始的<strong>APPClassLoader</strong>索扫描到</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
          <category> JVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
            <tag> 类加载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat架构设计</title>
      <link href="/2022/12/27/Tomcat%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
      <url>/2022/12/27/Tomcat%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="Tomcat整体架构"><a class="header-anchor" href="#Tomcat整体架构">¶</a>Tomcat整体架构</h2><blockquote><p>Tomcat核心：Http服务器+Servlet容器</p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227205006567.png" alt="image-20221227205006567"></p><p>这里通过<code>server.xml</code>配置文件来加深对Tomcat架构的理解</p><p>Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的要求配置在这个顶级容器中，<code>server.xml</code>：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Context</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Host</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Tomcat启动期间回通过解析xml文件，利用反射来创建相应的组件，所以xml中的标签与源码一一对应</p><p>以下是架构图：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/tomcat-x-design-2-1.jpeg" alt="tomcat架构图"></p><p>根据上述的**“Tomcat核心”**以及Tomcat架构图，我们可以得到：</p><p>Tomcat要实现2个核心功能：</p><ul><li>处理Socket连接，负责网络字节流与Request和Response对象的在转化</li><li>加载和管理Servlet，以及具体处理ServletRequest请求</li></ul><p>因此，Tomcat设计了2个核心组件：连接器(Connector)和容器(Container)来分别做上两个核心功能</p><ul><li>连接器负责对外交流</li><li>容器负责内部处理请求响应</li></ul><h2 id="核心组件"><a class="header-anchor" href="#核心组件">¶</a>核心组件</h2><h3 id="Server"><a class="header-anchor" href="#Server">¶</a>Server</h3><p>指的就是整个Tomcat服务器，包含多组服务(Service)，负责管理和启动各个Service，同时监听8005端口发过来的 <code>shutdown</code> 命令</p><h3 id="Service"><a class="header-anchor" href="#Service">¶</a>Service</h3><p>每个Service组件都包含了若干用于接收客户端消息的<strong>Connecotr组件</strong>和处理请求的<strong>容器</strong>ervice组件还包含了若干个<code>Executor</code>组件，每个Executor组件都是一个线程池，它可以为Service内所有组件提供线程池执行任务</p><p>模型图：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227211249505.png" alt="image-20221227211249505"></p><p>Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就是好比一个房间有多个们，但是单独的连接器或者容器都不能对外提供服务，需要把他们组装起来才能工作，<strong>组装后的这个整体叫做Service组件</strong></p><p>Service本身没有做什么重要的事情，只是在连接器和容器外面夺宝了一层，把它们组装在一起。Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑</p><p>通过Tomcat中配置多个Service，可以实现通过不通过的端口号来访问同一太机器上部署的不同应用</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227211741666.png" alt="image-20221227211741666"></p><p>从上图可以看出，最顶层的是Server，这里的Server指的就是一个Tomcat实例。一个Server中有一个或者多个Service，一个Service里面有多个连接器和一个容器连接器与容器之间通过标准的ServletRequest和ServletResponse通信</p><h3 id="Connector"><a class="header-anchor" href="#Connector">¶</a>Connector</h3><p>Tomcat与外部世界的连接器，监听固定端口、接收外部请求，传递给Container，并将Container处理的结构返回给外部。</p><p>连接器对Servlet容器屏蔽了不同的应用层协议以及I/O模型，无论是HTTP还是AJP，在容器中获取到的都是一个标准的<code>ServletRequest</code>对象</p><p>根据以上，连接器需要实现的功能有：</p><ul><li>监听网络端口</li><li>接收网络连接请求</li><li>读取请求网络字节流数据</li><li>根据具体的应用层协议(HTTP/AJP)解析字节流，生成统一的Tomcat Request对象</li><li>将Tomcat Request 对象转成标准的<code>ServletRequest</code></li><li>调用Servlet容器，得到ServletResponse</li><li>将ServletResponse转成Tomcat Response 对象</li><li>将Tomcat Response 对象转成网络字节流</li><li>将响应字节流写回给浏览器</li></ul><p>说是功能，倒不如说是，整个过程中Connector所做的事情，理解起来就像是个闭环一样</p><p>分析连接器详细功能列表，我们会发现连接器需要完成3个高内聚的功能：</p><ul><li>网络通信</li><li>应用层协议解析</li><li>Tomcat Request/Response 与ServletRequest/ServletResponse 的转化</li></ul><p>因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是：EndPoint、Processor、Adapter</p><ul><li>EndPoint负责提供字节流给Processor</li><li>Processor分组提供Tomcat Request 对象给Adapter</li><li>Adapter负责提供ServletRequest对象给Containert容器</li></ul><h4 id="ProtocolHandler"><a class="header-anchor" href="#ProtocolHandler">¶</a>ProtocolHandler</h4><p>连接器用<strong>ProtocolHandler</strong>来处理网络连接和应用层协议，包含了2个重要部件：EndPoint、Processor</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221228093700916.png" alt="image-20221228093700916"></p><ul><li>EndPoint：EndPoint是通信端点，即，通信监听的接口，是具体的Socket接收和发送处理器，<strong>是对传输层的抽象</strong>，因此EndPoint是用来实现TCP/IP协议的</li><li>Processor：Processor用来实现HTTP/AJP协议，Processor接收来自EndPoint的Socket，读取字节流解析成Tomcat Request 和Response 对象，并通过Adapter 将其提交到容器处理。<strong>Processor是对应用层协议的抽象</strong></li></ul><h4 id="Adapter"><a class="header-anchor" href="#Adapter">¶</a>Adapter</h4><p>由于协议不同客户端发了过来的请求信息也不尽相同，Tomcat定义了自己的Request类来**“存放”**这些请求消息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器</p><blockquote><p>Tomcat设计者的解决方案是映入<code>CoyoteAdapter</code>，这是适配器模式的经典运用~</p></blockquote><h3 id="Container"><a class="header-anchor" href="#Container">¶</a>Container</h3><p>容器，顾名思义就是用来装载东西的器具，在Tomcat里，容器就是用来装载Servlet的。Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。Toma设计了4中容器，分别是：Engine，Host，Context，Wrapper。这4种容器不是平行关系，而是父子关系。(没错，就是你与我之间的关系。)</p><ul><li>Engine：引擎，Servlet的顶层容器，用来管理多个虚拟站点，一个Service最多只能有一个Engine</li><li>Host：虚拟主机，负责web应用的部署和Context的创建。可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序</li><li>Context：Web 应用上下文，包含多个Wrapper，负责Web配置的解析、管理所有的Web 资源。一个Context对应一个Web应用程序</li><li>Wrapper：宝石一个Servlet最底层的容器，是对Servlet封装，负责Servlet实例的创建、执行和销毁</li></ul><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221228095237603.png" alt="image-20221228095237603"></p><p>那么这些容器，Tomcat是如何来管理的呢：</p><p><strong>Tomcat采用组合模式来管理这些容器</strong>。具体实现方式是，所有容器组件都实现了<code>Container</code>接口，一次组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</p><p><code>Container</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Container</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line"><span class="keyword">public</span> Container <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(Container container)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Container child)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(Container child)</span>;</span><br><span class="line"><span class="keyword">public</span> Container <span class="title function_">findChild</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工作原理"><a class="header-anchor" href="#工作原理">¶</a>工作原理</h2><h3 id="请求定位Servlet的过程"><a class="header-anchor" href="#请求定位Servlet的过程">¶</a>请求定位Servlet的过程</h3><p>Tomcat是用<code>Mapper</code>这个组件来完成这个任务的。Mapper组件的功能就是将用户请求的URL定位到个Servlet。</p><p>他的工作原理是：Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系，比如Host如里面配置的域名‘Context容器里的Web应用路径，以及Wrapper容器里面的Servlet映射的路径</p><p>你可以想象这些配置信息就是一个多层次的Map。当一个请求到来时，Mapper组件通过解析请求去URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet。一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet</p><h3 id="请求在容器中的调用过程"><a class="header-anchor" href="#请求在容器中的调用过程">¶</a>请求在容器中的调用过程</h3><p>连接器中的Adapter会调用容器的Service方法来执行Servlet，最先拿到的请求是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己子容器Host来自己处理，以此类推，最后这个请求会传给Wrapper容器，Wrapper会调用最终的Servlet来处理，那么这个调用过程具体是怎么实现的呢：</p><blockquote><p><strong>Pipeline-Valve</strong> 管道</p></blockquote><p>Pipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理</p><p>Valve表示一个处理点，比如权限认证和记录日志</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line"><span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOExceptio,ServletException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasic</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Pipeline中维护了 Valve链表，Valve可以插入到Pipeline中，对请求做某些处理。整个调用链的出发是Valve来完成的，Valve完成自己的处理后，调用<code>getNext().incoke()</code>来触发下一个Valve调用。<strong>每个容器都有一个Pipeline对象</strong>，只要出发这个Pipeline的第一个Valve，这个容器里Pipeline中的Valve就都会被调用到。</p><p><strong>Basic Valve</strong>处于Valve链表的末端，他是Pipeline中比不可少的一个Valve，负责调用下层容器的Pipeline里的第一Valve</p><h2 id="Tomcat基础调优"><a class="header-anchor" href="#Tomcat基础调优">¶</a>Tomcat基础调优</h2><ul><li>清理不必要的Web应用</li><li>清理不必要的xml文件</li><li>静止Tomcat TLD扫描</li><li>关闭WebSocket支持</li><li>关闭JSP支持</li><li>静止Servlet注解扫描</li><li>并行启动多个Web应用</li><li>……</li></ul>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
            <tag> 架构 </tag>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅浅理解Java线程</title>
      <link href="/2022/12/25/%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/"/>
      <url>/2022/12/25/%E6%B5%85%E6%B5%85%E7%90%86%E8%A7%A3Java%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="线程进程"><a class="header-anchor" href="#线程进程">¶</a>线程进程</h2><h3 id="进程间通讯方式"><a class="header-anchor" href="#进程间通讯方式">¶</a>进程间通讯方式</h3><ol><li><strong>管道(pipe)及有名管道(name pipe)</strong>：管道可应用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的所有功能之外，他还允许无亲缘关系进程之间的通信</li><li><strong>信号(signal)</strong>：信号是在软件层次上对中断机制的一种模拟，他是比较复杂的通信方式用于通知进程有某事件发生，一个进程收到一个信号，与处理器收到一个中断请求效果可以说是一致的</li><li><strong>消息队列(MQ)</strong>：MQ是消息的链接表，他克服了上面两种通信方式中信号量优先的缺点，具有写权限的进程可以按照一定的规则向MQ中添加新信息；对MQ有读权限进程看从MQ中读取信息</li><li><strong>共享内存(shared memory)</strong></li><li><strong>信号量(semaphore)</strong></li><li><strong>套接字(socket)</strong></li></ol><h3 id="线程的同步-互斥"><a class="header-anchor" href="#线程的同步-互斥">¶</a>线程的同步/互斥</h3><p>线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息的时应等待，知道消息到达的时候才被唤醒</p><p><strong>线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排他性</strong>。当由若干个线程都要使用某一个资源的时候，任何时刻最多只允许一个线程去使用，其他使用该资源的线程必须等待，知道占用者释放该资源。线程互斥可以看成是一种特殊的线程同步</p><p>那么我们改如何来控制线程的同步互斥呢：</p><h4 id="四种线程同步互斥的控制方法"><a class="header-anchor" href="#四种线程同步互斥的控制方法">¶</a>四种线程同步互斥的控制方法</h4><ul><li>临界区：通过对多线程的串行化来访问公共资源或者一段代码，速度快，适合控制数据访问</li><li>互斥量：为协调公共对一个共享资源的单独访问而设计的</li><li>信号量：为控制一个具有有限数量用户资源而设计的</li><li>事件：用来通知线程有一些事件已发生，从而启动后续任务的开始</li></ul><h3 id="上线文切换"><a class="header-anchor" href="#上线文切换">¶</a>上线文切换</h3><p>上下文切换是值CPU从一个线程或进程到另一个线程或基进程的切换</p><blockquote><p>上下文是CPU寄存器和程序计数器在任何时间点的内容</p><p>​寄存器是CPU内部的一部分非常快的内存(相对于CPU外部较慢的 RAM主内存)，它通过提供对常用值的快速访问来加快计算机程序的执行</p><p>​程序计数器时一种专门的寄存器，他指示CPU在起指令序列中的位置，并保存着正在执行的指令的地址或下一条要执行的指令的地址，这取决于具体的系统</p></blockquote><p>上下文切换可以更详细的描述为内核对CPU上的进程(包括线程)执行以下活动：</p><ol><li>暂停一个进程的处理，并将进程的CPU状态存储在内存中的某个地方</li><li>从内存中获取下一个进程的上下文，并在CPU的寄存器中恢复它</li><li>返回到程序计数器指示的位置以恢复进程</li></ol><h3 id="操作系统层面的线程生命周期"><a class="header-anchor" href="#操作系统层面的线程生命周期">¶</a>操作系统层面的线程生命周期</h3><p>操作系统层面的线程有五个状态：</p><ul><li>初始状态</li><li>可运行状态</li><li>运行状态</li><li>休眠状态</li><li>终止状态</li></ul><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221226093218906.png" alt="image-20221226093218906" style="zoom:67%;" /><p>这五种状态在不同编程语言会有简化合并。</p><p>例如：C的POSIX Threads规范，就把在初始状态和可运行状态合并了；Java就把可运行状态和运行状态合并了，这两个状态在操作系统调度层面有用，而JVM层面不关心这两个状态，因为JVM吧线程调度交给了操作系统处理了</p><h2 id="用户模式、内核模式"><a class="header-anchor" href="#用户模式、内核模式">¶</a>用户模式、内核模式</h2><p>绝大多数的操作系统都可以显示CPU的使用情况，在win上面，我们可以使用任务管理器查看，</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/6a0120a85dcdae970b0120a86db3c5970b-pi.png" alt="img"></p><p>CPU的使用率大体可以表示CPU花在处理非空闲任务的时间的比率，这只是一种简化的说法。实际上，在所有的现代的操作系统中，CPU是在两种不同的模式下运行的：</p><ol><li><p><strong>Kernel Mode</strong></p><p>在内核模式下，代码具有对硬件的所有控制权限。可以执行所有CPU指令，可以访问任意地址的内存。内核模式是为操作系统最底层，最可信的函数服务。在内核模式下的任何异常都是灾难性的将会导致整台机器宕机</p></li><li><p><strong>User Mode</strong></p><p>在用户模式下，代码没有对硬件的直接控制权限，也不能直接访问。程序是通过调用系统接口<code>(System APIs)</code>来达到访问硬件和内存。在这种保护模式下，即使程序发生panic也是可以回复的，在你的电脑上大部分程序都是在用户模式下运行的</p></li></ol><p>如上图所示，可以让任务管理器显示内核CPU占用时间。<br>绿色的表示总的CPU时间，红色的线表示内核使用的CPU使用，两者之间的间隔就是用户程序使用的CPU时间。</p><p>上面所说的两种模式不仅仅是字面上的区别，他们是受CPU严格制约的。如果在用户模式下，程序尝试做其权限之外的事情，比如说，执行一条高权限的CPU指令，修改其被禁止访问的内存，这个时候，一个可捕获的异常就会抛出。但是只会导致这个倒霉的应用程序panic，而不会当你的整个系统panic，这也是用户模式的存在意义</p><p>应用程序一般会在一下几种情况下切换到内核模式：</p><ul><li>系统调用</li><li>异常事件：当发生某些预见不可知的异常时，就会切换到内核态，以执行相关的异常事件</li><li>设备中断：在使用外围设备时，图外围设备完成了用户请求，就会向CPU发送一个中断信号，此时，CPU就会暂停执行原本的下一条指令，转去处理中断事件。此时，如果原来在用户态，则自然就会切换到内核态</li></ul><blockquote><p>CAS操作不会涉及到用户态切换到内核态</p></blockquote><h2 id="Java线程"><a class="header-anchor" href="#Java线程">¶</a>Java线程</h2><p>线程创建和启动的流程：</p><ol><li>使用<code>new Thread()</code>去创建一个线程，然后调用<code>start()</code>方法进行java层面的线程启动</li><li>调用本地方法<code>start()</code>，去调用<strong>jvm</strong>中的<code>JVM_StartThread</code>方法进行线程创建和启动</li><li>调用<code>new JavaThread(&amp;thread_entry,sz)</code>进行线程的创建，并根据不同的操作系统平台调用相应的<code>os::create_thread</code>方法创建线程</li><li>新创建的线程状态为<code>initialized</code>，调用了<code>sync-&gt;wait()</code>方法进行等待，等到被唤醒才继续执行<code>thread-&gt;run()</code></li><li>调用<code>Thread::start(native_thread)</code>方法进行线程的启动，此时将线程状态设置为RUNNABLE，接着调用<code>os::start_thread(thread)</code>根据不同的操作系统启动线程</li><li>线程启动之后状态设置为RUNNABLE，并唤醒第4步中等待的线程，接着执行<code>thread-&gt;run()</code>里面的body</li><li><code>JavaThread::run()</code>方法会回调第1步<code>new Thread()</code>中复写的<code>run()</code>方法</li></ol><p>Java线程属于内核级线程</p><ul><li>内核级线程(Kernel Level Thread，KLK)：他们是依赖于内核的，即，无论是用户线程中的线程，还是系统线程中的线程，他们的创建、销毁、切换都是由内核实现的</li><li>用户级线程(User Level Thread，ULK)：操作系统内核不知道应用线程的存在</li></ul><h2 id="终止线程"><a class="header-anchor" href="#终止线程">¶</a>终止线程</h2><p>Java没有提供一种安全、直接的方法来停止某个线程，而是提供了中断机制。</p><blockquote><p>中断机制是一种协同机制，也就是说通过中断并不能直接终止另一个线程，而需要被中断的线程自己来处理</p></blockquote><p>被中断的线程用有完全的自主权，他既可以选择立即停止，也可以选择一段时间后停止，也可以选择鸭压根不停止</p><p>API的使用</p><ul><li>interrupt()：将线程的<strong>中断标志</strong>设置为true，不会停止线程</li><li>isInterrupted()：判断当前线程的中断标志位是否为true，不会清除中断标志位</li><li>Thread.interrupted()：判断当前线程的中断标志位是否为true，并清除中断标志位(设置为false)</li></ul>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAS和原子类操作</title>
      <link href="/2022/12/19/CAS%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%93%8D%E4%BD%9C/"/>
      <url>/2022/12/19/CAS%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是CAS"><a class="header-anchor" href="#什么是CAS">¶</a>什么是CAS</h2><p>CAS(Compare And Swap，比较并交换)，通常指的是这样一种原子操作：</p><blockquote><p>针对一个变量，首先先比较他的内存值与某个期望值是否相同，如果相同，就给他赋一个新值</p></blockquote><p>CAS的逻辑用伪代码描述如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == expectedValue)&#123;</span><br><span class="line">value = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>CAS可以看做是他们合并后的整体——一个不可分割的原子操作，并且起原子性是直接在硬件层面得到保障的</li><li>CAS课看做是乐观锁(对比数据库的悲观、乐观锁)的一种实现方式，Java原子类中的递增操作就通过CAS自旋实现</li><li>CAS是一种无锁算法，在不使用锁(没有线程被阻塞)的情况下实现多线程之间的变量同步</li></ul><h2 id="CAS应用"><a class="header-anchor" href="#CAS应用">¶</a>CAS应用</h2><p>在Java中，CAS操作是有<code>Unsafe</code>类提供支持的，该类定义了三种针对不同类型变量的CAS操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1,<span class="type">long</span> var2,Object var4,Object var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1,<span class="type">long</span> var2,<span class="type">int</span> var4,<span class="type">int</span> var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1,<span class="type">long</span> var2,<span class="type">long</span> var4,<span class="type">long</span> var5)</span>;</span><br></pre></td></tr></table></figure><p>他们都是<a href="https://cloud.tencent.com/developer/article/1744704">native方法</a>，由Java虚拟机提供具体实现，这意味着不同的Java虚拟机对他们的实现可能会略有不同。</p><p>以<code>compareAndSwapInt</code>为例，<code>Unsafe</code>的<code>compareAndSwapInt</code>方法接收4个参数，分别是：</p><ol><li>对象实例</li><li>内存偏移量(有header的8个字节+x86机器的压缩指针粘的4个字节+对象存储数据本身的字节数，再添上对齐所需要的字节数使之成为8的整数倍)</li><li>字段期望值</li><li>字段新值</li></ol><p>这个方法会针对指定对象实例中的对应偏移量的字段执行CAS操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Entity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeFactory.getUnsafe();</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> UnsafeFactory.getFieldOffset(unsafe, Entity.class, <span class="string">&quot;x&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> successful;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4个参数分别是：对象实例、字段的内存偏移量、字段期望值、字段新值</span></span><br><span class="line">    successful = unsafe.compareAndSwapInt(entity, offset, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.x);</span><br><span class="line"></span><br><span class="line">    successful = unsafe.compareAndSwapInt(entity, offset, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.x);</span><br><span class="line"></span><br><span class="line">    successful = unsafe.compareAndSwapInt(entity, offset, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.x);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Unsafe 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">         field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">         <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字段的内存偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unsafe</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getFieldOffset</span><span class="params">(Unsafe unsafe, Class clazz, String fieldNam&#123;</span></span><br><span class="line"><span class="params">         <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="params">         return unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName)</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="CAS缺陷"><a class="header-anchor" href="#CAS缺陷">¶</a>CAS缺陷</h2><p>CAS虽然高校解决了原子操作但是还是存在一些缺陷，主要变现在三个方面：</p><ul><li>自旋CAS长时间地不成功，让CPU在那里空转，导致给CPU带来非常大的开销</li><li>只能保证一个共享变量的原子操作，也就是说，如果是分布式的话，还是老老实实用分布式锁吧</li><li>ABA问题</li></ul><h3 id="ABA问题"><a class="header-anchor" href="#ABA问题">¶</a>ABA问题</h3><p>当有多个线程对他一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，这个时候其他线程不感知，还是会修改成功</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219093920543.png" alt="image-20221219093920543"></p><p>其中，对某一个共享变量的操作序列为：读取-修改-写回(即A-B-A)，如果在修改操作B期间，另一个线程也对这个变量进行了修改没那么原本的修改操作就会被覆盖掉</p><p>ABA问题通常出现在使用CAS操作的场景中。在这些场景下，ABA问题可能会带来隐患(包括但不限于这些场景)</p><ol><li>使用CAS实现的锁：如果在一个线程获得锁之后，另一个线程在次期间对共享变量进行了修改，并且将其修改回去，那么要原本的线程可能会在释放锁的时候将修改的值写回，导致状态的混乱</li><li>使用CAS实现的队列(堆栈)：如果在一个线程向队列中插入元素的同时，另一个线程将队列中的某个原像素删除，并且将其插入回来，那么原本的线程可能会认为队列中任然存在这个元素，导致状态的混乱</li><li>……</li></ol><h3 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h3><p>数据库有个锁成为乐观锁，是一种基于数据版本实现的数据同步机制，每次修改一次数据，版本号就会进行累加</p><p>同样，Java也提供了相应的原子引用类<code>AtomicStampedReference&lt;V&gt;</code></p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219190644368.png" alt="image-20221219190644368"></p><ul><li><code>reference</code>即我们实际存储的变量，</li><li><code>stamp</code>是版本，每次修改可以通过+1来保证版本唯一性</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义AtomicStampedReference </span></span><br><span class="line">        <span class="comment">// Pair.reference值为1, Pair.stamp为1</span></span><br><span class="line">        <span class="type">AtomicStampedReference</span> <span class="variable">atomicStampedReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span>[] stampHolder = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (<span class="type">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampHolder[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread1 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 阻塞1s</span></span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000000000L</span>);</span><br><span class="line">            <span class="comment">// Thread1通过CAS修改value值为3</span></span><br><span class="line">            <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 update from &quot;</span> + value + <span class="string">&quot; to 3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 update fail!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span>[] stampHolder = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (<span class="type">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampHolder[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread2 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// Thread2通过CAS修改value值为2</span></span><br><span class="line">            <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 update from &quot;</span> + value + <span class="string">&quot; to 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">                value = (<span class="type">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class="line">                stamp = stampHolder[<span class="number">0</span>];</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">                <span class="comment">// Thread2通过CAS修改value值为1</span></span><br><span class="line">                <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">1</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 update from &quot;</span> + value + <span class="string">&quot; to 1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Thread1 read value: 1, stamp: 1</span><br><span class="line">Thread2 read value: 1, stamp: 1</span><br><span class="line">Thread2 update from 1 to 2</span><br><span class="line">Thread2 read value: 2, stamp: 2</span><br><span class="line">Thread2 update from 2 to 1</span><br><span class="line">Thread1 update fail!</span><br></pre></td></tr></table></figure><p>这里就可以看到，ABB问题得到解决。A线程没有修改成功</p><blockquote><p><code>AtomicMarkableReference</code>可以理解为上面<code>AtomicStampedReference</code>的简化版</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219191150048.png" alt="image-20221219191150048"></p><p>就是不关心修改过几次，仅仅关心是否修改过</p><p>因此变量<code>mark</code>是<code>boolean</code>类型，仅记录值是够有过修改</p></blockquote><h2 id="原子类操作"><a class="header-anchor" href="#原子类操作">¶</a>原子类操作</h2><p>在并发编程中很容易出现并发安全的问题</p><blockquote><p>有一个很简单的例子就是多线程更新变量 <code>i=1</code>，比如多个线程执行<code>i++</code>操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过<code>synchronized</code>进行控制来达到线程安全的目的。但是由于<code>synchronized</code>是采用的悲观锁策略，并不是特别高效的一种解决方案，实际上，在JUC下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，应用类型，以及更新对象中的字段类型，atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p></blockquote><p>在<code>java.util.concurrent.atomic</code>包下提供了一组原子操作类：</p><ul><li>基本类型：<code>AtomicInteger、AtomicLong、AtomicBoolean</code></li><li>引用类型：<code>AtomicReference、AtomicStampedRerence、AtomicMarkableReference</code></li><li>数组类型：<code>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</code></li><li>对象属性原子修改器：<code>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、 AtomicReferenceFieldUpdater</code></li><li>原子类型累加器(jdk1.8过后出来的)：<code>DoubleAccumulator、DoubleAdder、 LongAccumulator、LongAdder、Striped64</code></li></ul><h3 id="原子更新基本数据"><a class="header-anchor" href="#原子更新基本数据">¶</a>原子更新基本数据</h3><p>以<code>AtomicInteger</code>总结下常用方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以原子的方式将实例中的原值加1，返回的是自增前的旧值；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">boolean</span> newValue)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试一下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;<span class="comment">// 原子自增 CAS</span></span><br><span class="line">                    sum.incrementAndGet();</span><br><span class="line">                    <span class="comment">//TODO</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行完过后，值为10000的结果呈现在面前……</p><blockquote><p><code>incrementAndGet()</code>方法通过CAS自增实现，如果CAS失败，自旋直到成功+1。</p></blockquote><h3 id="原子更新数组类型"><a class="header-anchor" href="#原子更新数组类型">¶</a>原子更新数组类型</h3><p>以<code>AtomicIntegerArray</code>为例总结常用的方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>测试一下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先创建数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//将其放在AtomicIntegerArray构造器中</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//设置索引0的元素为100</span></span><br><span class="line">    atomicIntegerArray.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    System.out.println(atomicIntegerArray.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//以原子更新的方式将数组中索引为1的元素与输入值相加</span></span><br><span class="line">    atomicIntegerArray.getAndAdd(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(atomicIntegerArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到输出结果</p><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">[100, 7, 3, 4, 5]</span><br></pre></td></tr></table></figure><h3 id="原子更新引用类型"><a class="header-anchor" href="#原子更新引用类型">¶</a>原子更新引用类型</h3><p><code>AtomicReference</code>作用是对普通对象的封装，他可以保证你在修改对象时的线程安全性</p><p><strong>测试一下</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化为 user1</span></span><br><span class="line">    AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    atomicReference.set(user1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 user2 赋给 atomicReference</span></span><br><span class="line">    atomicReference.compareAndSet(user1, user2);</span><br><span class="line">    System.out.println(atomicReference.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 user3 赋给 atomicReference</span></span><br><span class="line">    atomicReference.compareAndSet(user1, user3);</span><br><span class="line">    System.out.println(atomicReference.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">25</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="对象属性原子修改器"><a class="header-anchor" href="#对象属性原子修改器">¶</a>对象属性原子修改器</h3><p><code>AtomicIntegerFieldUpdater</code>可以线程安全地更新对象中的整形变量</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Candidate</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">realScore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Candidate</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candidate</span>();</span><br><span class="line"></span><br><span class="line">        Thread[] t = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">                        candidate.score2.incrementAndGet();</span><br><span class="line">                        scoreUpdater.incrementAndGet(candidate);</span><br><span class="line">                        realScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicIntegerFieldUpdater Score=&quot;</span> + candidate.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger Score=&quot;</span> + candidate.score2.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;realScore=&quot;</span> + realScore.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>AtomicIntegerFieldUPdater</code>的使用稍微有一些限制和约束：</p><ol><li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见</li><li>字段的描述类型(修饰符public/protect/default/private)与调用者与操作对象字段的关系一致，也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段</li><li>只能是实例变量，不能是类变量。也就是说不能加<code>static</code>关键字</li><li>只能是可修改变量，不能是<code>final</code>变量，因为<code>final</code>的语义就是不可修改。实际上<code>final</code>的语义和<code>volatile</code>是有冲突的，这两个关键字不能同时存在。</li><li>对于<code>AtomicIntegerFieldUpdatert</code>和<code>AtomicLongFIeldUpdater</code>只能修改int/long类型字段，不能修改器包装类型(Integer/Long)。如果要修改包装类型就需要使用<code>AtomicReferenceFieldUpdater</code></li></ol><blockquote><p><code>LongAdder</code>还没研究，等以后有时间了来再研究(💩)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
          <category> CAS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
            <tag> CAS </tag>
            
            <tag> 原子类操作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JMM与并发三大特性</title>
      <link href="/2022/12/12/JMM%E4%B8%8E%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/"/>
      <url>/2022/12/12/JMM%E4%B8%8E%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="并发和并行"><a class="header-anchor" href="#并发和并行">¶</a>并发和并行</h2><p>这两种动作的目标总的来说就是</p><blockquote><p>最大化CPU的使用率</p></blockquote><h3 id="并行"><a class="header-anchor" href="#并行">¶</a>并行</h3><p>并行指的是在同一时刻，有<strong>多条指令</strong>在<strong>多个处理器</strong>上同时执行，所以无论是在宏观还是在微观上，两者都是一起执行的</p><h3 id="并发-Concurrency"><a class="header-anchor" href="#并发-Concurrency">¶</a>并发(Concurrency)</h3><p>并发指的是在同一时刻只能有一条指令执行，但多个线程指令被迅速的轮换执行，使得在宏观上好像是具有多个进程在同时执行的效果，但是在微观上并不是多个在同时执行，只是时间分成若干段，是多个进程快速交替的执行</p><hr><p>看的出，并行是真的有两个CPU在跑，而并发是只有一个CPU在跑，只是跑的进程在快速的交替执行。</p><p>并行在多CPU系统中存在，而并发可以在单处理器系统和多处理器系统中都存在。</p><p>并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时只执行多个操作</p><h2 id="并发三大特性"><a class="header-anchor" href="#并发三大特性">¶</a>并发三大特性</h2><p>并发编程Bug的源头：可见性、原子性、有序性</p><h3 id="可见性"><a class="header-anchor" href="#可见性">¶</a>可见性</h3><blockquote><p>当一个线程修改了<strong>共享资源</strong>的值，其他线程能够看到修改的值</p></blockquote><p>Java内存模型 (<code>JMM</code>)是通过在变量修改后将新值同步会主存，在变量读取之前从主存刷新变量值这种依赖主存作为传递媒介的方法来实现可见性的</p><h4 id="如何保证可见性"><a class="header-anchor" href="#如何保证可见性">¶</a>如何保证可见性</h4><ul><li>通过<code>volatile</code>关键字保证可见性</li><li>通过内存屏障保证可见性</li><li>通过<code>synchronized</code>关键字保证可见性</li><li>通过Lock保证可见性</li><li>通过<code>final</code>关键字保证可见性</li></ul><h3 id="有序性"><a class="header-anchor" href="#有序性">¶</a>有序性</h3><blockquote><p>即程序执行代码的顺序按照代码的先后顺序执行</p></blockquote><p>由于<code>JVM</code>存在<strong>指令重排</strong>，所以存在有序性问题</p><h4 id="如何保证有序性"><a class="header-anchor" href="#如何保证有序性">¶</a>如何保证有序性</h4><ul><li>通过<code>volatile</code>关键字保证有序性</li><li>通过内存屏障保证有序性</li><li>通过<code>synchronized</code>关键字保证有序性</li><li>通过Lock保证有序性</li></ul><h3 id="原子性"><a class="header-anchor" href="#原子性">¶</a>原子性</h3><blockquote><p>一个或多个操作</p><p>要么全部执行且在执行的过程中不能被任何元素打断</p><p>要么全部不执行</p><hr><p>梦回开哥……(<strong>LBWNB(撕心裂肺)</strong>)</p><p>：一个人谈恋爱</p><p>：出轨的次数只有</p><p>：0</p><p>：和</p><p>：N</p></blockquote><p>在Java当中，对基本数据类型的变量的读取和赋值的操作是原子性操作(64位)，如果不采取任何原子性保障措施的自增操作并不是原子性的，存在原子性问题</p><h3 id="如何保证原子性"><a class="header-anchor" href="#如何保证原子性">¶</a>如何保证原子性</h3><ul><li>通过<code>synchronized</code>关键字保证原子性</li><li>通过Lock保证原子性</li><li>通过CAS保证原子性</li></ul><h2 id="Java内存模型-JMM"><a class="header-anchor" href="#Java内存模型-JMM">¶</a>Java内存模型(JMM)</h2><blockquote><p>JVM规范定义了一个Java内存模型(Java Memory Model)，即JMM。</p><p>用于屏蔽掉各种硬件的OS的内存访问差异，以让Java程序在各种平台下都能达到一致的并发效果，JMM规范了JVM和计算机内存是如何协同工作的：</p><p>规定了一个线程如何、以及何时可以看到有其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</p></blockquote><p>这里给出JMM的模型图</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214091941422.png" alt="image-20221214091941422"></p><h3 id="内存交互操作"><a class="header-anchor" href="#内存交互操作">¶</a>内存交互操作</h3><p>关于<strong>主内存</strong>和<strong>工作内存</strong>之间的交互协议，即：</p><ul><li>一个变量如何存主内存中拷贝到工作内存、</li><li>如何从工作内存同步到主内存之间的实现细节</li></ul><p>JMM定义了八种操作来完成：</p><ul><li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li><li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li><li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li><li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li><li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要<strong>使用变量的值</strong>的字节码指令时将会执行这个操作。</li><li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个<strong>给变量赋值</strong>的字节码指令时执行这个操作。</li><li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li><li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li></ul><p>将上图改造一下：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214092607126.png" alt="image-20221214092607126"></p><p>JVM还规定了，再执行上述8种操作的时候，必须满足一下规则：</p><ul><li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行<code>store</code>和<code>write</code>操作。 但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li><li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现</li><li>不允许一个线程丢弃它的最近<code>assign</code>的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li><li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从工作内存同步回主内存中。</li><li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量。即就是对一个变量实施<code>use</code>和<code>store</code>操作之前，必须先执行过 了<code>assign</code>和<code>load</code>操作。</li><li>一个变量在同一时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。</li><li><code>lock</code>和<code>unlock</code>必须成对出现</li><li>如果对一个变量执行<code>lock</code>操作，将会清空工作内存中此变量的值，在执行引擎使用 这个变量前需要重新执行load或assign操作初始化变量的值</li><li>如果一个变量事先没有被<code>lock</code>操作锁定，则不允许对它执行<code>unlock</code>操作；也不允许去<code>unlock</code>一个被其他线程锁定的变量。</li><li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步到主内存中（执行store和 write操作）。</li></ul><h2 id="volatile"><a class="header-anchor" href="#volatile">¶</a>volatile</h2><h3 id="volatile的特性"><a class="header-anchor" href="#volatile的特性">¶</a>volatile的特性</h3><ul><li>可见性：对于一个<code>volatile</code>变脸的读操作，总是能看到(任意线程)对这个<code>volatile</code>变量最后的写操作</li><li>原子性：对任意单个<code>volatile</code>变量的读/写操作具有原子性，但类似于volatile++这种符合操作不具有原子性，<strong>(基于这点，我们通常会认为volatile不具有原子性)</strong>。volatile仅仅保障对单个volatile变量的读/写操作具有原子性，而锁的互斥执行h的特性可以确保对整个临界区代码的执行具有原子性</li><li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的<strong>内存屏障</strong>来禁止指令重排序来保证有序性</li></ul><h3 id="volatile写-读的内存语义"><a class="header-anchor" href="#volatile写-读的内存语义">¶</a>volatile写-读的内存语义</h3><ul><li>当<strong>写</strong>一个volatile变量时，JMM会把该线程对应的<strong>本地内存</strong>中的<strong>共享变量值刷新到主内存</strong></li><li>当<strong>读</strong>一个volatile变量时，JMM会把该线程对应的<strong>本地内存</strong>置为<strong>无效</strong>，线程接下来将从主内存中读取共享变量</li></ul><h3 id="volatile的可见性实现"><a class="header-anchor" href="#volatile的可见性实现">¶</a>volatile的可见性实现</h3><p>volatile修饰的变量的read、load、use操作和assign、store、write操作必须是连续的<br>即修改后必须立即同步回主内存，使用时必须从主内存刷新。</p><p>由此保证volatile变量操作对多线程的可见性</p><h4 id="硬件层面的实现"><a class="header-anchor" href="#硬件层面的实现">¶</a>硬件层面的实现</h4><p>通过lock前缀指令，volatile变量的操作会锁定变量<strong>缓存行</strong>区域并写回主内存，这个操作被称之为：“缓存锁定”。缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效</p><h4 id="lock前缀指令的作用"><a class="header-anchor" href="#lock前缀指令的作用">¶</a>lock前缀指令的作用</h4><ol><li>确保后续指令执行的原子性。在Pentium及其之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他线程无法对总线程进行访问，很显然这样做的开销十分巨大。<br>在新的处理器中，Inter使用缓存锁定来保证指令执行的原子性，缓存锁定将大大地减低了lock前缀指令的执行开销。因为，与锁住总线不同，缓存锁定只是<strong>锁定变量缓存行区域</strong>……</li><li>lock前缀指令具有类似于内存屏障的功能，禁止指令与前面和后面的读写指令重排序(指令重排)</li><li>lock前缀指令会等待他之前所有的指令完成、并且所有缓冲的的写操作写回内存(也就是将store buffer中的内容写入内存)之后才开始执行，并且根据缓存一致性协议，刷新store buffer的操作会导致其他cache中的副本失效</li></ol><blockquote><p>这里的lock前缀指令：</p><p><a href="https://www.cnblogs.com/sunddenly/articles/14829255.html">Lock指令作用</a></p><p><a href="https://www.jianshu.com/p/2171e180bdbd">Lock指令前缀</a></p></blockquote><h2 id="指令重排序"><a class="header-anchor" href="#指令重排序">¶</a>指令重排序</h2><blockquote><p>Java语言规范规定<code>JVM线程内部维持顺序化语义</code>(什么逆天命名)<br>即，只要程序的最终结果与它顺序话情况的结果相等，那么指令的执行顺序可与代码顺序不一致，这个过程叫做指令的重排序——也叫指令重排</p></blockquote><p>指令重排的意义：</p><blockquote><p>JVM能根据处理器的特性(CPU多级缓存系统、多核处理器……)适当的对机器指令进行重排序，是的机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p><p>在编译器与CPU处理器中都能执行指令重排优化</p><p>即下图</p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214192330065.png" alt="image-20221214192330065"></p><h3 id="volatile指令重排规则"><a class="header-anchor" href="#volatile指令重排规则">¶</a>volatile指令重排规则</h3><table><thead><tr><th>是否能重排序</th><th>第二个操作</th><th></th><th></th></tr></thead><tbody><tr><td>第一个操作</td><td>普通读/写</td><td>volatile读</td><td>volatile写</td></tr><tr><td>普通读/写</td><td></td><td></td><td>NO</td></tr><tr><td>volatile读</td><td>NO</td><td>NO</td><td>NO</td></tr><tr><td>volatile写</td><td></td><td>NO</td><td>NO</td></tr></tbody></table><p>volatile禁止指令重序的场景：</p><ol><li>第二个操作是volatile写，都不会出现指令重排</li><li>第一个操作是volatile读，都不会出现指令重排</li><li>第一个操作是volatile写，第二个操作是volatile读，不会发生指令重排</li></ol><p>总结：</p><p>这次写的很多东西其实都挺浅的，没有发展到汇编层面，(有没有可能是自己都没有记住💩)，还有内存屏障，MESI……</p><p>等以后沉淀够了再来补</p><p>落：2022-12-14 19:34:45</p><blockquote><p>可以看看CoderW的这篇文章：<a href="https://juejin.cn/post/7109464558783168526">关于缓存一致性协议、MESI、StoreBuffer、InvalidateQueue、内存屏障、Lock指令和JMM的那点事</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
          <category> 并发编程 </category>
          
          <category> 八股 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
            <tag> JMM </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WebFlux——响应式编程</title>
      <link href="/2022/12/10/WebFlux/"/>
      <url>/2022/12/10/WebFlux/</url>
      
        <content type="html"><![CDATA[<p>响应式编程打破了传统的<strong>同步阻塞式编程模型</strong>，而这样往往对性能的消耗是过大的（相对来说嘛），但是基于<strong>响应式数据流</strong>和<strong>背压机制</strong>实现了<strong>异步非阻塞式</strong>的网络通讯、数据访问和事件驱动架构，能减轻服务器资源之间的竞争关系，从而提高服务的响应能力。</p><p>这也是<strong>WebFlux</strong>——Spring出产的基于响应式编程的一套<strong>应用程序框架模型</strong>，的诞生之际……</p><h2 id="背压"><a class="header-anchor" href="#背压">¶</a>背压</h2><p>首先先讲讲<strong>背压</strong></p><p>我们明确，纯“推”的模式下，数据流会有很多不可控制的因素，所以我们需要实现流量控制，这个时候，背压就出来了</p><p>背压，简单来说就是下游能够向上游反馈流量请求的机制。如果消费者消费数据的速度 &lt; 生产者生产数据的速度时，他就会持续消耗系统的资源，知道这些资源被消耗殆尽。这里指的是生产者消耗资源。这个时候，需要一种机制来使得消费者可根据自身当前的处理能力通知生产者来调整生产数据的速度，这种机制就是背压。</p><p>消费者会根据自身的处理能力来请求数据，而生产者也会以根据消费者的消费速度来生产数据，从而在两者之间达成一种动态的平衡，确保系统的及时响应性。</p><h2 id="应用场景"><a class="header-anchor" href="#应用场景">¶</a>应用场景</h2><p>本质上，响应式编程是一种编程技术，还更是一种架构设计的系统方法。所以可以应用于任何地方，简单的Web应用程序，大型企业的解决方案。当然我们也完全可以基于他来构建流式系统或者大数据系统</p><h3 id="Netflix-Hystrix-中的滑动窗口"><a class="header-anchor" href="#Netflix-Hystrix-中的滑动窗口">¶</a>Netflix Hystrix 中的滑动窗口</h3><p>在Spring Cloud中，Hystrix 是奈飞的一个开源容错库，使用了<code>HystrixCircuitBreaker</code>这个类来实现熔断器。</p><p>这个类是通过一个<code>circuitOpen</code>状态位来控制着整个熔断过程，而这个状态位本身的状态值则取决于系统目前的执行数据和健康指标</p><p>那么如何来实现着滑动窗口呢？系统运行时的每一个数据都被视为一个个的<code>event</code>，滑动窗口中的每一个桶——<code>Bucket</code> 都来自源源不断的事件。在技术实现的选型上，Hystrix 采用的基于响应式编程思想的<strong>RxJava</strong>。</p><p>……</p><p>作为总结，Hystrix巧妙的使用了RxJava的 <code>window</code>、<code>flatMap</code> 等操作符来将单位窗口时间内的事件，以及将一个窗口大小内的<code>Bucket</code>聚集到一起形成滑动窗口，并基于滑动窗口继承指标数据，</p><h2 id="Flux-Mono"><a class="header-anchor" href="#Flux-Mono">¶</a>Flux &amp; Mono</h2><p><img src="https://img-blog.csdnimg.cn/3570da1e74d0443cb298fc0df5f824ec.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3loal85MTE=,size_16,color_FFFFFF,t_70" alt=""></p><blockquote><p>Flux 是一个发出(emit)0-N个元素组成的异步序列的Publisher<T>,可以被onComplete信号或者onError信号所终止。在响应流规范中存在三种给下游消费者调用的方法 onNext, onComplete, 和onError。</p><p>Mono 是一个发出(emit)0-1个元素的Publisher<T>,可以被onComplete信号或者onError信号所终止。<br>这里就不翻译了，整体和Flux差不多，只不过这里只会发出0-1个元素。也就是说不是有就是没有。</p></blockquote><p>Flux和Mono是Java响应式中的重要概念，这其实是规定了两种流式范式，这种范式让数据具有一些新的特性，比如基于发布订阅的事件驱动，异步流、背压等等。另外数据是推送（Push）给消费者的以区别于平时我们的拉（Pull）模式。同时我们可以像Stream Api一样使用类似map、flatmap等操作符（operator）来操作它们。</p><h3 id="创建Flux-Mono"><a class="header-anchor" href="#创建Flux-Mono">¶</a>创建Flux&amp;Mono</h3><blockquote><p>2022-12-10 22:23:21 先run，等明天起来再写(明天桌子和鼠标垫就到了，到时候直接原地起飞🚀)</p></blockquote><blockquote><p>2022-12-11 08:26:25 起来了，坏消息，今天桌子很有可能到不了。（以后买东西死都不买南京发货的的了）</p></blockquote><p>这里分为静态以及动态创建</p><h4 id="静态创建"><a class="header-anchor" href="#静态创建">¶</a>静态创建</h4><p>静态创建Flux和Mono的方式都是一样的</p><h5 id="just"><a class="header-anchor" href="#just">¶</a>just</h5><p><strong>Flux</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">//观察者监听被观察者(消费者)</span></span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用可变参数创建Flux</span></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用just创建Mono</span></span><br><span class="line">Mono.just(<span class="string">&quot;1s&quot;</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"> Mono.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p><strong>Mono</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line"><span class="comment">//观察者监听被观察者(消费者)</span></span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用可变参数创建Flux</span></span><br><span class="line">Flux.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用just创建Mono</span></span><br><span class="line">Mono.just(<span class="string">&quot;1s&quot;</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"> Mono.just(<span class="keyword">new</span> <span class="title class_">Integer</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>像这样使用<code>just</code>静态创建Flux和Mono，前提需要知道内容和大小的数据</p><h5 id="fromIterable"><a class="header-anchor" href="#fromIterable">¶</a>fromIterable</h5><p>使用fromIteratble从可迭代对象中创建Flux</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="comment">//从可迭代的对象中创建Flux</span></span><br><span class="line">Flux.fromIterable(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">.subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">ArrayList&lt;Integer&gt; list = Lists.newArrayList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">Flux&lt;Integer&gt; flux = Flux.fromIterable(list);</span><br><span class="line"><span class="comment">//在创建Flux后追加元素</span></span><br><span class="line">list.add(<span class="number">5</span>);</span><br><span class="line">flux.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="fromStream"><a class="header-anchor" href="#fromStream">¶</a>fromStream</h5><p>使用fromStream从集合流中创建Flux</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.fromStream(Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">               .subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="range"><a class="header-anchor" href="#range">¶</a>range</h5><p>创建一个范围内迭代的Flux</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">0</span>,<span class="number">10</span>)</span><br><span class="line">.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="动态创建"><a class="header-anchor" href="#动态创建">¶</a>动态创建</h4><p>动态创建有时候更容易满足我们发开时的需求</p><h5 id="generate"><a class="header-anchor" href="#generate">¶</a>generate</h5><p><code>generate()</code>方法生成Flux序列依赖于Reactor所提供的<code>SynchronousSink</code>组件，他的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="title function_">generate</span><span class="params">(Consumer&lt;SynchronousSink&lt;T&gt;&gt; generator)</span></span><br></pre></td></tr></table></figure><p><code>SynchronousSink</code>组件，看名字就能知道他是一个同步的Sink组件，也就是说元素的生成过程是同步执行的。</p><p>这个组件包括三个核心方法：</p><ol><li><code>next()</code></li><li><code>complete()</code></li><li><code>error()</code></li></ol><p>使用<code>generate()</code>方法创建Flux的实例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 同步动态创建， next() 方法只能最多被调用一次</span></span><br><span class="line">Flux.generate(sink -&gt; &#123;</span><br><span class="line">sink.next(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="comment">//第二次会报错:</span></span><br><span class="line"><span class="comment">//java.lang.IllegalStateException: More than one call to onNext</span></span><br><span class="line"><span class="comment">//sink.next(&quot;2&quot;);</span></span><br><span class="line"><span class="comment">//如果不调用 complete() 方法，那么就会生成一个所有元素均为“1”的无界数据流</span></span><br><span class="line">sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h5 id="create"><a class="header-anchor" href="#create">¶</a>create</h5><p><code>create()</code>方法和<code>generate()</code>是方法比较类似，但是他使用的是一个<code>FluxSink</code>组件，他的定义：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Flux&lt;T&gt; <span class="title function_">create</span><span class="params">(Consumer&lt;? <span class="built_in">super</span> FluxSink&lt;T&gt;&gt; emitter)</span></span><br></pre></td></tr></table></figure><p>与<code>generate()</code>不同的是，<code>create()</code>方法定义了我们上面所讲到的背压机制，并且一次调用可以产生多个元素。使用它创建Flux的实例：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.create(sink -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">                sink.next(<span class="string">&quot;Tang&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">            sink.complete();</span><br><span class="line">&#125;).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="操作符"><a class="header-anchor" href="#操作符">¶</a>操作符</h3><p>这里只列举出一些简单常用的操作符，包括<code>buffer</code>，<code>window</code>，<code>take</code>……</p><h4 id="buffer"><a class="header-anchor" href="#buffer">¶</a>buffer</h4><p><code>buffer</code>以及其相关的操作符都是将当前流中的元素收集到集合中，并把集合对象作为流中的新元素。buffer 相关操作符的使用示例</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).buffer(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">Flux.intervalMillis(<span class="number">100</span>).bufferMillis(<span class="number">1001</span>).take(<span class="number">2</span>).toStream().forEach(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferUntil(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br><span class="line">Flux.range(<span class="number">1</span>, <span class="number">10</span>).bufferWhile(i -&gt; i % <span class="number">2</span> == <span class="number">0</span>).subscribe(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="filter"><a class="header-anchor" href="#filter">¶</a>filter</h4><p>响应式流中的<code>filter</code>操作符和stream流中的<code>filter</code>操作符的作用以及使用是差不多甚至是一样的，就不在赘述了</p><h4 id="window"><a class="header-anchor" href="#window">¶</a>window</h4><p><code>window</code>操作符的作用类似于<code>buffer</code>，所不同的是<code>window</code>操作符是将当前流中的元素收集到另外的Flux序列汇总，一次返回值类型是<code>Flux&lt;Flux&gt;</code>：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.range(<span class="number">1</span>, <span class="number">100</span>).window(<span class="number">20</span>).subscribe(System.out::println);</span><br><span class="line">Flux.intervalMillis(<span class="number">100</span>).windowMillis(<span class="number">1001</span>).take(<span class="number">2</span>).toStream().forEach(System.out::println);</span><br></pre></td></tr></table></figure><h4 id="take"><a class="header-anchor" href="#take">¶</a>take</h4><p><code>take</code>系列操作符用来从当前流中提取元素，提取的方式可以用很多种</p><p>这里的提取，无非就是一些消费</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">takeLast(<span class="type">long</span> n)：提取流中的最后 N 个元素。</span><br><span class="line">takeUntil(Predicate&lt;? <span class="built_in">super</span> T&gt; predicate)：提取元素直到 Predicate 返回 <span class="literal">true</span>。</span><br><span class="line">takeWhile(Predicate&lt;? <span class="built_in">super</span> T&gt; continuePredicate)： 当 Predicate 返回 <span class="literal">true</span> 时才进行提取。</span><br><span class="line">takeUntilOther(Publisher&lt;?&gt; other)：提取元素直到另外一个流开始产生元素。</span><br></pre></td></tr></table></figure><h4 id="flatMap"><a class="header-anchor" href="#flatMap">¶</a>flatMap</h4><p><code>flatMap</code>可以说是经常使用的操作符了</p><p><code>flatMap</code>和<code>flatMapSequential</code>操作符吧流中的每一个元素转换成一个流，在吧所有流中的元素进行合并</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Flux.just(<span class="number">5</span>, <span class="number">10</span>)</span><br><span class="line">        .flatMap(x -&gt; Flux.intervalMillis(x * <span class="number">10</span>, <span class="number">100</span>).take(x))</span><br><span class="line">        .toStream()</span><br><span class="line">        .forEach(System.out::println);</span><br></pre></td></tr></table></figure><p>到这里，响应式流的操作符(API)，就差不多(其实差的还是有点多~ . ~)了</p><h2 id="RSocket"><a class="header-anchor" href="#RSocket">¶</a>RSocket</h2><h3 id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><p>我们知道常用的HTTP协议的优势在于其广泛的适用性，有很多的服务器和客户端实现工具的支持，但是HTTP协议本身比较简单，只支持<strong>请求-响应</strong>模式，而这种模式对于很多应用场景来说是不合适的</p><p>比如说消息推送</p><blockquote><p>以HTTP为例，如果客户端需要获取最新的推送消息，就必须使用轮询。客户端不断地发送请求到服务器来检查更新，这无疑造成了大量的资源浪费。</p></blockquote><p>这个时候，响应式规范后面的开发团队理解了</p><ol><li>跨网络</li><li>异步</li><li>低延迟通信</li></ol><p>的必要性了。</p><p>2015年，<strong>RSocket</strong>协议就在这样的背景下，破壳……</p><p>RSocket是一个二进制的协议，以异步消息的方式提供4种交互模式</p><ul><li>请求-响应模式：这个也是最经典也最常见的模式，发送方在发送消息给接收方之后，等待与之对应的响应消息</li><li>请求-响应<strong>流</strong>模式：以消息流作为响应</li><li>即发-即忘模式：发送方的请求消息没有与之对应的响应</li><li>通道模式：在发送方和接收方之间建立一个双向传输的通道</li></ul><h3 id="如何使用"><a class="header-anchor" href="#如何使用">¶</a>如何使用</h3><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.rsocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rsocket-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.rsocket<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rsocket-transport-netty<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果想以Spring框架集成</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-rsocket<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>构建一个简单的<code>DemoController</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloController</span> &#123;</span><br><span class="line"> </span><br><span class="line">  <span class="meta">@MessageMapping(&quot;hello&quot;)</span></span><br><span class="line">  <span class="keyword">public</span> Mono&lt;String&gt; <span class="title function_">hello</span><span class="params">(String input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> Mono.just(<span class="string">&quot;Hello: &quot;</span> + input);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里 <code>@MassageMapping</code>是Spring提供的一个注解，用来指定WebSocket、RSocket等协议中消息处理的目的地</p><p>为了访问这个RSocket端点，我们需要创建一个<code>RSocketRequester</code>对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RSocketRequester.Builder builder;</span><br><span class="line">&#123; </span><br><span class="line">    <span class="type">RSocketRequester</span> <span class="variable">requester</span> <span class="operator">=</span> builder.dataMimeType(MimeTypeUtils.TEXT_PLAIN)</span><br><span class="line">                .connect(TcpClientTransport.create(<span class="number">7000</span>)).block();</span><br><span class="line"></span><br><span class="line">    Mono&lt;String&gt; response = requester.route(<span class="string">&quot;hello&quot;</span>)</span><br><span class="line">            .data(<span class="string">&quot;World&quot;</span>)</span><br><span class="line">            .retrieveMono(String.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="集成中间件"><a class="header-anchor" href="#集成中间件">¶</a>集成中间件</h2><ul><li>MongoDB集成</li><li>Redis集成</li><li>R2DBC集成</li><li>MQ集成</li><li>……</li></ul><p>这里关于中间件的集成，我更愿意给出类似于官方的官方<a href="https://hantsy.github.io/spring-reactive-sample/">文档</a></p><p>这里面包含了中间件的继承过程</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221211091923548.png" alt="image-20221211091923548"></p><h2 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h2><p>相对于WebMVC这样一个众所周知的，在全世界有超过十年以上的广泛应用的框架，WebFlux倒是显得有点乳臭了。</p><p>毕竟，对异步、非阻塞的编程，不管是在编码上，维护上，还是在调试上都是一件很困难的事情。因为异步编程是基于回调的，由一个时间循环驱动，在尝试跟踪请求时，事件循环的堆栈跟踪毫无意义。正是因为处理的是事件和回调，很少用工具可以帮助调试。</p><p>边界情况、未处理的异常以及错误处理的状态更改会创建悬空资源，从而导致内存泄漏、文件描述符泄漏或丢失响应等……</p><p>以后：</p><blockquote><p>尽可能的适应，并采用响应式编程来代替目前的编程模型，达到全栈式的响应式应用程序的编写。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
          <category> 响应式编程 </category>
          
          <category> WebFlux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>大二寒假TOTO-LIST</title>
      <link href="/2022/12/07/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87TOTO-LIST/"/>
      <url>/2022/12/07/%E5%A4%A7%E4%BA%8C%E5%AF%92%E5%81%87TOTO-LIST/</url>
      
        <content type="html"><![CDATA[<h1>大二寒假TOTO-LIST</h1><p>2022-12-7 19:08:45</p><h2 id="技术栈"><a class="header-anchor" href="#技术栈">¶</a>技术栈</h2><ul><li><p>[x] WebFlux</p><ul><li>[x] Reactor操作</li><li>[x] 集成组件<ul><li>[ ] Redis</li><li>[x] MongoDB</li><li>[x] R2DBC</li><li>[ ] MQ</li></ul></li></ul></li><li><p>[ ] 并发编程</p><ul><li>[x] Java并发线程池底层原理</li><li>[ ] JUC并发集合底层原理</li><li>[x] CASAtomic</li><li>[x] JMM并发三大特性</li><li>[ ] 锁机制</li></ul></li><li><p>[ ] Mysql-Tomcat</p><ul><li>[ ] Mysql性能优化</li><li>[x] Tomcat整体机构</li><li>[x] Tomcat线程模型</li></ul></li><li><p>[ ] Jvm</p><ul><li>[ ] JVM类加载机制</li><li>[ ] JVM对象创建和内存分配机制</li><li>[ ] class字节码文件结构</li><li>[ ] 垃圾回收</li><li>[ ] JVM调优</li><li>[ ] JTM</li><li>[ ] Cloud-Native Java虚拟</li><li>[ ] Hotspot</li></ul></li><li><p>[ ] Redis</p><ul><li>[ ] Cluster集群</li><li>[ ] 核心数据结构</li><li>[ ] 分布式锁</li></ul></li><li><p>[ ] MongoDB(暂定)</p></li><li><p>[ ] Sharding-Sphere</p><ul><li>[ ] 简单实操——不准备研究源码以及于原理</li><li>[ ] Sharding-Proxy （?暂定）</li></ul></li><li><p>[ ] Netty</p><ul><li>[ ] 常见的组件使用</li><li>[ ] 核心线程模型</li><li>[ ] 底层数据交互</li></ul></li></ul><p>我不准备在这个时间段去研究源码，一是因为我本来就是个不爱看书的人，直接喊我去看源码，研究别人怎么实现的大概率会打瞌睡，二是顾虑到怕本来底层都没研究清楚就去看源码的话，到时候说不定会本末倒置……</p><h2 id="课程学习"><a class="header-anchor" href="#课程学习">¶</a>课程学习</h2><p>说来好笑，本就已经不听课了，但奈何nmmd邮专非得下学期来了才考试，非暑假复习不可，不然得挂了，我还是想明年的这个时候还是有至少1000的慰藉吧。</p><ul><li>线性代数</li><li>数据结构</li><li>大学物理</li><li>编程基础</li><li>离散数学</li><li>CET6</li><li>工程伦理</li><li>工程管理与经济决策</li></ul><h2 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h2><p>等到时候要开学了我再来写……</p>]]></content>
      
      
      <categories>
          
          <category> TODO-LIST </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TODO-LIST </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蓝山2022Java第四节课</title>
      <link href="/2022/12/04/%E8%93%9D%E5%B1%B12022Java%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%AF%BE/"/>
      <url>/2022/12/04/%E8%93%9D%E5%B1%B12022Java%E7%AC%AC%E5%9B%9B%E8%8A%82%E8%AF%BE/</url>
      
        <content type="html"><![CDATA[<h1>🌟蓝山2022Java第四次课🌟</h1><p>如果在场的各位坚持到我这节课了的话，恭喜你们，在Java这门编程语言的学习暂时告一段落了(bushi)，当然，一些卷王请自便<strong>Deep Learning</strong></p><p>从第一节课，罗神的讲的Java语法基础</p><p>到第二节课，籍楠姐姐讲的面向对象基础，</p><p>到第三节课，海神介绍的面向对象进阶，相信各位坚持下来的卷王们，肯定对Java这门语言，有了完全不同的认识</p><p>那么Java第四节课，主要就是介绍一些Java的一些高级特性</p><ul><li>IO</li><li>异常处理</li><li>反射</li><li>泛型</li><li>线程</li><li>…</li></ul><p>首先讲讲异常处理吧</p><p>艹，走，忽略</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122222714567.png" alt="image-20221122222714567" align="left" style="zoom:80%;" /><h2 id="💥异常处理"><a class="header-anchor" href="#💥异常处理">¶</a>💥异常处理</h2><p>在日常生活中，很多事情并非总是按照人们自己设计意愿顺利发展的，经常出现这样那样的异常情况。</p><blockquote><p>例如：沃日，今天部门要开例会，我tm中午回寝室就睡觉了。部长打过来电话都没接到，下次指定没我好果汁吃…</p></blockquote><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221028204320223.png" alt="image-20221028204320223" align="left" alignstyle="zoom:100%;" /><p>计算机程序的编写其实有时候也需要考虑处理这些异常情况，<code>异常(Exception)</code>，就是在运行程序的时候产生的一种异常情况</p><p>同时这也已经成为了衡量一门语言是否成熟的标准。目前的主流编程语言，如：C++、C#、Ruby、Rust、Python…等大都提供了异常处理机制</p><p>所以本节我们来介绍Java异常处理的相关知识</p><hr><h3 id="异常介绍"><a class="header-anchor" href="#异常介绍">¶</a>异常介绍</h3><p>Java中的异常又称：<strong>“例外”</strong>，是一个在程序执行期间发生的时间，他中断正在执行程序的<strong>正常指令</strong>，或者<strong>指令流</strong>，(也就是一串指令)。为了能够及时、有效第处理程序中的运行错误，这个时候必须使用异常类，这可以让程序具有极其可观的<strong>容错性和健壮性</strong>。</p><p>在Java中，一个异常的产生，主要有以下三中情况：</p><ul><li>Java内部错误发生异常，Java虚拟机产生的异常</li><li>编写的程序代码中的错误所产生的的异常，例如<code>NullPointException</code>空指针异常、<code>IndexBoundException</code>数组越界异常等等</li><li>通过<code>throw</code>语句手动生成的异常，一般用来告知该方法的调用者一些必要信息<br><code>throw</code>这个关键字等下会讲，我知道你很急，但你先别急…<br><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221028205457764.png" align="left" alt="image-20221028205457764" style="zoom:80%;" /></li></ul><h3 id="Java中的异常处理机制与语法"><a class="header-anchor" href="#Java中的异常处理机制与语法">¶</a>Java中的异常处理机制与语法</h3><p>语法格式：</p><blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">//可能出现异常的的代码</span></span><br><span class="line"> <span class="comment">//if (try中的代码出现问题了 &amp;&amp; 这里catch捕获的时候异常类型与try中跑出的异常类型一致的时候，或者是try中抛出异常的父类的时候，) ——&gt;  就会对异常进行异常处理</span></span><br><span class="line"> <span class="comment">//处理完成后，就跳出 try-catch 语句，继续执行后续的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;<span class="comment">//Exception 是需要捕获的异常类型</span></span><br><span class="line">e.printStackTrance();</span><br><span class="line"> <span class="comment">//...其他的一些异常处理</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//不管try代码里面是否出现了异常，</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><p>一首小悟结束异常处理：</p><ul><li>世界上最遥远的距离，是我在if里你在else里，<br>似乎一直相伴有永远分离；</li><li>世界上最痴心的等待，是我当case你是switch，<br>或许永远都选不上自己；</li><li>世界上最真情的相依，是你在try我在catch<br>无论你发什么什么脾气，<br>我都默默承受，静静处理<br>到那时候，再来期待我们的finally</li></ul><p>——来自BIlibili尚硅谷宋红康老师的笔记</p><hr><h3 id="异常的类型"><a class="header-anchor" href="#异常的类型">¶</a>异常的类型</h3><p>为了能够及时有效的处理出现的异常，Java专门引入了异常类<code>(Exceptoin)</code>，在Java中所有异常类型都是内置<code>java.lang.Throwable</code>类的子类，也就是说，<code>Throwable</code>是站在<strong>异常链顶端的男人</strong></p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221029081055771.png" align="left" alt="image-20221029081055771" style="zoom: 90%;" /><p><strong>常见的异常类型</strong></p><table><thead><tr><th>异常类型名称</th><th>异常类型说明</th></tr></thead><tbody><tr><td>ArithmeticException</td><td>算数异常</td></tr><tr><td>IndexOutOfBoundsException</td><td>角标越界异常</td></tr><tr><td>ClassCastException</td><td>类型转换异常</td></tr><tr><td>NullPointException</td><td>空指针异常</td></tr><tr><td>NumberFormatException</td><td>数字格式化异常</td></tr><tr><td>…</td><td>…</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Courseware-Backend-Java-2022</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 常见异常类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-11-22 19:20</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CommonException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//NullPointerException</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;integer.toString() = &quot;</span> + integer.toString());</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//ClassCastException</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">x</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Integer</span>(<span class="number">0</span>);</span><br><span class="line">        System.out.println((String)x);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">        <span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.out.println(list.get(<span class="number">0</span>));</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="自定义异常类"><a class="header-anchor" href="#自定义异常类">¶</a>自定义异常类</h3><p>为什么要自定义异常类呢？？？？？</p><p>当我们的文件中出现多个异常的时候，显然<code>RuntimeException</code>就不能满足我们的需求了</p><p>从业务角度去理解的话，就比如处理一个文件，有可能会出现网络异常，有可能会出现数据库异常，有可能会出现……</p><p>这个时候自定义异常类，就相当于将他们细化了</p><p>手搓一个：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Courseware-Backend-Java-2022</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 自定义异常类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-11-22 19:31</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeiQianException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Double money;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MeiQianException</span><span class="params">(Double money)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="string">&quot;余额不足，还差：&quot;</span> + money);</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">AccountAdmin</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> Double balance;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">AccountAdmin</span><span class="params">(Double balance)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//存钱的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">deposit</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.balance += money;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取钱的方法</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">withdraw</span><span class="params">(<span class="type">double</span> money)</span> <span class="keyword">throws</span> MeiQianException &#123;</span><br><span class="line">            <span class="keyword">if</span> (balance &gt;= money) &#123;</span><br><span class="line">                balance -= money;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="type">double</span> <span class="variable">needMoney</span> <span class="operator">=</span> money - balance;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MeiQianException</span>(needMoney);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AccountAdmin</span> <span class="variable">accountAdmin</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AccountAdmin</span>(<span class="number">100.0</span>);</span><br><span class="line">        accountAdmin.deposit(<span class="number">200</span>);<span class="comment">//先存二伯块</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//再取四伯块</span></span><br><span class="line">            accountAdmin.withdraw(<span class="number">400</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (MeiQianException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Throw、Throws"><a class="header-anchor" href="#Throw、Throws">¶</a>Throw、Throws</h3><h4 id="什么是Throw"><a class="header-anchor" href="#什么是Throw">¶</a>什么是Throw</h4><p>throw是java中关于异常的一种操作如果在<code>try&#123;&#125;catch&#123;&#125;</code>中使用了throw，即代表自己去书写这个方法——自己处理异常，也是一个<strong>手动抓取</strong>的动作，可以使程序停止并报出异常信息。</p><p><strong>其好处是：</strong></p><ul><li>可以在自己定义的地方报出异常停止程序；</li><li>而不是在错误的地方报出异常停止程序</li></ul><p>可以是自己书写的程序自己监测错误，而不需要最后一道防线JVM来处理错误</p><p>如果没有使用的话，报错的时候只能是JVM虚拟机来默认的报错处理(立即在报错位置停止程序的运行，报出异常原因)</p><h4 id="什么是Throws"><a class="header-anchor" href="#什么是Throws">¶</a>什么是Throws</h4><p><code>throws</code>是一个java的关键字，通常被应用在声明方法的时候，用来指定可能抛出的异常。声明之后，可以让Java的编译器对这个java文件进行正常的编译class文件(演示一下)，这也是平常我们所说的<strong>自动抛出</strong>的动作。一旦运行class文件期间出现错误，JVM虚拟机就会检测错误，停止程序的运行，并报出异常信息</p><h4 id="两者的区别"><a class="header-anchor" href="#两者的区别">¶</a>两者的区别</h4><ul><li>位置：throws放在方法声明的后面，表示报出异常，由该方法的调用者来处理；throw作用在方法内部，后面跟着的是异常的对象</li><li>功能：<br>throws用来声明方法在运行过程中可能出现的异常，以便调用者根据不同的异常类型预先定义不同的处理方式；<br>throw用来抛出封装了异常信息的对象，程序在执行到throw时后续的代码将不在执行，而是跳转到调用者，并将异常信息抛给调用者，也就是说，throw后面百度语句将无法被执行(finally语句块除外)</li></ul><h3 id="由以上总结出：Java处理异常的方式："><a class="header-anchor" href="#由以上总结出：Java处理异常的方式：">¶</a>由以上总结出：Java处理异常的方式：</h3><ul><li>方式一：try-catch-finally</li><li>方式二：throws+异常类型</li></ul><h2 id="🔧IO流"><a class="header-anchor" href="#🔧IO流">¶</a>🔧IO流</h2><h3 id="什么是IO流"><a class="header-anchor" href="#什么是IO流">¶</a>什么是IO流</h3><p>这里引用百度的回答：</p><blockquote><p>流是一种抽象概念，它代表了数据的无结构化传递。按照流的方式进行输入输出，数据被当成无结构的字节序或字符序列。从流中取得数据的操作称为提取操作，而向流中添加数据的操作称为插入操作。用来进行输入输出操作的流就称为IO流。换句话说，IO流就是以流的方式进行输入输出</p></blockquote><p>简而言之就是：你的程序和系统之间读写文件的操作就是IO操作，和系统之间读写用的东西就是IO流</p><p>所以，Java IO流就是Java程序和操作系统之间通信用的方法</p><p>这里出于篇幅，时间原因，只简单介绍Java IO流中的<strong>字节流</strong>和<strong>字符流</strong>，其他流，像<strong>NIO</strong>，<strong>AIO</strong>，<strong>BIO</strong>这些，各位卷王有余力的话可以自己去学习。</p><h3 id="字节流和字符流的区别"><a class="header-anchor" href="#字节流和字符流的区别">¶</a>字节流和字符流的区别</h3><p>字节流和字符流操作的本质区别只有一个：</p><blockquote><p>字节流是原生的操作，字符流是处理后的操作</p></blockquote><p>搓个图，字节流在操作的时候不会用到缓冲区，也就是不会用到内存，直接操作文件本身；</p><p>而字符流在操作的时候使勇了缓冲区，通过缓冲区再操作文件：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122081522641.png" alt="image-20221122081522641" style="zoom: 200%;" align="left" /><p>那么为什么会有字符流而不直接使用字节流呢？非得搞个字符流出来。</p><p>我的理解是，字节流处理机多个字节表示的东西的时候，有可能会出现乱码的问题</p><p>比如说汉字，用字节流读取的时候有可能因为以为字节没有读到就变成了乱码，字符流呢，就完美的解决了这个问题。</p><p>这样理解，<code>字节流+编码表=字符路</code>因为有了编码表，多以可以确定这个汉字有多少个字节，这样字节流就可以根据位数准确的写汉字了</p><h3 id="字节流"><a class="header-anchor" href="#字节流">¶</a>字节流</h3><p>字节流顾名思义。就是通过字节直接操作字符，更为的底层</p><p>字节流最基础的两个类就是<code>InputStream</code>和<code>OutputStream</code>。根据这两个派生而来类都含有<code>read()</code>和<code>write()</code>的基本方法，用来读写单个字节或者字节数组</p><ul><li>InputStream类是一个抽象类 ,是所有字节输入流类的父类。</li><li>OutputStream类是一个抽象类，是所有字节输出流的父类</li></ul><p>他俩常见的子类有：</p><table><thead><tr><th>InputStream的常见子类</th><th>描述</th></tr></thead><tbody><tr><td>FileInputStream</td><td>用于从文件中读取信息</td></tr><tr><td>ByteArrayInputStream</td><td>字节数组输入流</td></tr><tr><td>ObjectInputStream</td><td>序列化时使用 一般和ObjectOutputStream一起使用</td></tr><tr><td>FilterInputStream</td><td>过滤输入流,为基础的输入流提供一些额外的操作</td></tr></tbody></table><table><thead><tr><th>OutputStream的常见子类</th><th>描述</th></tr></thead><tbody><tr><td>FileOutPutStream</td><td>文件输出流对文件进行操作</td></tr><tr><td>ByteArrayOutputStream</td><td>字节数组输出流</td></tr><tr><td>ObjectOutputStream</td><td>序列化时使用 一般和OjbectInputStream一起使用</td></tr><tr><td>FilterOutputStream</td><td>过滤输出流,为基础的输出流提供一些额外的操作</td></tr></tbody></table><p>举个栗子，我们往F盘下面hello.txt里面输入“hello world”，再将他读出来，在程序里面输出</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Courseware-Backend-Java-2022</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 字节流Test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-11-22 09:02</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Byte</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">//根据文件夹的名字来创建对象</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;F:\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//往文件里面一个字节一个字节的写入数据</span></span><br><span class="line">        fileOutputStream.write((<span class="type">int</span>)<span class="string">&#x27;h&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="type">int</span>)<span class="string">&#x27;e&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="type">int</span>)<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="type">int</span>)<span class="string">&#x27;l&#x27;</span>);</span><br><span class="line">        fileOutputStream.write((<span class="type">int</span>)<span class="string">&#x27;o&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//入文件里面一个字节数组的写入文件</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot; world&quot;</span>;</span><br><span class="line">        fileOutputStream.write(s.getBytes());</span><br><span class="line">        fileOutputStream.close();</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//传文件夹的名字来创建对象</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:\\hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//一个字节一个字节的读出数据</span></span><br><span class="line">        <span class="keyword">while</span>((len = fileInputStream.read()) != -<span class="number">1</span>)&#123;</span><br><span class="line">            System.out.println((<span class="type">char</span>)len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">        <span class="comment">//通过File对象来创建对象</span></span><br><span class="line">        fileInputStream = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:\\hello.txt&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="type">byte</span> []bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">//一个字节数组的读出数据</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; len ; i++)&#123;</span><br><span class="line">                System.out.print((<span class="type">char</span>) bytes[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭流</span></span><br><span class="line">        fileInputStream.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>再来个栗子，复制某个位置的图片，到指定位置下。平常我们都是用CV来复制粘贴，这次我们用程序来操作：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.FileOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Courseware-Backend-Java-2022</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 复制图片Test</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-11-22 09:05</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyPhoto</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="comment">// 1.创建流对象</span></span><br><span class="line">        <span class="comment">// 1.1 指定数据源</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;F:\\元帅的艺术.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">// 1.2 指定目的地</span></span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;test_copy.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.读写数据</span></span><br><span class="line">        <span class="comment">// 2.1 定义数组</span></span><br><span class="line">        <span class="type">byte</span>[] b = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="comment">// 2.2 定义长度</span></span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="comment">// 2.3 循环读取</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(b))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">// 2.4 写出数据</span></span><br><span class="line">            fos.write(b, <span class="number">0</span> , len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 3.关闭资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>基本上我们平常如果有使用到IO流的地方，常用的方法就上面栗子里面使用到的几个，详细的方法各位可以参照官方文档，或者CSDN上博主们总结的。这里就不造赘述了。</p><p>除了<code>FileInputStream</code>剩下3个<code>InputStream</code>的子类，平常开发中不经常用到，有兴趣的可以自行了解。</p><h2 id="📐泛型T-R"><a class="header-anchor" href="#📐泛型T-R">¶</a>📐泛型T\R</h2><h3 id="泛型的解释"><a class="header-anchor" href="#泛型的解释">¶</a>泛型的解释</h3><blockquote><p>泛型属于一种程序语言的标准和规范，或者也可以说为特性</p></blockquote><p>通俗解释就是：泛型其实就是我们参数化类型，就比如在定义List的时候，我们就可以写作<code>List&lt;String&gt;</code>这样我们就在编码阶段，将List存放的类型定义好。这样的话，我们在操作List的时候就可以通过泛型对我们集合内的值进行规范和约束，如果我们传入非法的类型时程序在编译阶段就能帮我们找出问题，就不会出现隐形的异常。</p><p>就比如下面的梨子，如果我们不通过泛型进行约束，直接开写，在运行代码的时候我们都是不知道会出错的，只有当程序run到这句话的时候才会抛出异常：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">list.add(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">list.add(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;执行到第 &quot;</span> + (i+<span class="number">1</span>) + <span class="string">&quot; 次循环。&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) list.get(i);</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>run过后，执行结果：</p><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">执行到第 1 次循环。</span><br><span class="line">abc</span><br><span class="line">执行到第 2 次循环。</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</span><br><span class="line">    at com.zhj.business.test.Test01.main(Test01.java:18)</span><br></pre></td></tr></table></figure><p>可以看出程完整的完成了第一次for</p><p>但是在第二次for的时候触发了类转换异常<code>ClassCastException</code></p><p>当项目很大的时候，像这样的细节是很容易被忽略的，所以我们通过泛型，约束类型，这样我们在提供数据保存是对应类型即可，不需要进行强转，就不会出现上述问题</p><h3 id="泛型的用法"><a class="header-anchor" href="#泛型的用法">¶</a>泛型的用法</h3><p>泛型一共有三种用法，分别为：</p><ul><li><p>泛型类</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: Courseware-Backend-Java-2022</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>: 返回结果类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-11-22 09:32</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Result</span>&lt;T&gt; <span class="keyword">implements</span> <span class="title class_">Serializable</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 状态码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> T data;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Result</span><span class="params">(Integer code, String msg, T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Integer <span class="title function_">getCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCode</span><span class="params">(Integer code)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMsg</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMsg</span><span class="params">(String msg)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getData</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setData</span><span class="params">(T data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，我们就可以定义一个，由我们自己    定义类型的数据域   的对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Result&lt;String&gt; r1 = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">r1.setData(<span class="string">&quot;111&quot;</span>);</span><br><span class="line"></span><br><span class="line">Result&lt;Integer&gt; r2 = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">r2.setData(<span class="number">111</span>);</span><br><span class="line"></span><br><span class="line">Result&lt;Boolean&gt; r3 = <span class="keyword">new</span> <span class="title class_">Result</span>&lt;&gt;();</span><br><span class="line">r3.setData(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure></li><li><p>泛型接口</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">List</span>&lt;E&gt; <span class="keyword">extends</span> <span class="title class_">Collection</span>&lt;E&gt; &#123;</span><br><span class="line">......</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure></li><li><p>泛型方法<br>List接口中的<code>toArray()</code>方法就是经典的泛型方法</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> T[] 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T[] 返回值为T[]类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public与返回值中间的&lt;T&gt;，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> *     5）必须在权限声明public与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> size();</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="keyword">return</span> Arrays.copyOf(<span class="built_in">this</span>.a, size,(Class&lt;? <span class="keyword">extends</span> <span class="title class_">T</span>[]&gt;) a.getClass());</span><br><span class="line">    System.arraycopy(<span class="built_in">this</span>.a, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>使用泛型方法的时候，通常不必指明类型参数，因为编译器会为我们找出具体的类型。</p><p>这称为类型参数推断<code>(type argument inference)</code>类型推断只对赋值操作有效，其他时候并不起作用</p><blockquote><p>关于泛型数组：在Java中，在running时在数据中推送任何不兼容的类型将抛出<code>ArrayStoreException</code></p><p>这意味着数据在running时保留期类型信息，而泛型在running时使用类型擦除，由于上述冲突，不允许在Java中实例化泛型数组</p></blockquote><h3 id="类型通配"><a class="header-anchor" href="#类型通配">¶</a>类型通配</h3><p>在泛型代码中，<code>?</code>通配符表示位置类型。例如<code>List&lt;?&gt;</code>，在逻辑上是List、List等所有List&lt;类型实参&gt;的父类</p><h4 id="无界通配符"><a class="header-anchor" href="#无界通配符">¶</a>无界通配符</h4><p><code>&lt;?&gt;</code>叫做无界通配符，意味着对类型实参没有任何限制</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;?&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Long&gt;();  </span><br><span class="line">ArrayList&lt;?&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();  </span><br><span class="line">ArrayList&lt;?&gt;  list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Employee&gt;();  </span><br></pre></td></tr></table></figure><p>可以使用无界通配符来缩小类型参数的类型范围</p><h4 id="上界通配符和下界通配符"><a class="header-anchor" href="#上界通配符和下界通配符">¶</a>上界通配符和下界通配符</h4><p>这里就不讲上下界通配符了，一是平常开发的时候一般来说不用我们手写通配符；二是确实有点难以理解，各位如果有余力的可以自己下来钻研 ——&gt; <a href="https://juejin.cn/post/7126717331522191368">这里</a></p><h3 id="泛型不被允许的那些事儿"><a class="header-anchor" href="#泛型不被允许的那些事儿">¶</a>泛型不被允许的那些事儿</h3><ul><li><p><strong>不能在类中定义泛型参数化的静态属性。</strong><br>任何这样做的尝试都会产生编译时错误：<code>Cannot make a static reference to the non-static type T.</code><br>比如像这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsExample</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> T member; <span class="comment">//编译不通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="C:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20221122191241756.png" align="left" alt="image-20221122191241756" style="zoom:150%;" /></li><li><p><strong>不能创建类型参数的实例。</strong><br>任何创建T实例的尝试都将失败<br>抛出编译错误：<code>Cannot instantiate the type T</code><br>比如像这样</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsExample</span>&lt;T&gt;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">GenericsExample</span><span class="params">()</span>&#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="title class_">T</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122191414631.png" align="left" alt="image-20221122191414631" style="zoom:150%;" /></li><li><p><strong>泛型的类型参数不能是基础类型</strong><br>泛型的类型参数不能使用<code>int</code> <code>double</code>这样的基本类型，必须是引用类型，如果需要，请使用起对应的包装类型<code>Integer</code> <code>Double</code>等<br>比如这样：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;<span class="type">int</span>&gt; list1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();    <span class="comment">// 不允许</span></span><br><span class="line">List&lt;Integer&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();<span class="comment">//可以</span></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122191324448.png" align="left" alt="image-20221122191324448" style="zoom:150%;" /></li><li><p><strong>不能创建泛型的异常类</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericException</span>&lt;T&gt; <span class="keyword">extends</span> <span class="title class_">Exception</span> &#123;&#125;</span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122191100836.png" align="left" alt="image-20221122191100836" style="zoom: 150%;" /></li></ul><h2 id="🎰线程"><a class="header-anchor" href="#🎰线程">¶</a>🎰线程</h2><p><strong>什么是线程？</strong></p><blockquote><p>线程是程序执行的时候最小单位，他是进程的一个执行流，是CPU调度和分配资源的基本单位</p></blockquote><p>一个进程可以有很多个线程组成，线程之间共享进程的所有资源，每个线程有自己的堆栈和局部变量</p><p>线程有CPU独立调度执行，在多CPU环境下就允许多个线程同时运行。同样多线程也可以实现并发操作，每个请求分配一个线程来处理</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122195404294.png" align="left" alt="image-20221122195356392" style="zoom:80%;" /><p><strong>什么是进程？</strong></p><blockquote><p>进程是资源(CPU、内存等等)分配的最小，或者说基本单位，他是程序执行时的一个实例</p></blockquote><p>程序run的时候系统就会创建一个进程，并为他分配资源，然后吧这个进程放到进程就绪队列，进程调度器选中它的时候，就会为他分配CPU时间，程序真正开始run</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221122195356392.png" align="left" alt="image-20221122195356392" style="zoom:80%;" /><p><strong>线程和进程的区别</strong></p><p>根据上面的一些介绍，我们知道的是进程和线程的概念是在建立在操作系统层面上的</p><p>进程是程序的一次执行，进程是资源（CPU、内存等）分配的基本单位，它是程序执行时的一个实例。</p><p>线程是 CPU 的基本调度单位，是进程的一个执行流。</p><p>在 Java 程序中体现在 main 方法的执行是一个进程，我们在 main 方法中通过 Thread 类来创建多个线程进而运行他们，也就达到多线程的目的。</p><h3 id="创建线程的几种方式"><a class="header-anchor" href="#创建线程的几种方式">¶</a>创建线程的几种方式</h3><p>那么我们来如何实现多线程呢：</p><ul><li>继承Thread对象</li><li>重写run方法</li><li>创建线程对象</li><li>调用start()方法</li></ul><p>这里我们介绍4种方式来创建线程</p><h4 id="实现Runable接口"><a class="header-anchor" href="#实现Runable接口">¶</a>实现Runable接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName()+<span class="string">&quot;线程跑起来了!!!&quot;</span>);        </span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="Callable-Future-Task方法"><a class="header-anchor" href="#Callable-Future-Task方法">¶</a>Callable+Future Task方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">       <span class="built_in">this</span>.n = n;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//重写call方法(任务方法)(求n的加和)</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">       <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">           sum += i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是：&quot;</span> + sum;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a class="header-anchor" href="#匿名内部类">¶</a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">new</span> <span class="title class_">Thread</span>(</span><br><span class="line">     () -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">).start();</span><br></pre></td></tr></table></figure><p>我们来对比一下这3种方式</p><table><thead><tr><th style="text-align:left">方式</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:left">继承Thread类</td><td style="text-align:center">编程比较简单</td><td style="text-align:center">扩展性差</td></tr><tr><td style="text-align:left">实现Runnable接口</td><td style="text-align:center">扩展性强</td><td style="text-align:center">相对复杂，没有返回结果</td></tr><tr><td style="text-align:left">实现Callable+FutureTask接口</td><td style="text-align:center">扩展性强，可得到结果</td><td style="text-align:center">编程复杂</td></tr></tbody></table><p>细心的你肯定已经发现了，明明上面说的是《四种方式》，但这里只讲了三种，诶~你别急</p><p>除了继承Thread类，实现Runnable接口，实现Callable接口之外，最后一种创建线程的方式就是用线程池的方式，创建管理线程。</p><h3 id="线程池"><a class="header-anchor" href="#线程池">¶</a>线程池</h3><blockquote><ul><li>线程池里固定依一些线程，并重复利用这些线程</li><li>有利于系统进程，防止资源的耗尽</li></ul></blockquote><p>​<strong>如何得到线程池对象：</strong></p><blockquote><ul><li>使用**ExecutorService（接口）**的实现类：<strong>TreadPollExecutor</strong> 自创建一个线程池对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">ExecutorService</span> <span class="variable">pools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">            <span class="number">3</span>,<span class="comment">//核心线程个数 corePoolSize</span></span><br><span class="line">            <span class="number">5</span>,<span class="comment">//最大线程量 maximumPoolSize</span></span><br><span class="line">            <span class="number">8</span>,<span class="comment">//最大时间 keepAliveTime</span></span><br><span class="line">            TimeUnit.SECONDS,<span class="comment">//</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">6</span>),<span class="comment">//任务队列</span></span><br><span class="line">            Executors.defaultThreadFactory(),<span class="comment">//线程工厂</span></span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="comment">//任务拒绝策略</span></span><br></pre></td></tr></table></figure><ul><li>这七个参数便是</li></ul><ol><li>int <code>corePoolSize</code>：<strong>核心线程数</strong></li><li>int <code>maximumPoolSize</code>：<strong>最大创建线程数</strong></li><li>long <code>keepAliveTime</code>：<strong>存活时间</strong></li><li>TimeUnit <code>unit</code>：<strong>Time类管理工具</strong></li><li>BlockingQueue<Runnable> <code>workQueue</code>：指定阻塞队列</li><li>ThreadFactory <code>threadFactory</code>：<strong>线程工厂</strong></li><li>RejectedExecutionHandler <code>handler</code>：<strong>拒绝策略</strong></li></ol><ul><li>使用 <strong>Executor</strong> （线程池对象的工具类）调用方法返回不同特点的线程池对象</li></ul></blockquote><h4 id="处理Runnable任务"><a class="header-anchor" href="#处理Runnable任务">¶</a>处理Runnable任务</h4><blockquote><p><strong>如何丢入线程池(如何处理Runnable任务)：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">// 使用静态变量记住一个线程池对象</span></span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, TimeUnit.SECONDS,</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">2</span>),</span><br><span class="line">                                  Executors.defaultThreadFactory(),</span><br><span class="line">                                  <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="type">ExecutorService</span> <span class="variable">pools</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(</span><br><span class="line">          <span class="number">3</span>,<span class="comment">//核心线程个数 corePoolSize</span></span><br><span class="line">          <span class="number">5</span>,<span class="comment">//最大线程量 maximumPoolSize</span></span><br><span class="line">          <span class="number">8</span>,<span class="comment">//最大时间 keepAliveTime</span></span><br><span class="line">          TimeUnit.SECONDS,<span class="comment">//</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">6</span>),<span class="comment">//任务队列</span></span><br><span class="line">          Executors.defaultThreadFactory(),<span class="comment">//线程工厂</span></span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());<span class="comment">//任务拒绝策略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pool 的 execute 方法</span></span><br><span class="line">  pools.execute(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread() + <span class="string">&quot;起飞！！！&quot;</span> + <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  pools.execute(() -&gt; &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">          System.out.println(Thread.currentThread() + <span class="string">&quot;GGGGGG&quot;</span> + <span class="string">&quot;第&quot;</span> + i + <span class="string">&quot;次&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  pools.shutdown();</span><br></pre></td></tr></table></figure></blockquote><blockquote><p><strong>如何关闭线程池：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="comment">//(开发中一般不会使用)。</span></span><br><span class="line">&gt;pool.shutdownNow();<span class="comment">//立刻关闭，即使任务没有完成，丢失任务的。</span></span><br><span class="line">&gt;pool.shutdowm();<span class="comment">//会等待全部任务执行完毕之后再关闭</span></span><br></pre></td></tr></table></figure></blockquote><p>为什么大型并发系统环境中使用 <strong>Executors</strong> 如果不注意可能会出现系统风险捏？？？</p><p>这个就作为作业，留给各位啦</p><h3 id="线程安全问题"><a class="header-anchor" href="#线程安全问题">¶</a>线程安全问题</h3><p>什么是线程安全问题：</p><blockquote><p>多个线程同时共共享一个资源，并对他进行修改</p></blockquote><p>有一天，老师布置了这样一个问题：</p><p>使用两个线程将变量<code>count</code>自增<code>10</code>万次，每个线程承担<code>5</code>万次的自增任务，</p><p>变量<code>count</code>的初始值为<code>0</code>。</p><p>这个问题很简单，最终的结果我们也能够口算出来，答案就是<code>10</code>万。<br>小明同学做事非常迅速，很快就写出了下面的一段代码：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;<span class="comment">//定义一个资源类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        ++<span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">CNT</span> <span class="operator">=</span> <span class="number">50000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Counter</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Counter</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; CNT; i++) &#123;</span><br><span class="line">                counter.increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; CNT; j++) &#123;</span><br><span class="line">                counter.increase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        thread1.start();</span><br><span class="line">        thread2.start();</span><br><span class="line"></span><br><span class="line">        thread1.join();</span><br><span class="line">        thread2.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(counter.getCount());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行的结果比<code>10</code>万要小，你可以试着运行该程序你会发现每次运行的结果都不一样，但绝大部分情况，结果都会比预期的值要小，</p><p>上面我们使用多线程运行了一个程序，将一个变量值为0的变量自增10万次，但是最终实际结果比我们预期结果要小，</p><p><strong>原因就是线程调度的顺序是随机的，造成线程间自增的指令集交叉，导致运行时出现两次自增但值只自增一次的情况，所以得到的结果会偏小。</strong></p><h4 id="解决方法-线程同步"><a class="header-anchor" href="#解决方法-线程同步">¶</a>解决方法 -&gt; 线程同步</h4><p>线程同步的思想：</p><blockquote><p>加锁：让多个线程依次访问同一个资源</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (someObject)&#123;</span><br><span class="line">  <span class="comment">//someObject 为 锁对象 -&gt; 唯一</span></span><br><span class="line">  <span class="comment">//此处的代码只有占有了someObject后才可以执行</span></span><br><span class="line">  <span class="comment">//行为</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">    <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">        ++<span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>锁对象为 <strong>任意的</strong> 唯一对象到底好不好呢：</p><ul><li>不好，<strong>影响其线程的进行</strong></li></ul><p>规范上：</p><ul><li>建议使用<strong>共享资源</strong>作为锁对象：</li><li>对于实例方法建议使用<strong>this</strong>作为锁对象</li><li>对于静态方法建议使用**字节码（类名：class）**对象作为锁对象</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="built_in">this</span>)&#123;<span class="comment">//这里就直接用this关键字</span></span><br><span class="line">          ++<span class="built_in">this</span>.count;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">  &#125;</span><br><span class="line">&gt;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h4 id="同步方法"><a class="header-anchor" href="#同步方法">¶</a>同步方法</h4><blockquote><p>直接在返回值类型(int void long···)前面 +  <strong>synchronized</strong>就可以了</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;<span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line">&gt;<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line"> <span class="keyword">synchronized</span> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increase</span><span class="params">()</span> &#123;</span><br><span class="line">     ++count;</span><br><span class="line">&gt;&#125;</span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCount</span><span class="params">()</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.count;</span><br><span class="line">   &#125;</span><br><span class="line">&gt;&#125;</span><br></pre></td></tr></table></figure><p>如果一个类，其<strong>方法都是有synchronized修饰的</strong>，那么该类就叫做<strong>线程安全的类</strong></p><p>同一时间，只有一个线程能够进入 <strong>这种类的一个实例</strong> 的去修改数据，进而保证了这个实例中的数据的安全(不会同时被多线程修改而变成脏数据)</p></blockquote><p>常见的用法差不多就是这些，对于线程加锁（线程拿锁），如果两个线程同时拿一个对象的锁，就会产生锁竞争，两个线程同时拿两个不同对象的锁不会产生锁竞争。</p><p>对于<code>synchronized</code>这个关键字，它的英文意思是同步，但是同步在计算机中是存在多种意思的，比如在多线程中，这里同步的意思是“互斥”；而在IO或网络编程中同步指的是“异步”，与多线程没有半点的关系。</p><h4 id="🌟synchronized的工作原理"><a class="header-anchor" href="#🌟synchronized的工作原理">¶</a>🌟synchronized的工作原理</h4><ol><li>获取互斥锁<code>lock</code></li><li>从主内存拷贝变量到工作的内存</li><li>执行代码</li><li>将更改后面的共享变量的值刷新到主内存</li><li>释放互斥锁<code>unlock</code></li></ol><p><code>synchronized</code>同步块在对同一条线程来说是可重入的，不会出现自己吧自己锁死的问题   ——   死锁问题，这个以后再做介绍</p><p>综上：<code>synchronized</code>关键字加锁有如下性质：互斥性，刷新内存性，可重入性</p><p>至于后面的用<code>Lock锁</code>的方式，我们留到后面的JUC…</p><h2 id="📰反射"><a class="header-anchor" href="#📰反射">¶</a>📰反射</h2><h3 id="反射概述"><a class="header-anchor" href="#反射概述">¶</a>反射概述</h3><blockquote><p>Java程序在running状态的时候，</p><p>对于任何一个类，我们都能够知道这个类的所有属性和方法；</p><p>对于任何一个对象，都能够调用它的任何属性和方法，</p><p>这种动态获取信息；以及动态调用对象方法的功能，被我们称之为Java语言的反射机制</p></blockquote><p>接下来说说怎么使用反射</p><h3 id="反射的使用"><a class="header-anchor" href="#反射的使用">¶</a>反射的使用</h3><p>首先来介绍一下相关的<strong>API</strong></p><ul><li><p><strong>获取Class对象：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class.forName(<span class="string">&quot;全类名&quot;</span>);</span><br><span class="line">类名.class;</span><br><span class="line">对象.getClass();</span><br></pre></td></tr></table></figure></li></ul><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221121223935141.png" alt="image-20221121223935141" style="zoom: 150%;" align="left" /><ul><li><p><strong>反射获取构造方法：</strong><br>Class类中用于获取构造方法的方法</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>Constructor&lt;?&gt;[] getConstructors()</td><td>返回所有公共构造方法对象的数组</td></tr><tr><td>Constructor&lt;?&gt;[] getDeclaredConstructors()</td><td>返回所有构造方法对象的数组</td></tr><tr><td>Constructor<T> getConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回单个公共构造方法对象</td></tr><tr><td>Constructor<T> getDeclaredConstructor(Class&lt;?&gt;… parameterTypes)</td><td>返回单个构造方法对象</td></tr></tbody></table><p>Constructor类中用于创建对象的方法</p><table><thead><tr><th>方法名</th><th>描述</th></tr></thead><tbody><tr><td>T newInstance(Object… initargs)</td><td>根据指定的构造方法创建对象</td></tr><tr><td>void setAccessible(boolean flag)</td><td>设置为true,表示取消访问检查</td></tr></tbody></table></li><li><p><strong>反射获取成员变量</strong></p><table><thead><tr><th>方法名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>Field[] getFields()</td><td style="text-align:left">返回所有公共成员变量对象的数组</td></tr><tr><td>Field[] getDeclaredFields()</td><td style="text-align:left">返回所有成员变量对象的数组</td></tr><tr><td>Field getField(String name)</td><td style="text-align:left">返回单个公共成员变量对象</td></tr><tr><td>Field getDeclaredField(String name)</td><td style="text-align:left">返回单个成员变量对象</td></tr><tr><td>void set(Object obj, Object value)</td><td style="text-align:left">给指定对象的成员变量赋值</td></tr><tr><td>Object get(Object obj)</td><td style="text-align:left">返回指定对象的Field的值</td></tr></tbody></table></li><li><p><strong>反射获取成员方法并运行</strong><br><code>Object invoke(Object obj,Object ... args)</code></p></li></ul><p>看完上面的API过后，可能大家头都大了</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221121213629013.png" alt="image-20221121213629013" style="zoom:80%;" align="left" /><p>接下来说说该如何做吧：</p><ol><li><p>得到Class对象：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态方法：forName(权限名：包名 + 类名 );</span></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line">Class&lt;?&gt; class1 = Class.forName(<span class="string">&quot;entity.Student&quot;</span>);</span><br><span class="line"><span class="comment">//方法2</span></span><br><span class="line"><span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">class2</span> <span class="operator">=</span> student.getClass();</span><br><span class="line"><span class="comment">//方法3</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class3</span> <span class="operator">=</span> Student.class;</span><br></pre></td></tr></table></figure></li><li><p>获取Constructor对象：</p><ul><li><p>所有构造器</p></li><li><p>有参构造器</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;entity.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">System.out.println(constructor.getName() +<span class="comment">//提取构造器名称</span></span><br><span class="line">        <span class="string">&quot;===&gt;&quot;</span> +</span><br><span class="line">        constructor.getParameterCount());<span class="comment">//提取构造器参数个数</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建对象类：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;entity.Student&quot;</span>);</span><br><span class="line">Constructor&lt;?&gt; constructor = class1.getDeclaredConstructor(String.class, <span class="type">int</span>.class);</span><br><span class="line">        System.out.println(constructor.getName() +<span class="comment">//提取构造器名称</span></span><br><span class="line">                <span class="string">&quot;===&gt;&quot;</span> +</span><br><span class="line">                constructor.getParameterCount());<span class="comment">//提取构造器参数个数</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;yxy;&quot;</span>,<span class="number">19</span>);</span><br></pre></td></tr></table></figure></li><li><p>成员变量对象</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;entity.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;yxyl&quot;</span>,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取字段对象</span></span><br><span class="line"><span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> class1.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">field.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="comment">//获取字段值</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> field.get(o);</span><br><span class="line">System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line"><span class="comment">//设置字段值</span></span><br><span class="line">field.set(o,<span class="string">&quot;杨晨&quot;</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">overwriteValue</span> <span class="operator">=</span> field.get(o);</span><br><span class="line">System.out.println(<span class="string">&quot;overwriteValue = &quot;</span> + overwriteValue);</span><br></pre></td></tr></table></figure></li><li><p>成员方法提取</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里给Student类添加一个成员方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">...</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>&#123;</span><br><span class="line">        System.out.println(<span class="built_in">this</span>.name+<span class="string">&quot;吃了&quot;</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法1</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">class1</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;entity.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取对象</span></span><br><span class="line"><span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> constructor.newInstance(<span class="string">&quot;yxyl&quot;</span>,<span class="number">19</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> class1.getDeclaredMethod(<span class="string">&quot;eat&quot;</span>, String.class);</span><br><span class="line"></span><br><span class="line">method.invoke(o, <span class="string">&quot;学校的逆天饭菜&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="反射的作用"><a class="header-anchor" href="#反射的作用">¶</a>反射的作用</h3><p>说了这么多，敲了这么多，为什么要有反射这个东西呢，明明我们平常直接new，就可以得到一个对象</p><blockquote><p>对，没对象，就new一个吧</p></blockquote><p>原因是：通过反射可以是程序代码访问装载到JVM中的类的内部信息，以此来：</p><ul><li>获取已装载类的成员变量信息</li><li>获取已装载类的方法</li><li>获取一装载类的构造方法信息</li></ul><p>这里就以我目前做的一个项目一小块来说吧，具体的就不在课件里面展示，到时候上课的时候说。</p><hr><p>但是万物都有两面性，</p><blockquote><p>毕竟new出来的对象始终看得到，但是摸不着，反射也当然是</p></blockquote><p>其最突出的便是其性能问题：</p><p>是用反射基本上是一种解释操作，用于字段和方法接入时要远慢于直接代码(意思就是，通过反射得到一个对象，远远不如直接new)。因此，Java反射机制主要是应用在对灵活性和扩展性要求很高的系统框架上，基本程序不建议使用。</p><p>使用反射会模糊程序内部逻辑</p><p>程序人员希望在源代码中看到程序的逻辑，而反射等技术绕过了源代码的技术，因而会带来维护问题，反射代码比相应的直接代码更复杂</p><p>至于反射的代理模式，各位卷王请便 ——&gt; <a href="https://blog.csdn.net/weixin_43438052/article/details/117292687?ops_request_misc=%7B%22request%5Fid%22%3A%22164172376316781683959885%22%2C%22scm%22%3A%2220140713.130102334.pc%5Fall.%22%7D&amp;request_id=164172376316781683959885&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-14-117292687.pc_search_insert_ulrmf&amp;utm_term=Java%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E9%87%8D%E8%A6%81%E5%90%97&amp;spm=1018.2226.3001.4187">这里</a></p><h2 id="💬网络编程"><a class="header-anchor" href="#💬网络编程">¶</a>💬网络编程</h2><p>这里出于时间原因和篇幅原因，就不讲网络编程的相关知识，等后面讲<strong>计网知识</strong>的时候会详细讲</p><p><strong>…</strong></p><h1>Mysql</h1><h1>Navicat</h1>]]></content>
      
      
      <categories>
          
          <category> 蓝山 </category>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 课件 </tag>
            
            <tag> 蓝山 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本地虚拟机搭建k8s集群</title>
      <link href="/2022/11/19/%E6%9C%AC%E5%9C%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/"/>
      <url>/2022/11/19/%E6%9C%AC%E5%9C%B0%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%90%AD%E5%BB%BAk8s%E9%9B%86%E7%BE%A4/</url>
      
        <content type="html"><![CDATA[<h1>本地虚拟机搭建k8s集群</h1><p>为什么是虚拟机呢</p><ul><li>没钱</li><li>没钱</li><li>…</li></ul><p>其实就是没钱买aliyun下同网段的机器，目前只有一个马ht机器，和阿里机器，没有在一个网段上，而虚拟机正好可以很简单直接的解决我的问题</p><p>开始之前，部署k8s集群的机器要满足：</p><ul><li>一台或多台机器</li><li>2GB或者更多的RAM，2个或者更多CUP，30G以上的ROM</li><li>集群中所有机器之前可以网络互通</li><li>可以访问外网，需要拉取镜像</li><li>禁止swap分区</li></ul><h2 id="准备好Linux"><a class="header-anchor" href="#准备好Linux">¶</a>准备好Linux</h2><h3 id="首先：得到一-多-份双网卡Centos"><a class="header-anchor" href="#首先：得到一-多-份双网卡Centos">¶</a>首先：得到一(多)份双网卡Centos</h3><p>创建虚拟机的过程就不说了</p><p>这里就直接说配置静态id</p><h4 id="查看本地Vmnet8"><a class="header-anchor" href="#查看本地Vmnet8">¶</a>查看本地Vmnet8</h4><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221119095421318.png" alt="image-20221119095421318" style="zoom:75%;" align="left" /><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221119095700546.png" alt="image-20221119095700546" align="left"   /><p>偶对了，在创建虚拟机的时候，选择网卡：Vmnet8，这样才能联通网</p><h4 id="接着修改ip地址"><a class="header-anchor" href="#接着修改ip地址">¶</a>接着修改ip地址</h4><p><strong>进入存放修改ip地址的目录：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /etc/sysconfig/network-scripts/</span><br></pre></td></tr></table></figure><p><strong>修改文件：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ifcfg-ens33</span><br></pre></td></tr></table></figure><ol><li><p>修改BOOTPROTO=static</p></li><li><p>在下面添加内容：IP地址、子网掩码、网关、dns服务器</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">IPADDR=192.168.75.100 ——&gt; 前面三个和网关一样</span><br><span class="line">GATEWAY=192.168.75.2 ——&gt; 上面提到的Gateway</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">DNS1=218.4.4.4</span><br><span class="line">DNS2=8.8.8.8</span><br></pre></td></tr></table></figure></li></ol><p><strong>重启网络服务</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl restart network</span><br></pre></td></tr></table></figure><h3 id="再配置免密登录-远程连接"><a class="header-anchor" href="#再配置免密登录-远程连接">¶</a>再配置免密登录+远程连接</h3><p>先鸽…</p><p>2022-11-19 12:10:31</p><h2 id="开始搭建集群"><a class="header-anchor" href="#开始搭建集群">¶</a>开始搭建集群</h2><h3 id="安装docker环境"><a class="header-anchor" href="#安装docker环境">¶</a>安装docker环境</h3><ol><li><p>移除以前docker的相关包</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br></pre></td></tr></table></figure></li><li><p>配置yum源</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line">sudo yum-config-manager \</span><br><span class="line">--add-repo \</span><br><span class="line">http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li><li><p>安装docker(这里安装的是20.10.7版本的)</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">以下是在安装k8s的时候使用</span></span><br><span class="line">yum install -y docker-ce-20.10.7 docker-ce-cli-20.10.7  containerd.io-1.4.6</span><br></pre></td></tr></table></figure></li><li><p>启动</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker --now</span><br></pre></td></tr></table></figure></li><li><p>配置加速</p><blockquote><p>这里额外添加了docker的生产环境核心配置cgroup</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://82m9ar63.mirror.aliyuncs.com&quot;],</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure></li><li><p>docker环境成功，可以试一试命令了…</p></li></ol><h3 id="安装kubectl、kubeadm、kubelet"><a class="header-anchor" href="#安装kubectl、kubeadm、kubelet">¶</a>安装kubectl、kubeadm、kubelet</h3><h4 id="基础环境"><a class="header-anchor" href="#基础环境">¶</a>基础环境</h4><blockquote><p>所有机器都要执行</p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">各个机器设置自己的域名</span></span><br><span class="line">hostnamectl set-hostname xxxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将 SELinux 设置为 permissive 模式（相当于将其禁用）</span></span><br><span class="line">sudo setenforce 0</span><br><span class="line">sudo sed -i &#x27;s/^SELINUX=enforcing$/SELINUX=permissive/&#x27; /etc/selinux/config</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">关闭swap</span></span><br><span class="line">swapoff -a  </span><br><span class="line">sed -ri &#x27;s/.*swap.*/#&amp;/&#x27; /etc/fstab</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">允许 iptables 检查桥接流量</span></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/modules-load.d/k8s.conf</span><br><span class="line">br_netfilter</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">cat &lt;&lt;EOF | sudo tee /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sudo sysctl --system</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF | sudo tee /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg</span><br><span class="line">   http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kubelet kubeadm kubectl</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo yum install -y kubelet-1.20.9 kubeadm-1.20.9 kubectl-1.20.9 --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">sudo systemctl enable --now kubelet</span><br></pre></td></tr></table></figure><h3 id="使用kubeadm引导集群"><a class="header-anchor" href="#使用kubeadm引导集群">¶</a>使用kubeadm引导集群</h3><h4 id="下载各个机器需要的镜像"><a class="header-anchor" href="#下载各个机器需要的镜像">¶</a>下载各个机器需要的镜像</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo tee ./images.sh &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">images=(</span><br><span class="line">kube-apiserver:v1.20.9</span><br><span class="line">kube-proxy:v1.20.9</span><br><span class="line">kube-controller-manager:v1.20.9</span><br><span class="line">kube-scheduler:v1.20.9</span><br><span class="line">coredns:1.7.0</span><br><span class="line">etcd:3.4.13-0</span><br><span class="line">pause:3.2</span><br><span class="line">)</span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images/$imageName</span><br><span class="line">done</span><br><span class="line">EOF</span><br><span class="line">   </span><br><span class="line">chmod +x ./images.sh &amp;&amp; ./images.sh</span><br></pre></td></tr></table></figure><h4 id="初始化主节点"><a class="header-anchor" href="#初始化主节点">¶</a>初始化主节点</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有机器添加master域名映射，以下需要修改为自己的</span></span><br><span class="line">echo &quot;172.31.0.4  cluster-endpoint&quot; &gt;&gt; /etc/hosts</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">主节点初始化</span></span><br><span class="line">kubeadm init \</span><br><span class="line">--apiserver-advertise-address=172.31.0.4 \</span><br><span class="line">--control-plane-endpoint=cluster-endpoint \</span><br><span class="line">--image-repository registry.cn-hangzhou.aliyuncs.com/lfy_k8s_images \</span><br><span class="line">--kubernetes-version v1.20.9 \</span><br><span class="line">--service-cidr=10.96.0.0/16 \</span><br><span class="line">--pod-network-cidr=192.168.0.0/16</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">所有网络范围不重叠</span></span><br></pre></td></tr></table></figure><p>接下来就会：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Your Kubernetes control-plane has initialized successfully!</span><br><span class="line"></span><br><span class="line">To start using your cluster, you need to run the following as a regular user:</span><br><span class="line"></span><br><span class="line">  mkdir -p $HOME/.kube</span><br><span class="line">  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">  sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line"></span><br><span class="line">Alternatively, if you are the root user, you can run:</span><br><span class="line"></span><br><span class="line">  export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line"></span><br><span class="line">You should now deploy a pod network to the cluster.</span><br><span class="line">Run &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:</span><br><span class="line">  https://kubernetes.io/docs/concepts/cluster-administration/addons/</span><br><span class="line"></span><br><span class="line">You can now join any number of control-plane nodes by copying certificate authorities</span><br><span class="line">and service account keys on each node and then running the following as root:</span><br><span class="line"></span><br><span class="line">  kubeadm join cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3 \</span><br><span class="line">    --control-plane </span><br><span class="line"></span><br><span class="line">Then you can join any number of worker nodes by running the following on each as root:</span><br><span class="line"></span><br><span class="line">kubeadm join cluster-endpoint:6443 --token hums8f.vyx71prsg74ofce7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:a394d059dd51d68bb007a532a037d0a477131480ae95f75840c461e85e2c6ae3</span><br></pre></td></tr></table></figure><p>看到里面说：<code>Alternatively, if you are the root user, you can run:</code>吧</p><p>那就执行下面的命令：</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>这样，主节点就初始化完成了</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看集群所有节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">根据配置文件，给集群创建资源</span></span><br><span class="line">kubectl apply -f xxxx.yaml</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">查看集群部署了哪些应用？</span></span><br><span class="line">docker ps   ===   kubectl get pods -A</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">运行中的应用在docker里面叫容器，在k8s里面叫Pod</span></span><br><span class="line">kubectl get pods -A</span><br></pre></td></tr></table></figure><h4 id="安装网络组件"><a class="header-anchor" href="#安装网络组件">¶</a>安装网络组件</h4><p>这里选择<code>calico</code>当然也可以选择<code>flannel</code></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">如果你使用的是1.20版本的k8s，可安装v3.21版本的Calico，</span><br><span class="line">curl https://docs.projectcalico.org/archive/v3.21/manifests/calico.yaml -O</span><br><span class="line">kubectl apply -f calico.yaml</span><br></pre></td></tr></table></figure><p>这样就会创建<code>calico</code>的<code>deployment</code>，等待所有的<code>pod</code>都<code>running</code>过后，就让node加入集群</p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubeadm join cluster-endpoint:6443 --token x5g4uy.wpjjdbgra92s25pp \</span><br><span class="line">--discovery-token-ca-cert-hash sha256:6255797916eaee52bf9dda9429db616fcd828436708345a308f4b917d3457a22</span><br></pre></td></tr></table></figure><p>一系列操作完了过后，就可以在集群节点状态中看到两个节点的<code>Ready</code>了</p><h3 id="部署dashboard"><a class="header-anchor" href="#部署dashboard">¶</a>部署dashboard</h3><blockquote><p>k8s官方提供的可视化界面</p><p><a href="https://github.com/kubernetes/dashboard">https://github.com/kubernetes/dashboard</a></p></blockquote><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.3.1/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure><p>如果下不了就：</p><ol><li><code>vim recommended.yaml</code></li><li><code>kubectl apply -f recommended.yaml</code></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Copyright 2017 The Kubernetes Authors.</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment"># you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment"># You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment"># See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment"># limitations under the License.</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Namespace</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">443</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8443</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-csrf</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="attr">csrf:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-key-holder</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">Opaque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard-settings</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Dashboard to get, update and delete Dashboard exclusive secrets.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;secrets&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;kubernetes-dashboard-key-holder&quot;</span>, <span class="string">&quot;kubernetes-dashboard-certs&quot;</span>, <span class="string">&quot;kubernetes-dashboard-csrf&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line">    <span class="comment"># Allow Dashboard to get and update &#x27;kubernetes-dashboard-settings&#x27; config map.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;configmaps&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;kubernetes-dashboard-settings&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">    <span class="comment"># Allow Dashboard to get metrics.</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;services&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;heapster&quot;</span>, <span class="string">&quot;dashboard-metrics-scraper&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;proxy&quot;</span>]</span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;services/proxy&quot;</span>]</span><br><span class="line">    <span class="attr">resourceNames:</span> [<span class="string">&quot;heapster&quot;</span>, <span class="string">&quot;http:heapster:&quot;</span>, <span class="string">&quot;https:heapster:&quot;</span>, <span class="string">&quot;dashboard-metrics-scraper&quot;</span>, <span class="string">&quot;http:dashboard-metrics-scraper&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line">  <span class="comment"># Allow Metrics Scraper to get metrics from the Metrics server</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;metrics.k8s.io&quot;</span>]</span><br><span class="line">    <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>, <span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">    <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;list&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubernetesui/dashboard:v2.3.1</span></span><br><span class="line">          <span class="attr">imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8443</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">args:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--auto-generate-certificates</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">--namespace=kubernetes-dashboard</span></span><br><span class="line">            <span class="comment"># Uncomment the following line to manually specify Kubernetes API server Host</span></span><br><span class="line">            <span class="comment"># If not specified, Dashboard will attempt to auto discover the API server and connect</span></span><br><span class="line">            <span class="comment"># to it. Uncomment only if the default does not work.</span></span><br><span class="line">            <span class="comment"># - --apiserver-host=http://my-address:port</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">              <span class="attr">mountPath:</span> <span class="string">/certs</span></span><br><span class="line">              <span class="comment"># Create on-disk volume to store exec logs</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">              <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTPS</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8443</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">1001</span></span><br><span class="line">            <span class="attr">runAsGroup:</span> <span class="number">2001</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">          <span class="attr">secret:</span></span><br><span class="line">            <span class="attr">secretName:</span> <span class="string">kubernetes-dashboard-certs</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;kubernetes.io/os&quot;:</span> <span class="string">linux</span></span><br><span class="line">      <span class="comment"># Comment the following tolerations if Dashboard must not be deployed on master</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">      <span class="attr">targetPort:</span> <span class="number">8000</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">1</span></span><br><span class="line">  <span class="attr">revisionHistoryLimit:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">k8s-app:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">      <span class="attr">annotations:</span></span><br><span class="line">        <span class="attr">seccomp.security.alpha.kubernetes.io/pod:</span> <span class="string">&#x27;runtime/default&#x27;</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dashboard-metrics-scraper</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">kubernetesui/metrics-scraper:v1.0.6</span></span><br><span class="line">          <span class="attr">ports:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="attr">containerPort:</span> <span class="number">8000</span></span><br><span class="line">              <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">          <span class="attr">livenessProbe:</span></span><br><span class="line">            <span class="attr">httpGet:</span></span><br><span class="line">              <span class="attr">scheme:</span> <span class="string">HTTP</span></span><br><span class="line">              <span class="attr">path:</span> <span class="string">/</span></span><br><span class="line">              <span class="attr">port:</span> <span class="number">8000</span></span><br><span class="line">            <span class="attr">initialDelaySeconds:</span> <span class="number">30</span></span><br><span class="line">            <span class="attr">timeoutSeconds:</span> <span class="number">30</span></span><br><span class="line">          <span class="attr">volumeMounts:</span></span><br><span class="line">          <span class="bullet">-</span> <span class="attr">mountPath:</span> <span class="string">/tmp</span></span><br><span class="line">            <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">securityContext:</span></span><br><span class="line">            <span class="attr">allowPrivilegeEscalation:</span> <span class="literal">false</span></span><br><span class="line">            <span class="attr">readOnlyRootFilesystem:</span> <span class="literal">true</span></span><br><span class="line">            <span class="attr">runAsUser:</span> <span class="number">1001</span></span><br><span class="line">            <span class="attr">runAsGroup:</span> <span class="number">2001</span></span><br><span class="line">      <span class="attr">serviceAccountName:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line">      <span class="attr">nodeSelector:</span></span><br><span class="line">        <span class="attr">&quot;kubernetes.io/os&quot;:</span> <span class="string">linux</span></span><br><span class="line">      <span class="comment"># Comment the following tolerations if Dashboard must not be deployed on master</span></span><br><span class="line">      <span class="attr">tolerations:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line">          <span class="attr">effect:</span> <span class="string">NoSchedule</span></span><br><span class="line">      <span class="attr">volumes:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">tmp-volume</span></span><br><span class="line">          <span class="attr">emptyDir:</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>启动pod过后，就可以设置访问端口：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl edit svc kubernetes-dashboard -n kubernetes-dashboard</span><br></pre></td></tr></table></figure><blockquote><p>type: ClusterIP 改为 type: NodePort</p></blockquote><p><strong>完了过户，执行下面的命令找到端口：</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kubectl get svc -A |grep kubernetes-dashboard</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment"># 找到端口，在安全组放行</span></span></span><br></pre></td></tr></table></figure><p>这样就可以在任何节点通过<code>host+port</code>访问<code>dashboard</code>了</p><p>但是我们还需要一个访问账号</p><p><strong>创建访问账号</strong></p><ol><li><code>vim dash.yaml</code></li><li><code>kubectl apply -f dash.yaml</code></li></ol><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#创建访问账号，准备一个yaml文件； vi dash.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">admin-user</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">kubernetes-dashboard</span></span><br></pre></td></tr></table></figure><p><strong>执行下面命令获取访问token</strong></p><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">获取访问令牌</span></span><br><span class="line">kubectl -n kubernetes-dashboard get secret $(kubectl -n kubernetes-dashboard get sa/admin-user -o jsonpath=&quot;&#123;.secrets[0].name&#125;&quot;) -o go-template=&quot;&#123;&#123;.data.token | base64decode&#125;&#125;&quot;</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">eyJhbGciOiJSUzI1NiIsImtpZCI6InpXSkU0TjhCUmVKQzBJaC03Nk9ES2NMZ1daRTRmQ1FMZU9rRUJ3VXRnM3MifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLXgyczhmIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiIzOTZmYjdlNS0wMjA2LTQxMjctOGQzYS0xMzRlODVmYjU0MDAiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.Hf5mhl35_R0iBfBW7fF198h_klEnN6pRKfk_roAzOtAN-Aq21E4804PUhe9Rr9e_uFzLfoFDXacjJrHCuhiML8lpHIfJLK_vSD2pZNaYc2NWZq2Mso-BMGpObxGA23hW0nLQ5gCxlnxIAcyE76aYTAB6U8PxpvtVdgUknBVrwXG8UC_D8kHm9PTwa9jgbZfSYAfhOHWmZxNYo7CF2sHH-AT_WmIE8xLmB7J11vDzaunv92xoUoI0ju7OBA2WRr61bOmSd8WJgLCDcyBblxz4Wa-3zghfKlp0Rgb8l56AAI7ML_snF59X6JqaCuAcCJjIu0FUTS5DuyIObEeXY-z-Rw</span><br></pre></td></tr></table></figure><p><strong>进入</strong><code>dashboard</code></p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221119123545481.png" alt="image-20221119123545481" style="zoom:150%;" /><h1>⭐完成~⭐</h1>]]></content>
      
      
      <categories>
          
          <category> 搭建教程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> k8s </tag>
            
            <tag> 部署 </tag>
            
            <tag> 运维 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅谈Redis主从、哨兵</title>
      <link href="/2022/11/10/%E6%B5%85%E8%B0%88Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5/"/>
      <url>/2022/11/10/%E6%B5%85%E8%B0%88Redis%E4%B8%BB%E4%BB%8E%E3%80%81%E5%93%A8%E5%85%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="主从"><a class="header-anchor" href="#主从">¶</a>主从</h2><p>先说说主从吧。单机的Redis，能够承载的QPS就在上万到几万不等。但对于缓存来说，本来就是用于高并发的读写的，毕竟不像Mysql那样。</p><p>因此，需要将架构提升到，主从(master-slave)架构：一主多从，主读，从写，达到读写分离的效果。所有的读的请求全部走从节点，也可以很轻松的实现水平扩容，支撑住高并发。</p><h3 id="Redis-replication-的核心机制"><a class="header-anchor" href="#Redis-replication-的核心机制">¶</a>Redis replication 的核心机制</h3><ul><li>Redis采用异步的方式复制数据到<code>slave</code>节点，(从Redis2.8开始，slave node 会周期性地确认自己和master node上的数据是否保持一致)</li><li>一个master node 可以配置多个slave node</li><li>slave node 也可以连接其他的 slave  node（slave node 之间的通讯）</li><li>slave node 节点在复制数据的时候，不会 block master node</li><li>slave node 节点在复制数据的时候，也不会block 自己的查询操作，它会先用之前的旧数据集来提供服务；<br>但是复制完成的时候，需要删除旧数据集，这个时候就会暂停对外服务了；</li></ul><p>有一点挺重要的，如果采用了master—slave架构，<strong>那么建议开启 master node 的持久化</strong>，<strong>并且不建议使用 slave node 做 master node 的数据热备</strong>，因为那样的话，如果我们关闭了master的持久化，可能在master重启的时候数据是空的，那么slave复制过来的数据也是空的，数据丢失。</p><h3 id="Redis-主从复制的原理"><a class="header-anchor" href="#Redis-主从复制的原理">¶</a>Redis 主从复制的原理</h3><p>当启动一个slave node 时，他会发送一个<code>PSYNC</code>命令给master node</p><ol><li>slave连接到master ——&gt; 触发一次 <code>full resynchronization</code>全复制</li><li>master就启动一个后台线程，生成一份<code>RDB</code>快照文件 ——&gt; 发给slave</li><li>然后slave node 收到这个快照文件过后，将他写入磁盘中。完了过后，将这份数据持久到内存中。</li><li>紧接着，master会讲 <strong>内存中 缓存的 写命令</strong> 发送到slave，slave会同步这些数据。</li></ol><p>如果slave node 跟master node 出现了网络故障，断开了连接，会自动重连，重连过后 master node 仅仅会复制给slave部分缺少的数据</p><h3 id="主从复制的断点续传"><a class="header-anchor" href="#主从复制的断点续传">¶</a>主从复制的断点续传</h3><blockquote><p>从Redis2.8开始，Redis就支持所谓的<strong>主从复制的断点续传</strong></p></blockquote><p>什么意思呢，如果主从复制的过程当中，由于网络IO等各种原因，导致复制过程中断，那么可以接着上次复制的点，继续复制下去，而不是从头开始复制一份</p><p><strong>原理如下：</strong></p><blockquote><p>master node  会在内存中维护一个<code>backlog</code>，master 和 slave 都会保存一个 <code>replica offset</code>还有一个个<code>master run id</code> ，<code>offset</code>就是保存在<code>backlog</code>中的</p><p><code>backlog</code>中，如果master和slave网络中断了，slave会让master从上次<code>replica offset</code>开始继续复制，如果没有找到对应的<code>offset</code>，那么就会执行一次<code>resynchronization</code></p><p>如果根据<code>host+ip</code>定位master node ，是不靠谱的，土规 master node  重启或者数据出现了变化，那么slave node 应该根据不同的run id区分</p></blockquote><h3 id="过期Key的处理"><a class="header-anchor" href="#过期Key的处理">¶</a>过期Key的处理</h3><p>slave 不会过期key，主从主从，仆人肯定是听从主人的嘛，slave只会等待master过期key。如果master过期了一个key，后者通过LRU淘汰了一个key，那么会模拟一条类似于<code>del</code>的指令发送给slave去删除过期的kwy</p><h3 id="那么Redis如何才能做到高可用呢"><a class="header-anchor" href="#那么Redis如何才能做到高可用呢">¶</a>那么Redis如何才能做到高可用呢</h3><p>如果一个系统在356天，有99.99%的时间内，都是可以对外提服务的，那么就是说这个系统是高可用的</p><p>一个slave挂掉了，是不会影响到系统的可用性，因为还有其他的slave在提供服务</p><p>那么，吐过master node 寄了呢，没办法写数据了，写缓存的时候，全部都是失效了。slave node 就没什么作用了，毕竟没有master 给他们复制数据了，这就是所谓群龙无首，遮掩搞得系统相当于不可用</p><hr><p>这就需要设计Redis的高可用架构，<strong>故障转移</strong>，也可以叫做<strong>主备切换</strong></p><p>存在故障转移过后，master node 寄，系统自动监测，并且将某个slave node 自动切换为 master node ，类似于继承？或者说是选举更合适一点。</p><p>这个过程中，就实现了Redis 的主从架构的高可用。</p><p>要完成这样的架构设计，就需要接下来要说到了哨兵机制了……</p><h2 id="哨兵"><a class="header-anchor" href="#哨兵">¶</a>哨兵</h2><h3 id="什么是哨兵？"><a class="header-anchor" href="#什么是哨兵？">¶</a>什么是哨兵？</h3><blockquote><p>Sentinle，中文名是哨兵</p></blockquote><p>哨兵是Redis集群架构中非常重要的一个组件，主要有以下功能：</p><ul><li>集群监控：负责监控Redis master node 和 slave node 是否正常工作</li><li>消息通知：如果某个node有故障，那么哨兵负责发送消息作为警报通知给Mng</li><li>故障转移：如果master node 寄了，会自动将某个slave node 选举为 新的master</li><li>配置中心：如果股中航转移发生了，通知client客户端新的master的<code>address</code></li></ul><p>哨兵是用来实现Redis集群的高可用的，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作</p><ul><li>故障转移的时候，判断一个master node 是否宕机了，需要大部分的哨兵都同意才可以，涉及到了分布式的选举的问题了，这个后面会提</li><li>即使部分哨兵的node 寄了，哨兵集群还是能正常工作的</li></ul><p>介绍完哨兵是什么过后，来说说哨兵的核心知识</p><h3 id="哨兵的核心知识"><a class="header-anchor" href="#哨兵的核心知识">¶</a>哨兵的核心知识</h3><ol><li>哨兵至少需要3个实例，来保证自己的健壮性</li><li>哨兵+Redis主从的部署架构，是保证数据不丢失的，只能保障Redis集群的高可用性</li></ol><p>哨兵集群必须部署2个以上的节点，如果哨兵集群仅仅部署了2个哨兵实例，quorum = 1</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+----+         +----+</span><br><span class="line">| M1 |---------| R1 |</span><br><span class="line">| S1 |         | S2 |</span><br><span class="line">+----+         +----+</span><br></pre></td></tr></table></figure><p>配置<code>quorum = 1</code>，如果，master宕机了，s1 s2 中只能有1个哨兵认为master宕机了，就可以进行切换，同时s1 和 s2 会选举出一个哨兵来执行故障转移，但是同时这个时候，需要<code>majority</code>，也就是大多数哨兵都是运行的，</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">2 个哨兵，majority=2</span><br><span class="line">3 个哨兵，majority=2</span><br><span class="line">4 个哨兵，majority=2</span><br><span class="line">5 个哨兵，majority=3</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>说到这里，什么是<code>quorum</code>和<code>majority</code>呢</p><h4 id="quorum和majority"><a class="header-anchor" href="#quorum和majority">¶</a>quorum和majority</h4><p>每次一个哨兵要做主备切换，首先需要quorum数量的哨兵认为<code>odown</code>，然后选举出一个哨兵来做切换，这个哨兵还需要得到majority哨兵的授权，才能正式执行切换</p><ul><li>如果quorum &lt; majority ， 比如说 5个哨兵， majority = 3， quorum = 2，那么3个哨兵授权就可以执行切换</li><li>但是如果 quorum &gt;= majority，那么必须quorum 数量的哨兵都授权，比如5个哨兵，quorum = 5 ，那么必须5个哨兵都同意授权，才能执行切换</li></ul>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> Redis </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络通讯与TPC/IP</title>
      <link href="/2022/10/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8ETPC-IP/"/>
      <url>/2022/10/16/%E7%BD%91%E7%BB%9C%E9%80%9A%E8%AE%AF%E4%B8%8ETPC-IP/</url>
      
        <content type="html"><![CDATA[<h1>网络通信与TCP/IP</h1><p>什么是计算机的网络？<br>老套路、官方话：</p><blockquote><p>利用通信线路将地理上分散的、具有独立功能的计算机系统和通信设备按不同的形式连接起来，以功能完善的网络软件及协议实现资源共享和信息传递的系统。</p></blockquote><p><strong>主要的网络</strong>：</p><ol><li>局域网</li><li>城域网</li><li>广域网</li><li>无线网</li><li>…</li></ol><p>P话就不多说了，直接进入主题吧</p><p>首先是，网络通讯的鼻祖、<strong>OSI七层模型</strong>：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015165435767.png" alt="image-20221015165435767" align="left" style="zoom: 50%;" /><p>再到我们现在的<strong>TCP/IP五层模型</strong>：</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015165526473.png" alt="image-20221015165526473"  align="left" style="zoom:71%;" /><p>从图片中可以看出来，TCPIP只是把OSI的上三层合并为了一层，应用层。</p><p>方便记忆：</p><ul><li>应用层：平时我们访问使用的http(bushi)、https协议；或者远程连接的Mysql；远程连接的SSH…</li><li>传输层：<ul><li>TCP协议：面向连接的、可靠的流协议</li><li>UDP协议：面向无连接的通讯协议</li></ul></li><li>网络层：IP地址</li><li>数据链路层：硬件驱动程序，追究到底还是</li><li>物理层：网卡</li></ul><p>有些说法是吧最底层的物理层+数据链路层合成一层，但其实不是…</p><h2 id="浅谈TCP-UDP"><a class="header-anchor" href="#浅谈TCP-UDP">¶</a>浅谈TCP/UDP</h2><p>从上文看到，TCP协议是面向连接的、可靠的流协议；而UDP是面向无连接的通讯协议</p><p>TCP首先是要建立连接的，他会有我们平常所说的3次握手，</p><p>为什么要建立连接呢？</p><blockquote><p>1.更好的保证可靠性: 建立连接的过程其实就是让通信双方验证各自的发送能力和接受能力是否正常<br>2.协商一些重要参数 (如: 序号的初始值)</p></blockquote><p>具体怎么建立连接？</p><blockquote><p>栗子：</p><p>A给B打电话，打电话同样要同样给自己以及对方的话筒是否正常工作</p><p>第一次握手：刚开始，A不知道自己和B书籍的听筒的话筒是否正常，所以A说：“喂喂喂？？？”</p><p>第二次握手：B听到过后，说明A的话筒和B的听筒正常，但B还需要进一步的检查自己的话筒是否正常；同时B吧A话筒正常和自己听筒正常的消息传给A；于是B：”干嘛？你爹！”</p><p>第三次握手：A收到了B的消息后，就证明了A听筒正常，B听筒正常</p></blockquote><p>这就类似于网络建立连接的三次握手…</p><p>所以，网络中传输数据整体过程是这样的：</p><blockquote><p>又是一个栗子：在消息发送的过程中</p><p>首先我们吧消息编辑好，点击发送button，此时，这个消息还处于<strong>应用层</strong>。点击button后，进入传输层，被解析成，计算机唯一认识的01二进制，再加上大概20个字节的TCP首部，形成<strong>报文</strong>，或者是所谓的<strong>消息</strong>；</p><p>然后，传进网络层，加上IP包首部——&gt;报文段</p><p>传进数据链路层，加上以太网首部——&gt;数据报</p><p>最后进入物理层，通过网卡等硬件，带上型信号，传进以太网电缆。</p><p>等这个<strong>帧</strong>，被甲方接收到过后，通过以上的顺序的反解析，一步一步脱壳成最初我们所编辑的数据包，展示在甲方的应用层上。这时，甲方手机上显现一个：“我是你爹”<br>的时候就</p><p>完成的数据(消息)的传输</p></blockquote><hr><p><strong>而UDP</strong></p><p>他最主要的特点就是、UDP是无连接的，就是发送数据之前不需要建立连接，这也是与TCP协议的本质区别，当然，发送数据结束的时候也没有连接可以释放，一次，就减少了开销和发送数据之前的延迟，</p><p>目前QQ，微信，语音电话、视频……之类的通讯大都基于UDP的通信协议，因为大都人不会因为你那一个像素点，一句话两句话听不清楚就抱怨什么(没有针对一些比较紧急的场景)</p><h2 id="网络通讯中的地址与端口号"><a class="header-anchor" href="#网络通讯中的地址与端口号">¶</a>网络通讯中的地址与端口号</h2><h3 id="地址Address"><a class="header-anchor" href="#地址Address">¶</a>地址Address</h3><ul><li>IP地址和MAC地址</li></ul><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015185133497.png" alt="image-20221015185133497" align="left" style="zoom:60%; " /><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015185221395.png" alt="image-20221015185221395" align="left" style="zoom:50%; " /><p>打开<strong>win</strong>的<strong>powerShell</strong>，输入：<code>ipconfig</code>可以看到自己设备信息</p><p>这里的物理地址就是MAC地址。MAC地址是厂商开始创建这个设备的时候就将其写在点的硬件上的。所以每个设备只有一个MAC地址，还是不能修改的(除非说是你通过物理手段，修改BIOS，修改MAC地址)，所以MAC地址实在TCP的数据链路层上用的，也可以理解成数据链路层的地址。</p><p>看到我电脑上无线局局域网Adapter (WALN) 下的MAC地址是：E0-D4-64-31-CA-13，前一半是<a href="https://zh.wikipedia.org/wiki/%E7%94%B5%E6%B0%94%E7%94%B5%E5%AD%90%E5%B7%A5%E7%A8%8B%E5%B8%88%E5%AD%A6%E4%BC%9A">IEEE</a>给每个厂商一个，后面一半由厂商自己分配</p><p>IPV4就不用说了，没有IPV4是没法上网的，这个东西要么手动获取，要么DHCP服务器给分配IPV4</p><ul><li><p>MAC地址与IPV4的区别</p><blockquote><ol><li>MAC地址不能随意更换，IPV4可以</li><li>MAC地址48位，IPV4是32位</li><li>MAC地址工作在数据链路层，IPV4工作在网络层</li></ol></blockquote></li></ul><h3 id="端口Port"><a class="header-anchor" href="#端口Port">¶</a>端口Port</h3><p>官方：</p><blockquote><p>用来识别同一台计算机设备设备中不同的应用程序，也被称之为应用程序地址</p></blockquote><ul><li><p>为什么端口号有65535个？</p><blockquote><p>因为TCP和UDP协议里面报文头中吗，有专门的的字段来存这个端口号，这个字段头只有2个字节，2^16 = 65536 ，但是一般端口0只带本设备上所有的端口。</p><p>所以端口号只有65536 - 1 =  65535个</p></blockquote></li><li><p>一台设备上最多只能有65535个TCP连接嘛？</p><blockquote><p>这是可笑的，</p><p>一个栗子：现有10个客户端连接一台机器上的Mysql，Mysql也只是接收到了3306这个端口上发送来的数据，</p><p>所以，一台设备上所能接收到的链接，与端口号数没有必然关系。</p></blockquote></li></ul><p>再者，一个通讯在网络中是由5个元组识别：</p><ol><li>源IP</li><li>目标IP</li><li>TCP协议号</li><li>源端口</li><li>目标端口</li></ol><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015200329440.png" alt="image-20221015200329440"></p><h3 id="TCP三次握手建立连接"><a class="header-anchor" href="#TCP三次握手建立连接">¶</a>TCP三次握手建立连接</h3><p>图片来自：<a href="https://www.bilibili.com/video/BV1c4411d7jb?p=65&amp;vd_source=61258a05469482a4381c086011c25c18">https://www.bilibili.com/video/BV1c4411d7jb?p=65&amp;vd_source=61258a05469482a4381c086011c25c18</a></p><p>TCP报文的首部格式</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015203150879.png" alt="image-20221015203150879"></p><p>至于三次握手的流程我就懒得用文字来描述了，用图片的方式可能更好记忆一点(可能纯粹就是懒吧…)</p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221015204050802.png" alt="image-20221015204050802" align="left" style="zoom:70%;" /><p>其中SYN是TCP报文里面某一个bit的站位标志。</p><p>出于这样的连接方式，TCP的三次握手也是会有漏洞，——SYN洪泛攻击</p><p><strong>SYN洪泛攻击</strong>，是通过网络服务所在的端口发送大量伪造源地址的攻击报文，发送到服务端，造成服务端上的<strong>半开连接</strong>，队列被占满，从而组织其他用户进行访问。</p><p><strong>原理</strong></p><blockquote><p>攻击者客户端利用为伪造的IP地址想服务端发出请求(第一次)。而服务端的响应(第二次)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(其实永远不会有的，毕竟是伪造的)，服务端在这种半开的链接过程中小号了资源，如果有成千上万的这样链接，主机资源将被耗尽，从而发达到攻击的目的，就有点像DDOS攻击，都是发送大量的数据包。</p></blockquote><p><strong>解决方案</strong></p><blockquote><ul><li>无效连接监控释放</li><li>延缓TCB分配方法</li><li>防火墙</li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> 八股 </category>
          
          <category> 计网 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TCP/IP </tag>
            
            <tag> 网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rust-所有权</title>
      <link href="/2022/10/03/Rust-%E6%89%80%E6%9C%89%E6%9D%83/"/>
      <url>/2022/10/03/Rust-%E6%89%80%E6%9C%89%E6%9D%83/</url>
      
        <content type="html"><![CDATA[<p>在所有程序执行过程中，与计算机内存的暧昧行为早已被默认。但如何与其保持着敌进我退，敌退我进的距离，——在内存中申请内存来执行程序；在执行完过后，不需要的时候再释放这段内存，成为了重中之重。这也是设计编程语言过程中的一座高山。于是，三种主流的模式应运而生：</p><ul><li><p>GC：垃圾回收机制，在程序运行的同时，无时无刻的想办法找那些不被利用，并且以后也不再使用的内存，回收起来，例如最经典的Java(Jvm)，Go，C#</p></li><li><p>显示操作：回收，申请内存这些操作改成了由程序员自己手动操作，(比起GC的耗性能，我果然还是接收不了自己手动操作对象空间的申请与释放)，C++</p></li><li><blockquote><p><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查(这里就直接把原话复制过来吧)</p></blockquote></li></ul><p>而Rust正好就是第三种，对内存的管理机制——<strong>所有权</strong></p><p>这种机制，早在编译的时候就确立好了这段内存由谁来支配，大大的挽回了内存的损失。</p><hr><p>在说所有权之前先谈谈栈和堆吧</p><h3 id="栈、堆"><a class="header-anchor" href="#栈、堆">¶</a>栈、堆</h3><ul><li><p>栈</p><blockquote><p>这个东西，数据结构的角度看栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表的子集。他们是操作受限的线性表…</p><p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。出于这样的存储方式，在栈中的数据必须有明确的大小，并且在之后的操作中不得改变(明确，固定)，假设数据是未知的，那么在取出数据时，将无法获取想要的数据。</p></blockquote></li><li><p>堆</p><blockquote><p>相对于栈，我们(哪儿来的们🐟)对堆的认识往往并不多，可能是出于平常使用的编程语言并不要求我们对栈堆有多大的掌握。扯远了…</p><p>与栈不同，对于未知数据的存储，我们需要将它存到堆中。在存数据的过程中，OS首先在堆中找到一份它觉得合适大小的空间，将它标记为——&gt;已使用，并返回这段空间的指针地址，该过程称之为——&gt;<strong>分配</strong>。接着，让数据占用这段空间。</p><p>当我们访问这段空间想拿到数据时，只需要找到刚刚被分配到栈中的指针，去找地址就好了。</p><p>(这个例子以后还会提到)就好像我们去餐厅吃饭，服务员问我们几个人，我们说6个，那她就会带我们去大概6 7个位置左右的餐桌，这个过程就是分配。完了过后，要是有人迟到了，想找到我们，只需要我们发短信给他一个餐桌号，他就可以顺利的找到我们，这个过程就是拿数据。</p></blockquote></li></ul><h3 id="所有权机制"><a class="header-anchor" href="#所有权机制">¶</a><strong>所有权机制</strong></h3><blockquote><ul><li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li><li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li><li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</li></ul></blockquote><h3 id="浅谈一下String"><a class="header-anchor" href="#浅谈一下String">¶</a>浅谈一下String</h3><p>在rust里面，当我们在编译器里输入<code>let s =&quot;hello&quot;</code>时，s这个变量是直接被硬编码到程序里面去的(类型为：<code>&amp;str</code>)，也叫作<strong>字符串字面量</strong>，字符串字面量是很方便的，但是在有些时候，这个方便并没有体现到位，原因是：</p><ul><li>由于是直接被硬编码到程序当中去，所以他是不可变的</li><li>并非所有字面量都能在编写代码的时候得知他的值</li></ul><p>于是就有了动态字符串类型：<code>String</code></p><p>这个类型被分配到堆空间上，所以可以动态的伸缩，也就可以存储位置大小的文本。</p><p>在rust中，想要得到一个String类型的变量很简单：<code>let s = String::new(&quot;yxyl&quot;);</code></p><h3 id="浅拷贝和深拷贝"><a class="header-anchor" href="#浅拷贝和深拷贝">¶</a>浅拷贝和深拷贝</h3><h4 id="拷贝-浅拷贝"><a class="header-anchor" href="#拷贝-浅拷贝">¶</a>(拷贝)浅拷贝</h4><p>先讲讲浅拷贝吧，浅拷贝只是发生在栈上，因此，性能很高，就比如：</p><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure><p>这段代码就是很实在的浅拷贝，因为整形这个数据类型大小是已知的，会被存储在栈上，所以浅拷贝也是快速的、这意味着没有理由在创建<code>y</code>过后，<code>x</code>失效</p><h4 id="克隆-深拷贝"><a class="header-anchor" href="#克隆-深拷贝">¶</a>(克隆)深拷贝</h4><p>没有人会做出有损自己利益的事情，rust也一样，rust不会主动进行数据的深拷贝，他是低效且耗性能的，就像如果想要复制String类型的变量时候，通常会用<code>clone()</code>这样一个方法，他不仅仅是复制栈上的数据，深度copy了堆上的数据。</p>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>您的设计模式-单例模式</title>
      <link href="/2022/09/19/%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2022/09/19/%E6%82%A8%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1>单例模式【Singleton Pattern】</h1><blockquote><p>这个模式是很有意思，而且比较简单，但是我还是要说因为它使用的是如此的广泛，如此的有人缘， 单例就是单一、独苗的意思，那什么是独一份呢？你的思维是独一份，除此之外还有什么不能山寨的呢？ 我们举个比较难复制的对象：皇帝  中国的历史上很少出现两个皇帝并存的时期，是有，但不多，那我们就认为皇帝是个单例模式，在这 个场景中，有皇帝，有大臣，大臣是天天要上朝参见皇帝的，今天参拜的皇帝应该和昨天、前天的一样（过渡期的不考虑，别找茬哦），大臣磕完头，抬头一看，嗨，还是昨天那个皇帝，单例模式，绝对的单例模式， 先看类图：</p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220919101551388.png" alt="image-20220919101551388"></p><p><strong>然后我们看程序实现，先定一个皇帝：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 中国的历史上一般都是一个朝代一个皇帝，有两个皇帝的话，必然要PK出一个皇帝出来</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Emperor</span> &#123; </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Emperor</span> <span class="variable">emperor</span> <span class="operator">=</span> <span class="literal">null</span>; <span class="comment">//定义一个皇帝放在那里，然后给这个皇帝名字</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Emperor</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="comment">//世俗和道德约束你，目的就是不让你产生第二个皇帝</span></span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Emperor <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(emperor == <span class="literal">null</span>)&#123; <span class="comment">//如果皇帝还没有定义，那就定一个</span></span><br><span class="line">         emperor = <span class="keyword">new</span> <span class="title class_">Emperor</span>(); </span><br><span class="line">         &#125; </span><br><span class="line">         <span class="keyword">return</span> emperor; </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//皇帝叫什么名字呀</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">emperorInfo</span><span class="params">()</span>&#123; </span><br><span class="line">     System.out.println(<span class="string">&quot;我就是皇帝某某某....&quot;</span>); </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>然后定义大臣：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 大臣是天天要面见皇帝，今天见的皇帝和昨天的，前天不一样那就出问题了！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Minister</span> &#123; </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">     <span class="comment">//第一天</span></span><br><span class="line">     Emperor emperor1=Emperor.getInstance(); </span><br><span class="line">     emperor1.emperorInfo(); <span class="comment">//第一天见的皇帝叫什么名字呢？</span></span><br><span class="line"></span><br><span class="line">     <span class="comment">//第二天</span></span><br><span class="line">     Emperor emperor2=Emperor.getInstance(); </span><br><span class="line">     Emperor.emperorInfo(); </span><br><span class="line"></span><br><span class="line">     <span class="comment">//第三天</span></span><br><span class="line">     Emperor emperor3=Emperor.getInstance(); </span><br><span class="line">     emperor2.emperorInfo(); </span><br><span class="line"></span><br><span class="line">     <span class="comment">//三天见的皇帝都是同一个人，荣幸吧！</span></span><br><span class="line">     &#125; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p><strong>看到没，大臣天天见到的都是同一个皇帝，不会产生错乱情况，反正都是一个皇帝，是好是坏就这一 个，只要提到皇帝，大家都知道指的是谁，清晰，而又明确。问题是这是通常情况，还有个例的，如同一 个时期同一个朝代有两个皇帝，怎么办？</strong></p><p><strong>单例模式很简单，就是在构造函数中多了加一个构造函数，访问权限是 private 的就可以了，这个模式是简单，但是简单中透着风险，风险？什么风险？在一个 B/S 项目中，每个 HTTP Request 请求到 J2EE 的容器上后都创建了一个线程,每个线程都要创建同一个单例对象,怎么办?,好,我们写一个通用的单例程 序,然后分析一下:</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 通用单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SingletonPattern singletonPattern= <span class="literal">null</span>; </span><br><span class="line">    <span class="comment">//限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123; </span><br><span class="line"></span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="keyword">if</span>(<span class="built_in">this</span>.singletonPattern == <span class="literal">null</span>)&#123; <span class="comment">//如果还没有实例，则创建一个</span></span><br><span class="line">     <span class="built_in">this</span>.singletonPattern = <span class="keyword">new</span> <span class="title class_">SingletonPattern</span>(); </span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">this</span>.singletonPattern; </span><br><span class="line">     &#125; </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​假如现在有两个线程 A 和线程 B，线程 A 执行到 <code>this.singletonPattern =  new SingletonPattern()</code>，正在申请内存分配，可能需要 0.001 微秒，就在这 0.001 微秒之内，线程 B 执 行到 <code>if(this.singletonPattern == null)</code>，你说这个时候这个判断条件是 true 还是 false？是 true，那然后呢？线程 B 也往下走，于是乎就在内存中就有两个 <code>SingletonPattern</code> 的实例了，看看是不是出问题了？</p><p>​如果你这个单例是去拿一个序列号或者创建一个信号资源的时候，会怎么样？业务逻辑混乱！数据一致性校验失败！最重要的是你从代码上还看不出什么问题，这才是最要命的！因为这种情况基本上你是重现不 了的，不寒而栗吧，那怎么修改？有很多种方案，我就说一种，能简单的、彻底解决问题的方案：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> cbf4Life cbf4life@126.com</span></span><br><span class="line"><span class="comment">* I&#x27;m glad to share my knowledge with you all.</span></span><br><span class="line"><span class="comment">* 通用单例模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;all&quot;)</span> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingletonPattern</span> &#123; </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SingletonPattern singletonPattern= <span class="keyword">new</span></span><br><span class="line">    <span class="title class_">SingletonPattern</span>(); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//限制住不能直接产生一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">SingletonPattern</span><span class="params">()</span>&#123; </span><br><span class="line">     &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> SingletonPattern <span class="title function_">getInstance</span><span class="params">()</span>&#123; </span><br><span class="line">     <span class="keyword">return</span> singletonPattern; </span><br><span class="line">     &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接 new 一个对象传递给类的成员变量 <code>singletonpattern</code>，你要的时候 <code>getInstance()</code>直接返回给你，解决问题！</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务简单部署</title>
      <link href="/2022/09/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/"/>
      <url>/2022/09/18/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%AE%80%E5%8D%95%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1>微服务简单部署</h1><h2 id="📋：Docker-Conpose"><a class="header-anchor" href="#📋：Docker-Conpose">¶</a>📋：Docker-Conpose</h2><ul><li>Docker-Compose是一个用来定义和运行复杂应用的docker工具。一个使用Docker容器的应用，一般是由多个容器组成。使用Docker-Compose就不用写多个shell脚本来启动管理容器了。</li></ul><ol><li>查看docker版本：<br><code>docker -version </code></li><li>安装docker-compose<br><code>sudo apt install docker-compose</code></li><li>查看docker-compose版本<br><code>docker-compose -version</code></li></ol><h2 id="➰：打包"><a class="header-anchor" href="#➰：打包">¶</a>➰：打包</h2><ul><li>在项目目录下创建image包，放每个微服务打包好的镜像，可选择每个微服务单独一个包，以便于以后微服务版本的维护，回滚。</li></ul><h2 id="🚉：Dockerfile"><a class="header-anchor" href="#🚉：Dockerfile">¶</a>🚉：Dockerfile</h2><ul><li><p>在每个微服务包下编写Dockerfile</p><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> openjdk:<span class="number">8</span>-jre</span><br><span class="line"><span class="keyword">ENV</span> APP_PATH=/apps</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$APP_PATH</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> xxx-1.0-SNAPSHOT.jar <span class="variable">$APP_PATH</span>/app.jar</span></span><br><span class="line"><span class="keyword">EXPOSE</span> $&#123;PORT&#125;</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;java&quot;</span>,<span class="string">&quot;-jar&quot;</span>]</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> [<span class="string">&quot;app.jar&quot;</span>]</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="上传Docker-Compose文件"><a class="header-anchor" href="#上传Docker-Compose文件">¶</a>上传Docker-Compose文件</h2><ul><li><p>在<code>Docker-Compose</code>文件中编写服务：</p><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">version:</span> <span class="string">&quot;3.3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="attr">networks:</span> <span class="comment">#定义docker网络</span></span><br><span class="line">  <span class="attr">yingxue_network:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="attr">volumes:</span> <span class="comment">#挂载数据卷</span></span><br><span class="line">  <span class="attr">data:</span></span><br><span class="line">  <span class="attr">redisdata:</span></span><br><span class="line">  <span class="attr">mqdata:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">services:</span></span><br><span class="line"><span class="comment">#每个服务</span></span><br><span class="line">  <span class="attr">nacos:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">nacos/nacos-server:2.0.2</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;8848:8848&quot;</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JVM_XMS=256m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;JVM_XMX=256m&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MODE=standalone&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yingxue_network</span></span><br><span class="line">        </span><br><span class="line">  <span class="attr">mysql:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">mysql</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;3306:3306&quot;</span></span><br><span class="line">    <span class="attr">networks:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">yingxue_network</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">data:/var/lib/mysql</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">./yingxue.sql:/docker-entrypoint-initdb.d/yingxue.sql</span></span><br><span class="line">    <span class="attr">environment:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MYSQL_ROOT_PASSWORD=&quot;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;MYSQL_DATABASE=yingxue&quot;</span></span><br><span class="line">  <span class="attr">redis:</span></span><br><span class="line">    <span class="attr">image:</span> <span class="string">redis</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">&quot;6379:6379&quot;</span></span><br><span class="line">    <span class="attr">volumes:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">redisdata:/data</span></span><br><span class="line">    <span class="attr">command:</span> <span class="string">redis-server</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">  <span class="string">xxx服务:</span></span><br><span class="line">  <span class="attr">build:</span></span><br><span class="line">  <span class="attr">context:</span> <span class="string">./images/xxx</span></span><br><span class="line">  <span class="attr">dockerfile:</span> <span class="string">Dockerfile</span></span><br><span class="line">  <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&quot;xxxx:xxxx&quot;</span></span><br><span class="line">  <span class="attr">depends_on:</span></span><br><span class="line">  <span class="string">-mysql</span></span><br><span class="line">  <span class="string">-redis</span></span><br><span class="line">  <span class="string">-rebbitmq</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">....</span></span><br></pre></td></tr></table></figure><p>这里是将每个软件服务和写的微服务写在同一个<code>docker-compose</code>文件中，可以的分成两个<code>docker-compose</code>，可将其划分成：</p><ol><li>docker-compose-app.yml：微服务</li><li>docker-compose-env.yml：环境服务</li></ol></li></ul><h2 id="🚀：点火"><a class="header-anchor" href="#🚀：点火">¶</a>🚀：点火</h2><ul><li>cd到docker-compose文件，</li><li><code>docker-compose up -d</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> Micro-Serve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 部署 </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gateway自定义网关Filter</title>
      <link href="/2022/09/18/Gateway%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%85%B3Filter/"/>
      <url>/2022/09/18/Gateway%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BD%91%E5%85%B3Filter/</url>
      
        <content type="html"><![CDATA[<h1>SpringCloud-Gateway自定义网关Filter</h1><p>自定义filter可以实现两种，一种是全局生效的，一种是局部生效的，需要配置。</p><p>🖕：这边自定义下局部的</p><ol><li><p>首先命名为：<code>xxxGatewayFilterFactory</code>比如<code>TokenGatewayFilterFactory</code>，<code>AddLogGatewayFilterFactory</code>等等，再注入IOC管理</p></li><li><p>然后，通过看其他自带的局部(全局)Filter类可以看出，他们都继承了<code>AbstractGatewayFilterFactory</code>这个抽象类，</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TokenGatewayFilterFactory</span> <span class="keyword">extends</span> <span class="title class_">AbstractGatewayFilterFactory</span>&lt;TokenGatewayFilterFactory.Config&gt;</span><br></pre></td></tr></table></figure><p>其中的泛型是Filter类中自定义的内部类<code>Config</code></p></li><li><p>重写<code>apply()</code>，<code>shortcutFieldOrder()</code>方法，</p><ul><li>其中apply是核心方法，它决定着我们需要的过滤业务，</li><li>shortcutFieldOrder()方法可根据自定义顺序接收我们从配置文件传过来的value</li></ul></li><li><p>创建Filter构造方法，可以传进来需要用到的工具类等等…</p></li></ol><p>🆗：Filter over后，需要我们在网关配置文件中每个需要Filter的路由中进行配置了，可传的参数由shortcutFieldOrder决定。</p>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
          <category> Micro-Serve </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Filter </tag>
            
            <tag> Gateway </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JUC</title>
      <link href="/2022/09/17/JUC/"/>
      <url>/2022/09/17/JUC/</url>
      
        <content type="html"><![CDATA[<h2 id="🌠-JUC是什么"><a class="header-anchor" href="#🌠-JUC是什么">¶</a>🌠:JUC是什么</h2><p>JUC是<code>java.util.concurrent</code>包的缩写，这个包里包含了各种各样的关于线程通讯，控制同步的工具类——&gt;即Java并发工具包。</p><p>另外，JUC的框架结构，并不是我们常见的继承实现框架结构。JUC底层在Java中是unsafe，unsafe是jvm的实现。有了unsafe的支持，才出现可以进行原子操作的Atomic原子类…最后才到我们的Utils。</p><h2 id="🚀-进程和线程"><a class="header-anchor" href="#🚀-进程和线程">¶</a>🚀:进程和线程</h2><blockquote><p>官方：进程是CPU分配资源的最小单元，线程是CPU调度资源的最小单位</p></blockquote><p>Java默认有2个线程：mian(主线程)、GC(守护线程)</p><h2 id="🚢-并发和并行"><a class="header-anchor" href="#🚢-并发和并行">¶</a>🚢:并发和并行</h2><ul><li>并发（多个线程操作一个资源）：CPU一核，模拟出来多个线程</li><li>并行（多个人一起行走）：CPU多核，执行多条线程</li></ul><blockquote><p>线程有6个状态：</p></blockquote><ol><li><strong>NEW-&gt;新生</strong></li><li><strong>RUNNABLE-&gt;运行</strong></li><li><strong>BLOCKED-&gt;阻塞</strong></li><li><strong>WAITING-&gt;等待</strong></li><li><strong>TIMED_WAITING-&gt;死等</strong></li><li><strong>TERMINATED-&gt;终结</strong></li></ol><blockquote><p>wait/sleep区别</p></blockquote><ul><li>wait：<br>要释放锁<br>不需要捕获异常<br>只能在静态代码块中(<code>static</code>)</li><li>sleep：<br>不释放锁<br>需要捕获异常<br>任意地方都可以<strong>睡</strong></li></ul><h2 id="🔒-Lock-锁"><a class="header-anchor" href="#🔒-Lock-锁">¶</a>🔒:Lock(锁)</h2><blockquote><p>传统synchronized 本质：队列+锁 ——&gt; 排队</p></blockquote><p><code>java.util.concurrent.locks.Lock</code></p><p>其子类：</p><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220915205227492.png" alt="image-20220915205227492"></p><blockquote><p>synchronized和lock的区别</p></blockquote><ul><li>synchronized  是关键字；lock是类</li><li>synchronized  不能判断锁的状态；lock可以判断锁</li><li>synchronized  自动释放锁；lock必须手动释放锁，不释放的话–&gt;死锁</li><li>synchronized  Thread1堵塞–&gt;Thread2等待；lock不一定等</li><li>synchronized  适合少代码同步；lock适合大量代码同步</li><li><strong>…</strong></li></ul><h2 id="⭐-JUC版的PC问题"><a class="header-anchor" href="#⭐-JUC版的PC问题">¶</a>⭐:JUC版的PC问题</h2><blockquote><p>通过lock找到Condition<br>condition来对线程进行监视操作(等待，唤醒…)<br>condition操作线程，可以精准的对线程的唤醒</p></blockquote><p><strong>资源类：</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tea3</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Condition</span> <span class="variable">condition3</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">number</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printA</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition1.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition2.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printB</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition2.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">3</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition3.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">printC</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="comment">//业务</span></span><br><span class="line">            <span class="keyword">while</span> (number != <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">//等待</span></span><br><span class="line">                condition3.await();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;=&gt;&quot;</span> + number);</span><br><span class="line">            number = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//通知</span></span><br><span class="line">            condition1.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>这里看到判断线程操作资源等待的条件使用<code>while</code>判断而不用<code>if</code>，为了防止虚假唤醒的问题。</strong></p><h2 id="💦-集合类不安全"><a class="header-anchor" href="#💦-集合类不安全">¶</a>💦:集合类不安全</h2><p>我们知道在多线程下进行任何操作都是令人胆战心惊的。</p><p>多线程下，对集合CRUD，难免会遇到<code>ConcurrentModificationException</code>线程操作异常，是因为我们平常使用的ArrayList底层的数据操作方法都是单线程的，没有对线程进行处理。</p><p>针对这点，有3个常见的解决方案(仅基于Java层面)：</p><ol><li>使用Vector集合类，Vector集合类底层对集合操作进行了synchronized锁处理，但相对来说效率较低<br><code>List list = new Vector&lt;&gt;();</code></li><li>使用集合工具类中的**“锁集合”**，<code>Collections.synchronizedList(....);</code></li><li>使用<strong>读写锁集合(JUC)</strong>，<code>CopyOnWriteArrayList</code>底层对数据的集合操使用了JUC中的Lock锁类，效率较Vector自然<strong>upup</strong><br><code>List list = new CopyOnWriteArrayList();</code></li></ol><h2 id="🍶-线程池"><a class="header-anchor" href="#🍶-线程池">¶</a>🍶:线程池</h2><p>写到这里突然想起来那天学长面试的问题——说下线程的创建方法吧</p><p>头一次感受到当时开学用一个月学Java这门编程语言的时候到如今这样一个不太正式的面试，面临如此基础简单的问题 时是多么的无力…</p><p>创建线程一共有4个方法，但万变不离其宗，完全可以总结为一个方法——其最终都是执行的<code>Thread.start()</code>当中的<code>run()</code>方法</p><ol><li><p>实现<code>Runable</code>接口，重写<code>Run()</code>方法</p></li><li><p>实现<code>Callable</code>接口，重写<code>Call()</code>方法</p><ul><li><blockquote><p>与（1）不同的是，<code>Call()</code>方法是有返回值的，其类型由我们创建匿名内部类的时候指定泛型。而<code>Callable接口</code>本身并不是<code>Runable</code>的子类，创建线程可以通过该方法是因为：Thread在创建的时候是需要将<code>Runable</code>或其子类传入，其中包含了子类<code>FutureTask</code>这样一个类，在创建这个类时可将Callable接口的实现当做构造参数传进去，以达到创建线程的目的…</p></blockquote></li></ul></li><li><p>💩直接New Thread</p></li><li><p>通过线程池创建…</p></li></ol><hr><p><strong>池化技术</strong></p><blockquote><p>程序运行的本质是：占用OS的资源，而优化资源的使用——&gt;池化技术</p><p>事先准备好一些资源，需要用的话从我这儿拿，用完还我</p></blockquote><p>其优点：</p><ul><li>降低资源的消耗：本质即优化资源的使用效率</li><li>方便线程管理：创建线程池初始化事先线程</li><li>提高响应速度：不用频繁的创建和销毁线程</li></ul><h3 id="线程池的3个Func"><a class="header-anchor" href="#线程池的3个Func">¶</a>线程池的3个Func</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Executor</span> <span class="variable">executor1</span> <span class="operator">=</span> Executors.newSingleThreadExecutor(); -- 单例线程</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor2</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">5</span>); -- 固定线程</span><br><span class="line"><span class="type">Executor</span> <span class="variable">executor3</span> <span class="operator">=</span> Executors.newCachedThreadPool(); --弹性</span><br></pre></td></tr></table></figure><h3 id="线程池的7个参数"><a class="header-anchor" href="#线程池的7个参数">¶</a>线程池的7个参数</h3><p>通过三个Func可以看出来，<code>Executors.newCachedThreadPool(); --弹性</code>这样一个方法是值得我们青睐的，</p><p>其构造方法：</p><img src="C:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20220918095441793.png" alt="image-20220918095441793" style="zoom: 65%;" /><blockquote><p>但是读源码我们可以看到</p></blockquote><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220918094909666.png" alt="image-20220918094909666" style="zoom: 80%;" /><blockquote><p>这里<strong>允许的创建线程数量</strong>是：<code>Integer.MAX_VALUE</code> = 2^31 - 1 ——&gt;<strong>可能会堆积大量的请求，从而导致 OOM！</strong></p></blockquote><p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20220918095025854.png" alt="image-20220918095025854"></p><blockquote><p>这也是阿里巴巴开发手册里面提到的，线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 这样一个原生的方式来创建线程。</p></blockquote><hr><p>归言：其7个参数分别：</p><ol><li>int <code>corePoolSize</code>：<strong>核心线程数</strong></li><li>int <code>maximumPoolSize</code>：<strong>最大创建线程数</strong></li><li>long <code>keepAliveTime</code>：<strong>存活时间</strong></li><li>TimeUnit <code>unit</code>：<strong>Time类管理工具</strong></li><li>BlockingQueue<Runnable> <code>workQueue</code>：指定阻塞队列</li><li>ThreadFactory <code>threadFactory</code>：<strong>线程工厂</strong></li><li>RejectedExecutionHandler <code>handler</code>：<strong>拒绝策略</strong></li></ol><h3 id="线程池的4中拒绝策略"><a class="header-anchor" href="#线程池的4中拒绝策略">¶</a>线程池的4中拒绝策略</h3><ul><li><code>new ThreadPoolExecutor.AbortPolicy()</code> // 银行满了，还有人进来，不处理这个人的，抛出异常</li><li><code>new ThreadPoolExecutor.CallerRunsPolicy()</code> //哪来的去哪里!</li><li><code>new ThreadPoolExecutor.DiscardPolicy()</code> //队列满了，丢掉任务，不会抛出异常!</li><li><code>new ThreadPoolExecutor.DiscardoldestPolicyO()</code> //队列满了，尝试去和最早的竞争，也不会抛出异常!</li></ul><h2 id="📼-JMM"><a class="header-anchor" href="#📼-JMM">¶</a>📼:JMM</h2><blockquote><p>JMM(Java Memory Model)：Java内存模型</p></blockquote><p>它实现了Java程序在各种平台上都能达到一定的并发效果</p><p>每个Java程序都有<strong>主内存</strong>，以及<strong>每条线程的工作内存</strong></p><p>每天线程获取资源都会有相应的交互操作规范：</p><h3 id="8种内存交互模型"><a class="header-anchor" href="#8种内存交互模型">¶</a>8种内存交互模型</h3><ul><li>lock(锁定)，作用于<strong>主内存</strong>中的变量，把变量标识为线程独占的状态。</li><li>read(读取)，作用于<strong>主内存</strong>的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。</li><li>load(加载)，作用于<strong>工作内存</strong>的变量，把read操作主存的变量放入到工作内存的变量副本中。</li><li>use(使用)，作用于<strong>工作内存</strong>的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li><li>assign(赋值)，作用于<strong>工作内存</strong>的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。</li><li>store(存储)，作用于<strong>工作内存</strong>的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。</li><li>write(写入)：作用于<strong>主内存</strong>中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li><li>unlock(解锁)：作用于<strong>主内存</strong>的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li></ul><p>JMM对8种内存交互操作制定的规则：</p><ul><li>不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。</li><li>不允许线程丢弃他最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。</li><li>不允许线程将没有assign的数据从工作内存同步到主内存。</li><li>一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。</li><li>一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。</li><li>如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。</li><li>如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。</li><li>一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。</li></ul><h2 id="Volatile"><a class="header-anchor" href="#Volatile">¶</a>Volatile</h2><blockquote><p><code>Volatile</code>是Jvm虚拟机提供的轻量级的同步机制</p></blockquote><p>特点：</p><ol><li>不保证原子性<ul><li>这里的原子性：<strong>即一个操作或者多个操作，要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。原子性就像数据库里面的事务一样，他们是一个团队，同生共死。</strong></li></ul></li><li>禁止指令重排<ul><li>利用CPU的内存屏障，避免指令重排现象出现</li></ul></li><li>指令可见性<ul><li>当线程还正在消费主线程资源时，资源发生更改，<code>volatile</code>保证<strong>这个更改</strong>及时<strong>通知</strong>到线程</li></ul></li></ol><h2 id="CAS"><a class="header-anchor" href="#CAS">¶</a>CAS</h2><blockquote><p>CAS的全称为<code>compare and swap</code> 或者<code>compare and exchange</code>,意思为比较和交换</p><ul><li>比较：比较当前线程工作内存中的值&lt;——&gt;和主内存中的值</li><li>交换：若为期望——&gt;则执行操作；若不是期望，由于底层是自旋锁，会无线循环</li></ul><p><strong>本质</strong>上即是，对乐观锁思想的实际实现…</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="type">AtomicInteger</span> <span class="variable">integer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">1000</span>);<span class="comment">//原子类</span></span><br><span class="line"><span class="comment">//CAS操作</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">1000</span>, <span class="number">2000</span>));<span class="comment">//true</span></span><br><span class="line">System.out.println(integer.getAndIncrement());<span class="comment">//2000</span></span><br><span class="line">System.out.println(integer);<span class="comment">//2001</span></span><br><span class="line">System.out.println(integer.compareAndSet(<span class="number">1000</span>, <span class="number">2000</span>));<span class="comment">//false</span></span><br></pre></td></tr></table></figure><h3 id="CAS实现原子操作的问题"><a class="header-anchor" href="#CAS实现原子操作的问题">¶</a>CAS实现原子操作的问题</h3><p>ABA问题：</p><blockquote><p>因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了</p></blockquote><p>解决ABA问题：使用带版本号机制的——&gt;原子应用类</p><p><strong>这里仅搬出简单的一类解决方案，类似于乐观锁的思想——&gt;基于版本号控制</strong></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AtomicStampedReference&lt;Integer&gt; atomicReference</span><br><span class="line">                = <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>&lt;Integer&gt;(<span class="number">100</span>, <span class="number">1</span>);</span><br><span class="line"><span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> atomicReference.getStamp();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(e);</span><br><span class="line">    &#125;</span><br><span class="line">    atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">102</span></span><br><span class="line">            , atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line"></span><br><span class="line">    atomicReference.compareAndSet(<span class="number">102</span>, <span class="number">100</span></span><br><span class="line">            , atomicReference.getStamp(), atomicReference.getStamp() + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line"></span><br><span class="line">&#125;, <span class="string">&quot;A&quot;</span>).start();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"></span><br><span class="line">    atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">105</span></span><br><span class="line">            , stamp, stamp + <span class="number">1</span>);</span><br><span class="line">    System.out.println(atomicReference.getStamp());</span><br><span class="line">    System.out.println(atomicReference.getReference());</span><br><span class="line">&#125;, <span class="string">&quot;B&quot;</span>).start();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Tech-Stuck </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUC </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
