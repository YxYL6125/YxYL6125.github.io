<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="并发和并行这两种动作的目标总的来说就是最大化CPU的使用率">
<meta property="og:type" content="website">
<meta property="og:title" content="JMM与并发三大特性">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/JMM%E4%B8%8E%E5%B9%B6%E5%8F%91%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="并发和并行这两种动作的目标总的来说就是最大化CPU的使用率">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214091941422.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214092607126.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214192330065.png">
<meta property="article:published_time" content="2022-12-12T02:06:19.000Z">
<meta property="article:modified_time" content="2022-12-12T02:06:19.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="TODO-LIST">
<meta property="article:tag" content="JMM">
<meta property="article:tag" content="并发编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214091941422.png">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>JMM与并发三大特性</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h2 id="并发和并行"><a class="header-anchor" href="#并发和并行">¶</a>并发和并行</h2>
<p>这两种动作的目标总的来说就是</p>
<blockquote>
<p>最大化CPU的使用率</p>
</blockquote>
<h3 id="并行"><a class="header-anchor" href="#并行">¶</a>并行</h3>
<p>并行指的是在同一时刻，有<strong>多条指令</strong>在<strong>多个处理器</strong>上同时执行，所以无论是在宏观还是在微观上，两者都是一起执行的</p>
<h3 id="并发-Concurrency"><a class="header-anchor" href="#并发-Concurrency">¶</a>并发(Concurrency)</h3>
<p>并发指的是在同一时刻只能有一条指令执行，但多个线程指令被迅速的轮换执行，使得在宏观上好像是具有多个进程在同时执行的效果，但是在微观上并不是多个在同时执行，只是时间分成若干段，是多个进程快速交替的执行</p>
<hr>
<p>看的出，并行是真的有两个CPU在跑，而并发是只有一个CPU在跑，只是跑的进程在快速的交替执行。</p>
<p>并行在多CPU系统中存在，而并发可以在单处理器系统和多处理器系统中都存在。</p>
<p>并发能够在单处理器系统中存在是因为并发是并行的假象，并行要求程序能够同时执行多个操作，而并发只是要求程序假装同时只执行多个操作</p>
<h2 id="并发三大特性"><a class="header-anchor" href="#并发三大特性">¶</a>并发三大特性</h2>
<p>并发编程Bug的源头：可见性、原子性、有序性</p>
<h3 id="可见性"><a class="header-anchor" href="#可见性">¶</a>可见性</h3>
<blockquote>
<p>当一个线程修改了<strong>共享资源</strong>的值，其他线程能够看到修改的值</p>
</blockquote>
<p>Java内存模型 (<code>JMM</code>)是通过在变量修改后将新值同步会主存，在变量读取之前从主存刷新变量值这种依赖主存作为传递媒介的方法来实现可见性的</p>
<h4 id="如何保证可见性"><a class="header-anchor" href="#如何保证可见性">¶</a>如何保证可见性</h4>
<ul>
<li>通过<code>volatile</code>关键字保证可见性</li>
<li>通过内存屏障保证可见性</li>
<li>通过<code>synchronized</code>关键字保证可见性</li>
<li>通过Lock保证可见性</li>
<li>通过<code>final</code>关键字保证可见性</li>
</ul>
<h3 id="有序性"><a class="header-anchor" href="#有序性">¶</a>有序性</h3>
<blockquote>
<p>即程序执行代码的顺序按照代码的先后顺序执行</p>
</blockquote>
<p>由于<code>JVM</code>存在<strong>指令重排</strong>，所以存在有序性问题</p>
<h4 id="如何保证有序性"><a class="header-anchor" href="#如何保证有序性">¶</a>如何保证有序性</h4>
<ul>
<li>通过<code>volatile</code>关键字保证有序性</li>
<li>通过内存屏障保证有序性</li>
<li>通过<code>synchronized</code>关键字保证有序性</li>
<li>通过Lock保证有序性</li>
</ul>
<h3 id="原子性"><a class="header-anchor" href="#原子性">¶</a>原子性</h3>
<blockquote>
<p>一个或多个操作</p>
<p>要么全部执行且在执行的过程中不能被任何元素打断</p>
<p>要么全部不执行</p>
<hr>
<p>梦回开哥……(<strong>LBWNB(撕心裂肺)</strong>)</p>
<p>：一个人谈恋爱</p>
<p>：出轨的次数只有</p>
<p>：0</p>
<p>：和</p>
<p>：N</p>
</blockquote>
<p>在Java当中，对基本数据类型的变量的读取和赋值的操作是原子性操作(64位)，如果不采取任何原子性保障措施的自增操作并不是原子性的，存在原子性问题</p>
<h3 id="如何保证原子性"><a class="header-anchor" href="#如何保证原子性">¶</a>如何保证原子性</h3>
<ul>
<li>通过<code>synchronized</code>关键字保证原子性</li>
<li>通过Lock保证原子性</li>
<li>通过CAS保证原子性</li>
</ul>
<h2 id="Java内存模型-JMM"><a class="header-anchor" href="#Java内存模型-JMM">¶</a>Java内存模型(JMM)</h2>
<blockquote>
<p>JVM规范定义了一个Java内存模型(Java Memory Model)，即JMM。</p>
<p>用于屏蔽掉各种硬件的OS的内存访问差异，以让Java程序在各种平台下都能达到一致的并发效果，JMM规范了JVM和计算机内存是如何协同工作的：</p>
<p>规定了一个线程如何、以及何时可以看到有其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量</p>
</blockquote>
<p>这里给出JMM的模型图</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214091941422.png" alt="image-20221214091941422"></p>
<h3 id="内存交互操作"><a class="header-anchor" href="#内存交互操作">¶</a>内存交互操作</h3>
<p>关于<strong>主内存</strong>和<strong>工作内存</strong>之间的交互协议，即：</p>
<ul>
<li>一个变量如何存主内存中拷贝到工作内存、</li>
<li>如何从工作内存同步到主内存之间的实现细节</li>
</ul>
<p>JMM定义了八种操作来完成：</p>
<ul>
<li>lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。</li>
<li>unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要<strong>使用变量的值</strong>的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个<strong>给变量赋值</strong>的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。</li>
</ul>
<p>将上图改造一下：</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214092607126.png" alt="image-20221214092607126"></p>
<p>JVM还规定了，再执行上述8种操作的时候，必须满足一下规则：</p>
<ul>
<li>如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作， 如果把变量从工作内存中同步回主内存中，就要按顺序地执行<code>store</code>和<code>write</code>操作。 但Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。</li>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现</li>
<li>不允许一个线程丢弃它的最近<code>assign</code>的操作，即变量在工作内存中改变了之后必须同步到主内存中。</li>
<li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量。即就是对一个变量实施<code>use</code>和<code>store</code>操作之前，必须先执行过 了<code>assign</code>和<code>load</code>操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。</li>
<li><code>lock</code>和<code>unlock</code>必须成对出现</li>
<li>如果对一个变量执行<code>lock</code>操作，将会清空工作内存中此变量的值，在执行引擎使用 这个变量前需要重新执行load或assign操作初始化变量的值</li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，则不允许对它执行<code>unlock</code>操作；也不允许去<code>unlock</code>一个被其他线程锁定的变量。</li>
<li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步到主内存中（执行store和 write操作）。</li>
</ul>
<h2 id="volatile"><a class="header-anchor" href="#volatile">¶</a>volatile</h2>
<h3 id="volatile的特性"><a class="header-anchor" href="#volatile的特性">¶</a>volatile的特性</h3>
<ul>
<li>可见性：对于一个<code>volatile</code>变脸的读操作，总是能看到(任意线程)对这个<code>volatile</code>变量最后的写操作</li>
<li>原子性：对任意单个<code>volatile</code>变量的读/写操作具有原子性，但类似于volatile++这种符合操作不具有原子性，<strong>(基于这点，我们通常会认为volatile不具有原子性)</strong>。volatile仅仅保障对单个volatile变量的读/写操作具有原子性，而锁的互斥执行h的特性可以确保对整个临界区代码的执行具有原子性</li>
<li>有序性：对volatile修饰的变量的读写操作前后加上各种特定的<strong>内存屏障</strong>来禁止指令重排序来保证有序性</li>
</ul>
<h3 id="volatile写-读的内存语义"><a class="header-anchor" href="#volatile写-读的内存语义">¶</a>volatile写-读的内存语义</h3>
<ul>
<li>当<strong>写</strong>一个volatile变量时，JMM会把该线程对应的<strong>本地内存</strong>中的<strong>共享变量值刷新到主内存</strong></li>
<li>当<strong>读</strong>一个volatile变量时，JMM会把该线程对应的<strong>本地内存</strong>置为<strong>无效</strong>，线程接下来将从主内存中读取共享变量</li>
</ul>
<h3 id="volatile的可见性实现"><a class="header-anchor" href="#volatile的可见性实现">¶</a>volatile的可见性实现</h3>
<p>volatile修饰的变量的read、load、use操作和assign、store、write操作必须是连续的<br>
即修改后必须立即同步回主内存，使用时必须从主内存刷新。</p>
<p>由此保证volatile变量操作对多线程的可见性</p>
<h4 id="硬件层面的实现"><a class="header-anchor" href="#硬件层面的实现">¶</a>硬件层面的实现</h4>
<p>通过lock前缀指令，volatile变量的操作会锁定变量<strong>缓存行</strong>区域并写回主内存，这个操作被称之为：“缓存锁定”。缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存会导致其他处理器的缓存无效</p>
<h4 id="lock前缀指令的作用"><a class="header-anchor" href="#lock前缀指令的作用">¶</a>lock前缀指令的作用</h4>
<ol>
<li>确保后续指令执行的原子性。在Pentium及其之前的处理器中，带有lock前缀的指令在执行期间会锁住总线，使得其他线程无法对总线程进行访问，很显然这样做的开销十分巨大。<br>
在新的处理器中，Inter使用缓存锁定来保证指令执行的原子性，缓存锁定将大大地减低了lock前缀指令的执行开销。因为，与锁住总线不同，缓存锁定只是<strong>锁定变量缓存行区域</strong>……</li>
<li>lock前缀指令具有类似于内存屏障的功能，禁止指令与前面和后面的读写指令重排序(指令重排)</li>
<li>lock前缀指令会等待他之前所有的指令完成、并且所有缓冲的的写操作写回内存(也就是将store buffer中的内容写入内存)之后才开始执行，并且根据缓存一致性协议，刷新store buffer的操作会导致其他cache中的副本失效</li>
</ol>
<blockquote>
<p>这里的lock前缀指令：</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/sunddenly/articles/14829255.html">Lock指令作用</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2171e180bdbd">Lock指令前缀</a></p>
</blockquote>
<h2 id="指令重排序"><a class="header-anchor" href="#指令重排序">¶</a>指令重排序</h2>
<blockquote>
<p>Java语言规范规定<code>JVM线程内部维持顺序化语义</code>(什么逆天命名)<br>
即，只要程序的最终结果与它顺序话情况的结果相等，那么指令的执行顺序可与代码顺序不一致，这个过程叫做指令的重排序——也叫指令重排</p>
</blockquote>
<p>指令重排的意义：</p>
<blockquote>
<p>JVM能根据处理器的特性(CPU多级缓存系统、多核处理器……)适当的对机器指令进行重排序，是的机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。</p>
<p>在编译器与CPU处理器中都能执行指令重排优化</p>
<p>即下图</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221214192330065.png" alt="image-20221214192330065"></p>
<h3 id="volatile指令重排规则"><a class="header-anchor" href="#volatile指令重排规则">¶</a>volatile指令重排规则</h3>
<table>
<thead>
<tr>
<th>是否能重排序</th>
<th>第二个操作</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>第一个操作</td>
<td>普通读/写</td>
<td>volatile读</td>
<td>volatile写</td>
</tr>
<tr>
<td>普通读/写</td>
<td></td>
<td></td>
<td>NO</td>
</tr>
<tr>
<td>volatile读</td>
<td>NO</td>
<td>NO</td>
<td>NO</td>
</tr>
<tr>
<td>volatile写</td>
<td></td>
<td>NO</td>
<td>NO</td>
</tr>
</tbody>
</table>
<p>volatile禁止指令重序的场景：</p>
<ol>
<li>第二个操作是volatile写，都不会出现指令重排</li>
<li>第一个操作是volatile读，都不会出现指令重排</li>
<li>第一个操作是volatile写，第二个操作是volatile读，不会发生指令重排</li>
</ol>
<p>总结：</p>
<p>这次写的很多东西其实都挺浅的，没有发展到汇编层面，(有没有可能是自己都没有记住💩)，还有内存屏障，MESI……</p>
<p>等以后沉淀够了再来补</p>
<p>落：2022-12-14 19:34:45</p>
<blockquote>
<p>可以看看CoderW的这篇文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/7109464558783168526">关于缓存一致性协议、MESI、StoreBuffer、InvalidateQueue、内存屏障、Lock指令和JMM的那点事</a></p>
</blockquote>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
