<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="GC垃圾回收">
<meta property="og:type" content="website">
<meta property="og:title" content="JVM垃圾回收">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="GC垃圾回收">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200451419.png">
<meta property="og:image" content="c:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20230104195701973.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104195726124.png">
<meta property="og:image" content="c:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20230104200047594.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200104614.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200318187.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200341802.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104201742420.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104203621430.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104203928994.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104204833414.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230105135738963.png">
<meta property="article:published_time" content="2023-01-04T11:50:16.000Z">
<meta property="article:modified_time" content="2023-01-05T06:40:37.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="垃圾回收">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200451419.png">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>JVM垃圾回收</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <p><img src="" alt=""></p>
<h2 id="垃圾收集算法"><a class="header-anchor" href="#垃圾收集算法">¶</a>垃圾收集算法</h2>
<p><strong>丢图</strong></p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200451419.png" alt="image-20230104200451419"></p>
<h3 id="分代收集"><a class="header-anchor" href="#分代收集">¶</a>分代收集</h3>
<p>当前的虚拟机的垃圾手机都采用分代手收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将Java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</p>
<h3 id="标记-复制算法"><a class="header-anchor" href="#标记-复制算法">¶</a>标记-复制算法</h3>
<p>为了解决效率问题，&quot;复制&quot;收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存被使用完后，就将对象(存活的)复制到另一块去，然后吧这一块内存空间给清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收</p>
<p><strong>内存整理前：</strong></p>
<p><img src="C:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20230104195701973.png" alt="image-20230104195701973"></p>
<p><strong>内存整理后：</strong></p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104195726124.png" alt="image-20230104195726124"></p>
<h3 id="标记-清除算法"><a class="header-anchor" href="#标记-清除算法">¶</a>标记-清除算法</h3>
<p>算法分为&quot;标记&quot;和&quot;清除&quot;阶段：</p>
<blockquote>
<p>标记存活的对象，统一回收没有被标记的对象(一般选择这种)；</p>
<p>也可以反过来，</p>
</blockquote>
<p>它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p>
<ul>
<li>效率问题(如果需要标记的对象太多，效率不高)</li>
<li>空间问题(标记清除后会产生大量不连续的碎片)</li>
</ul>
<p><strong>内存整理前：</strong></p>
<p><img src="C:/Users/%E9%9B%B7%E7%A5%9E%E6%88%98%E6%9C%BA/AppData/Roaming/Typora/typora-user-images/image-20230104200047594.png" alt="image-20230104200047594"></p>
<p><strong>内存整理后：</strong></p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200104614.png" alt="image-20230104200104614"></p>
<h3 id="标记-整理算法"><a class="header-anchor" href="#标记-整理算法">¶</a>标记-整理算法</h3>
<p>根据老年代的特点特出的一种标记算法，标记过程任然与**&quot;标记-清除&quot;算法**一样，但是后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</p>
<p><strong>回收前的状态：</strong></p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200318187.png" alt="image-20230104200318187"></p>
<p><strong>回收后的状态：</strong></p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104200341802.png" alt="image-20230104200341802"></p>
<h2 id="垃圾收集器"><a class="header-anchor" href="#垃圾收集器">¶</a>垃圾收集器</h2>
<blockquote>
<p>如果说收集算法是内存回收的方法论的话，那么垃圾收集器就是内存回收的具体实现</p>
</blockquote>
<p>直到现在都还没出现最好的垃圾收集器，更没有万能的垃圾收集器，我们能做的就是根据具体应用场景，选择适当前业务，流量的垃圾收集器</p>
<h3 id="Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a class="header-anchor" href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC">¶</a>Serial收集器(<code>-XX:+UseSerialGC -XX:+UseSerialOldGC</code>)</h3>
<p>**Seiral(串行)**收集器是最基本、历史最悠久的垃圾收集器了</p>
<p>看名字就知道，他是一个单线程收集器了。他的**&quot;单线程&quot;<strong>的意义不仅仅意味着他只会使用一条垃圾收集线程去完成垃圾收集任务，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程</strong>(STW)**，直到它结束收集</p>
<blockquote>
<p>新生代采用<strong>复制算法</strong></p>
<p>老年代采用<strong>标记-整理算法</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104201742420.png" alt="image-20230104201742420"></p>
<p>它比其他收集器的优点在于：</p>
<blockquote>
<p>简单而高效：Serial收集器由于没有线程交互的开销，自然可以获得高效的处理速度</p>
</blockquote>
<h3 id="Parallel-Scavenge收集器-XX-UseParallelGC-XX-UseParallelOldGC"><a class="header-anchor" href="#Parallel-Scavenge收集器-XX-UseParallelGC-XX-UseParallelOldGC">¶</a>Parallel Scavenge收集器(<code>-XX:UseParallelGC, -XX:+UseParallelOldGC</code>)</h3>
<p><strong>Parallel收集器就是Serial收集器的多线程版本</strong>，除了使用多线程进行垃圾收集之外，其余行为(参数控制、收集算法、回收策略等等)和<strong>Serial收集器</strong>类似。默认的收集器线程跟CPU合数相同，当然也可以用参数(<code>-XX:ParallelGcThreads</code>)指定收集线程数，但是一般不建议这样做</p>
<blockquote>
<p>Parallel收集器关注点是吞吐量(高效率使用 <strong>CPU</strong> )。</p>
<p>而CMS等垃圾收集器的关注点更多的实在用户线程的停顿时间(提高用户体验)</p>
</blockquote>
<p>Parallel收集器提供了很多参数供用户找到最合适的停顿时间或者最大的吞吐量</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104203621430.png" alt="image-20230104203621430"></p>
<h3 id="ParNew收集器-XX-UseParNewGC"><a class="header-anchor" href="#ParNew收集器-XX-UseParNewGC">¶</a>ParNew收集器(<code>-XX:+UseParNewGC</code>)</h3>
<p><strong>ParNew收集器</strong>其实跟Parallel收集器很类似，区别主要在于它可以和CMS收集器配合使用。</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104203928994.png" alt="image-20230104203928994"></p>
<p>他是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有ParNew收集器才能与CMS收集器配合工作</p>
<h3 id="CMS收集器-XX-UseConcMarkSweepGC"><a class="header-anchor" href="#CMS收集器-XX-UseConcMarkSweepGC">¶</a>CMS收集器(<code>-XX:+UseConcMarkSweepGC</code>)</h3>
<p>CMS(Concurrent Mark Sweep)收集器是种获得最短回收停顿时间为目标的收集器。</p>
<p>他非常符合在注重用户体验的应用上的使用，他是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程(基本上)同时工作</p>
<p>整个过程分为四个步骤：</p>
<ul>
<li>初始标记：暂停所有线程(STW)，并记录下<strong>GC Roots</strong>直接能引用的对象，速度很快*</li>
<li>并发标记：并发标记阶段是从<strong>GC Roots</strong>的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。因为用户线程继续运行，可能会有导致已经标记过的对象状态发生改变。</li>
<li>重新标记：这个阶段就是为了修正上个阶段因为用户线程继续运行而导致产生变动的那一部分对象的标记记录，这个阶段的定顿时间一般会比<strong>初始标记阶段</strong>的时间长一点，远远比<strong>并发标记阶段</strong>的时间短。主要用到<strong>三色标记</strong>里的<strong>更新算法</strong>做<strong>重新标记</strong></li>
<li>并发重置：重置本次GC过程中的标记数据。(GC<img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230104204833414.png" alt="image-20230104204833414"></li>
</ul>
<p>从他的名字就可以看出他是一款优秀的垃圾收集器</p>
<p>主要优点：</p>
<ul>
<li>并发收集</li>
<li>低停顿</li>
</ul>
<p>但是他有以下几个明显的缺点：</p>
<ul>
<li>
<p>对CPU资源敏感(会和服务抢资源)：因为并发过程，要与用户线程一起运行，必然占部分资源</p>
</li>
<li>
<p>无法处理<strong>浮动垃圾</strong>(在并发标记和并发清理阶段又产生垃圾，这种浮动垃圾只能等到下一次GC再清理了)</p>
</li>
<li>
<p>他使用的回收算法——<strong>&quot;标记-清除&quot;算法</strong>会导致在收集结束的时候会有大量空间碎片产生</p>
<p>当然，可以通过参数：<strong><code>-XX:+UseCMSCompactAtFullCollection</code><strong>可以让</strong>jvm</strong>在<strong>执行完标记清除完再做整理</strong></p>
</li>
<li>
<p>执行过程中的不确定性：会存在上一次垃圾回收还没有执行完，然后垃圾回收又被触发的情况，特别是在<strong>并发标记和并发清理的阶段</strong>会出现</p>
</li>
</ul>
<p>一些CMS核心参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> -XX:+UseConcMarkSweepGC：启用cms</span><br><span class="line"><span class="number">2.</span> -XX:ConcGCThreads：并发的GC线程数</span><br><span class="line"><span class="number">3.</span> -XX:+UseCMSCompactAtFullCollection：FullGC之后做压缩整理（减少碎片）</span><br><span class="line"><span class="number">4.</span> -XX:CMSFullGCsBeforeCompaction：多少次FullGC之后压缩一次，默认是<span class="number">0</span>，代表每次FullGC后都会压缩一</span><br><span class="line">次</span><br><span class="line"><span class="number">5.</span> -XX:CMSInitiatingOccupancyFraction: 当老年代使用达到该比例时会触发FullGC（默认是<span class="number">92</span>，这是百分比）</span><br><span class="line"><span class="number">6.</span> -XX:+UseCMSInitiatingOccupancyOnly：只使用设定的回收阈值(-XX:CMSInitiatingOccupancyFraction设</span><br><span class="line">定的值)，如果不指定，JVM仅在第一次使用设定值，后续则会自动调整</span><br><span class="line"><span class="number">7.</span> -XX:+CMSScavengeBeforeRemark：在CMS GC前启动一次minor gc，目的在于减少老年代对年轻代的引</span><br><span class="line">用，降低CMS GC的标记阶段时的开销，一般CMS的GC耗时 <span class="number">80</span>%都在标记阶段</span><br><span class="line"><span class="number">8.</span> -XX:+CMSParallellnitialMarkEnabled：表示在初始标记的时候多线程执行，缩短STW</span><br><span class="line"><span class="number">9.</span> -XX:+CMSParallelRemarkEnabled：在重新标记的时候多线程执行，缩短STW;</span><br></pre></td></tr></table></figure>
<h2 id="垃圾收集底层算法实现"><a class="header-anchor" href="#垃圾收集底层算法实现">¶</a>垃圾收集底层算法实现</h2>
<h3 id="三色标记"><a class="header-anchor" href="#三色标记">¶</a>三色标记</h3>
<p>在并发标记的过程中(CMS收集器)，因为标记期间应用线程还在继续跑，对象键的引用可能发生变化，<strong>多标</strong>和<strong>漏标</strong>的情况就可能发生。</p>
<p>所以这里就引入了**“三色标记”**的概念</p>
<p>吧GcRoots可达性分析遍历对象过程中遇到的对象，按照**“是否访问过”**这个条件标记记成以下三种颜色：</p>
<ul>
<li><strong>黑色</strong>：表示这个对象已经被垃圾收集器访问过了，并且这个对象的所有引用都已经被扫描过了。黑色的对象表示已经扫描过，是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象</li>
<li><strong>灰色</strong>：表示这个对象被垃圾收集器访问过，但是这个对象上至少存在一个引用还没有被扫描过</li>
<li><strong>白色</strong>：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，任然是白色的对象，那么说明这个对象是不可达的，可以被回收</li>
</ul>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230105135738963.png" alt="image-20230105135738963"></p>
<h4 id="多标-浮动垃圾"><a class="header-anchor" href="#多标-浮动垃圾">¶</a>多标-浮动垃圾</h4>
<p>在并发标记过程中，如果由于方法运行结束导致<strong>部分局部标量(GcRoot)<strong>被销毁，这个</strong>GCRoot</strong>引用的对象之前又被扫描过(被标记为非垃圾对象)，那么本轮GC不会回收这部分内存。这部分本应该回收但是没有回收到的内存，被称之为：<strong>“浮动垃圾”</strong>、浮动垃圾并不会影响垃圾回收的正确性，只是需要等到下一轮垃圾回收中才被清除。</p>
<p>另外，<strong>针对并发标记(还有并发清理)开始后产生的新对象，通常的做法是直接全部当成黑色</strong>，本轮不会进行清除。这部分对象期间可能也会变成垃圾，这也算是浮动垃圾的一部分</p>
<h4 id="漏标-读写屏障"><a class="header-anchor" href="#漏标-读写屏障">¶</a>漏标-读写屏障</h4>
<p>漏标就会导致被引用的对象被当做垃圾被误清理，<strong>这是很严重的bug</strong>。有两种解决方案：<strong>增量更新(Incremental Update) 和 原始快照(SnapShot At The Beginning，SATB)</strong></p>
<ul>
<li><strong>增量更新</strong>：就是当黑色对象插入新的指向白色对象的引用关系时，就将这个新插入的引用记录下来，等并发结束之后，再将这些记录过的引用关系中的黑色对象为<strong>root</strong>，重新扫描一次(<strong>重新标记阶段</strong>)，这样就能扫描到白色的对象。这可以简化理解为：<strong>黑色对象一旦插入了指向白色对象的引用之后，他就变回灰色对象了。</strong></li>
<li><strong>原始快照</strong>：就是当灰色对象要删除指向白色对象的引用关系的时候，就要将这个要删除的引用记录下来，在并发扫描结束之后之后，再将这些记录过的引用关系中的灰色对象为root，重新扫描一下，这样就能扫描到白色的对象，将白色对象直接标记为黑色(<strong>目的就是让这种对象在本轮gc清理中存活下来，等待下一轮gc的时候重新扫描，这个对象也有可能是浮动垃圾</strong>)</li>
</ul>
<p>以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过<strong>写屏障</strong>实现的。</p>
<h4 id="写屏障"><a class="header-anchor" href="#写屏障">¶</a>写屏障</h4>
<p>给某个对象的成员变量赋值的时候，其底层代码大概长这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> field 某对象的成员变量，如 a.b.d</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> new_value 新值，如 null</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> &#123;</span><br><span class="line">	*field = new_value; <span class="comment">// 赋值操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所谓的写屏障，就是指在赋值操作前后，加入一些处理(可以理解AOP的概念)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">oop_field_store</span><span class="params">(oop* field, oop new_value)</span> &#123;</span><br><span class="line">    pre_write_barrier(field); <span class="comment">// 写屏障‐写前操作</span></span><br><span class="line">    *field = new_value;</span><br><span class="line">    post_write_barrier(field, value); <span class="comment">// 写屏障‐写后操作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>写屏障实现SATB<br>
当对象B的成员变量的引用发生变化时，比如引用小时(<code>z.b.d = null</code>)，我们可以利用写屏障，将B原来的成员变量对象D给记录下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">pre_write_barrier</span><span class="params">(oop* field)</span> &#123;</span><br><span class="line">    <span class="type">oop</span> <span class="variable">old_value</span> <span class="operator">=</span> *field; <span class="comment">// 获取旧值</span></span><br><span class="line">    remark_set.add(old_value); <span class="comment">// 记录原来的引用对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>写屏障实现增量更新<br>
当对象A的成员变量的引用发生变化的时候，比如新增引用(<code>a.d = d</code>)，我们可以利用写屏障，将A新的成员变量引用对象D给记录下来：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">post_write_barrier</span><span class="params">(oop* field, oop new_value)</span> &#123;</span><br><span class="line">    remark_set.add(new_value); <span class="comment">// 记录新引用的对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
