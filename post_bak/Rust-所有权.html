<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="在所有程序执行过程中，与计算机内存的暧昧行为早已被默认。">
<meta property="og:type" content="website">
<meta property="og:title" content="Rust-所有权">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/Rust-%E6%89%80%E6%9C%89%E6%9D%83.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="在所有程序执行过程中，与计算机内存的暧昧行为早已被默认。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-03T06:16:29.000Z">
<meta property="article:modified_time" content="2022-10-04T11:41:07.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="Rust">
<meta name="twitter:card" content="summary">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>Rust-所有权</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <p>在所有程序执行过程中，与计算机内存的暧昧行为早已被默认。但如何与其保持着敌进我退，敌退我进的距离，——在内存中申请内存来执行程序；在执行完过后，不需要的时候再释放这段内存，成为了重中之重。这也是设计编程语言过程中的一座高山。于是，三种主流的模式应运而生：</p>
<ul>
<li>
<p>GC：垃圾回收机制，在程序运行的同时，无时无刻的想办法找那些不被利用，并且以后也不再使用的内存，回收起来，例如最经典的Java(Jvm)，Go，C#</p>
</li>
<li>
<p>显示操作：回收，申请内存这些操作改成了由程序员自己手动操作，(比起GC的耗性能，我果然还是接收不了自己手动操作对象空间的申请与释放)，C++</p>
</li>
<li>
<blockquote>
<p><strong>通过所有权来管理内存</strong>，编译器在编译时会根据一系列规则进行检查(这里就直接把原话复制过来吧)</p>
</blockquote>
</li>
</ul>
<p>而Rust正好就是第三种，对内存的管理机制——<strong>所有权</strong></p>
<p>这种机制，早在编译的时候就确立好了这段内存由谁来支配，大大的挽回了内存的损失。</p>
<hr>
<p>在说所有权之前先谈谈栈和堆吧</p>
<h3 id="栈、堆"><a class="header-anchor" href="#栈、堆">¶</a>栈、堆</h3>
<ul>
<li>
<p>栈</p>
<blockquote>
<p>这个东西，数据结构的角度看栈和队列也是线性表，其特殊性在于栈和队列的基本操作是线性表的子集。他们是操作受限的线性表…</p>
<p>栈按照顺序存储值并以相反顺序取出值，这也被称作<strong>后进先出</strong>。出于这样的存储方式，在栈中的数据必须有明确的大小，并且在之后的操作中不得改变(明确，固定)，假设数据是未知的，那么在取出数据时，将无法获取想要的数据。</p>
</blockquote>
</li>
<li>
<p>堆</p>
<blockquote>
<p>相对于栈，我们(哪儿来的们🐟)对堆的认识往往并不多，可能是出于平常使用的编程语言并不要求我们对栈堆有多大的掌握。扯远了…</p>
<p>与栈不同，对于未知数据的存储，我们需要将它存到堆中。在存数据的过程中，OS首先在堆中找到一份它觉得合适大小的空间，将它标记为——&gt;已使用，并返回这段空间的指针地址，该过程称之为——&gt;<strong>分配</strong>。接着，让数据占用这段空间。</p>
<p>当我们访问这段空间想拿到数据时，只需要找到刚刚被分配到栈中的指针，去找地址就好了。</p>
<p>(这个例子以后还会提到)就好像我们去餐厅吃饭，服务员问我们几个人，我们说6个，那她就会带我们去大概6 7个位置左右的餐桌，这个过程就是分配。完了过后，要是有人迟到了，想找到我们，只需要我们发短信给他一个餐桌号，他就可以顺利的找到我们，这个过程就是拿数据。</p>
</blockquote>
</li>
</ul>
<h3 id="所有权机制"><a class="header-anchor" href="#所有权机制">¶</a><strong>所有权机制</strong></h3>
<blockquote>
<ul>
<li>Rust 中每一个值都被一个变量所拥有，该变量被称为值的所有者</li>
<li>一个值同时只能被一个变量所拥有，或者说一个值只能拥有一个所有者</li>
<li>当所有者(变量)离开作用域范围时，这个值将被丢弃(drop)</li>
</ul>
</blockquote>
<h3 id="浅谈一下String"><a class="header-anchor" href="#浅谈一下String">¶</a>浅谈一下String</h3>
<p>在rust里面，当我们在编译器里输入<code>let s =&quot;hello&quot;</code>时，s这个变量是直接被硬编码到程序里面去的(类型为：<code>&amp;str</code>)，也叫作<strong>字符串字面量</strong>，字符串字面量是很方便的，但是在有些时候，这个方便并没有体现到位，原因是：</p>
<ul>
<li>由于是直接被硬编码到程序当中去，所以他是不可变的</li>
<li>并非所有字面量都能在编写代码的时候得知他的值</li>
</ul>
<p>于是就有了动态字符串类型：<code>String</code></p>
<p>这个类型被分配到堆空间上，所以可以动态的伸缩，也就可以存储位置大小的文本。</p>
<p>在rust中，想要得到一个String类型的变量很简单：<code>let s = String::new(&quot;yxyl&quot;);</code></p>
<h3 id="浅拷贝和深拷贝"><a class="header-anchor" href="#浅拷贝和深拷贝">¶</a>浅拷贝和深拷贝</h3>
<h4 id="拷贝-浅拷贝"><a class="header-anchor" href="#拷贝-浅拷贝">¶</a>(拷贝)浅拷贝</h4>
<p>先讲讲浅拷贝吧，浅拷贝只是发生在栈上，因此，性能很高，就比如：</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="variable">y</span> = x;</span><br></pre></td></tr></table></figure>
<p>这段代码就是很实在的浅拷贝，因为整形这个数据类型大小是已知的，会被存储在栈上，所以浅拷贝也是快速的、这意味着没有理由在创建<code>y</code>过后，<code>x</code>失效</p>
<h4 id="克隆-深拷贝"><a class="header-anchor" href="#克隆-深拷贝">¶</a>(克隆)深拷贝</h4>
<p>没有人会做出有损自己利益的事情，rust也一样，rust不会主动进行数据的深拷贝，他是低效且耗性能的，就像如果想要复制String类型的变量时候，通常会用<code>clone()</code>这样一个方法，他不仅仅是复制栈上的数据，深度copy了堆上的数据。</p>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
