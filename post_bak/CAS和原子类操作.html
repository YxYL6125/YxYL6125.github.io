<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="CAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。">
<meta property="og:type" content="website">
<meta property="og:title" content="CAS和原子类操作">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/CAS%E5%92%8C%E5%8E%9F%E5%AD%90%E7%B1%BB%E6%93%8D%E4%BD%9C.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="CAS（Compare And Swap，比较并交换），通常指的是这样一种原子操作：针对一个变量，首先比较它的内存值与某个期望值是否相同，如果相同，就给它赋一个新值。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219093920543.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219190644368.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219191150048.png">
<meta property="article:published_time" content="2022-12-19T01:02:12.000Z">
<meta property="article:modified_time" content="2022-12-20T10:53:36.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="TODO-LIST">
<meta property="article:tag" content="CAS">
<meta property="article:tag" content="原子类操作">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219093920543.png">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>CAS和原子类操作</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h2 id="什么是CAS"><a class="header-anchor" href="#什么是CAS">¶</a>什么是CAS</h2>
<p>CAS(Compare And Swap，比较并交换)，通常指的是这样一种原子操作：</p>
<blockquote>
<p>针对一个变量，首先先比较他的内存值与某个期望值是否相同，如果相同，就给他赋一个新值</p>
</blockquote>
<p>CAS的逻辑用伪代码描述如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(value == expectedValue)&#123;</span><br><span class="line">	value = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>CAS可以看做是他们合并后的整体——一个不可分割的原子操作，并且起原子性是直接在硬件层面得到保障的</li>
<li>CAS课看做是乐观锁(对比数据库的悲观、乐观锁)的一种实现方式，Java原子类中的递增操作就通过CAS自旋实现</li>
<li>CAS是一种无锁算法，在不使用锁(没有线程被阻塞)的情况下实现多线程之间的变量同步</li>
</ul>
<h2 id="CAS应用"><a class="header-anchor" href="#CAS应用">¶</a>CAS应用</h2>
<p>在Java中，CAS操作是有<code>Unsafe</code>类提供支持的，该类定义了三种针对不同类型变量的CAS操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapObject</span><span class="params">(Object var1,<span class="type">long</span> var2,Object var4,Object var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapInt</span><span class="params">(Object var1,<span class="type">long</span> var2,<span class="type">int</span> var4,<span class="type">int</span> var5)</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="type">boolean</span> <span class="title function_">compareAndSwapLong</span><span class="params">(Object var1,<span class="type">long</span> var2,<span class="type">long</span> var4,<span class="type">long</span> var5)</span>;</span><br></pre></td></tr></table></figure>
<p>他们都是<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1744704">native方法</a>，由Java虚拟机提供具体实现，这意味着不同的Java虚拟机对他们的实现可能会略有不同。</p>
<p>以<code>compareAndSwapInt</code>为例，<code>Unsafe</code>的<code>compareAndSwapInt</code>方法接收4个参数，分别是：</p>
<ol>
<li>对象实例</li>
<li>内存偏移量(有header的8个字节+x86机器的压缩指针粘的4个字节+对象存储数据本身的字节数，再添上对齐所需要的字节数使之成为8的整数倍)</li>
<li>字段期望值</li>
<li>字段新值</li>
</ol>
<p>这个方法会针对指定对象实例中的对应偏移量的字段执行CAS操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CASTest</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Entity</span> <span class="variable">entity</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Entity</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">Unsafe</span> <span class="variable">unsafe</span> <span class="operator">=</span> UnsafeFactory.getUnsafe();</span><br><span class="line"></span><br><span class="line">	<span class="type">long</span> <span class="variable">offset</span> <span class="operator">=</span> UnsafeFactory.getFieldOffset(unsafe, Entity.class, <span class="string">&quot;x&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">boolean</span> successful;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 4个参数分别是：对象实例、字段的内存偏移量、字段期望值、字段新值</span></span><br><span class="line">    successful = unsafe.compareAndSwapInt(entity, offset, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.x);</span><br><span class="line"></span><br><span class="line">    successful = unsafe.compareAndSwapInt(entity, offset, <span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.x);</span><br><span class="line"></span><br><span class="line">    successful = unsafe.compareAndSwapInt(entity, offset, <span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">    System.out.println(successful + <span class="string">&quot;\t&quot;</span> + entity.x);</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnsafeFactory</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取 Unsafe 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title function_">getUnsafe</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">try</span> &#123;</span><br><span class="line">         <span class="type">Field</span> <span class="variable">field</span> <span class="operator">=</span> Unsafe.class.getDeclaredField(<span class="string">&quot;theUnsafe&quot;</span>);</span><br><span class="line">         field.setAccessible(<span class="literal">true</span>);</span><br><span class="line">         <span class="keyword">return</span> (Unsafe) field.get(<span class="literal">null</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">         &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取字段的内存偏移量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unsafe</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> fieldName</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">getFieldOffset</span><span class="params">(Unsafe unsafe, Class clazz, String fieldNam&#123;</span></span><br><span class="line"><span class="params">         <span class="keyword">try</span> &#123;</span></span><br><span class="line"><span class="params">         return unsafe.objectFieldOffset(clazz.getDeclaredField(fieldName)</span>);</span><br><span class="line">         &#125; <span class="keyword">catch</span> (NoSuchFieldException e) &#123;</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(e);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="CAS缺陷"><a class="header-anchor" href="#CAS缺陷">¶</a>CAS缺陷</h2>
<p>CAS虽然高校解决了原子操作但是还是存在一些缺陷，主要变现在三个方面：</p>
<ul>
<li>自旋CAS长时间地不成功，让CPU在那里空转，导致给CPU带来非常大的开销</li>
<li>只能保证一个共享变量的原子操作，也就是说，如果是分布式的话，还是老老实实用分布式锁吧</li>
<li>ABA问题</li>
</ul>
<h3 id="ABA问题"><a class="header-anchor" href="#ABA问题">¶</a>ABA问题</h3>
<p>当有多个线程对他一个原子类进行操作的时候，某个线程在短时间内将原子类的值A修改为B，又马上将其修改为A，这个时候其他线程不感知，还是会修改成功</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219093920543.png" alt="image-20221219093920543"></p>
<p>其中，对某一个共享变量的操作序列为：读取-修改-写回(即A-B-A)，如果在修改操作B期间，另一个线程也对这个变量进行了修改没那么原本的修改操作就会被覆盖掉</p>
<p>ABA问题通常出现在使用CAS操作的场景中。在这些场景下，ABA问题可能会带来隐患(包括但不限于这些场景)</p>
<ol>
<li>使用CAS实现的锁：如果在一个线程获得锁之后，另一个线程在次期间对共享变量进行了修改，并且将其修改回去，那么要原本的线程可能会在释放锁的时候将修改的值写回，导致状态的混乱</li>
<li>使用CAS实现的队列(堆栈)：如果在一个线程向队列中插入元素的同时，另一个线程将队列中的某个原像素删除，并且将其插入回来，那么原本的线程可能会认为队列中任然存在这个元素，导致状态的混乱</li>
<li>……</li>
</ol>
<h3 id="解决方案"><a class="header-anchor" href="#解决方案">¶</a>解决方案</h3>
<p>数据库有个锁成为乐观锁，是一种基于数据版本实现的数据同步机制，每次修改一次数据，版本号就会进行累加</p>
<p>同样，Java也提供了相应的原子引用类<code>AtomicStampedReference&lt;V&gt;</code></p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219190644368.png" alt="image-20221219190644368"></p>
<ul>
<li><code>reference</code>即我们实际存储的变量，</li>
<li><code>stamp</code>是版本，每次修改可以通过+1来保证版本唯一性</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">demo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 定义AtomicStampedReference </span></span><br><span class="line">        <span class="comment">// Pair.reference值为1, Pair.stamp为1</span></span><br><span class="line">        <span class="type">AtomicStampedReference</span> <span class="variable">atomicStampedReference</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicStampedReference</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span>[] stampHolder = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (<span class="type">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampHolder[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread1 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// 阻塞1s</span></span><br><span class="line">            LockSupport.parkNanos(<span class="number">1000000000L</span>);</span><br><span class="line">            <span class="comment">// Thread1通过CAS修改value值为3</span></span><br><span class="line">            <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">3</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 update from &quot;</span> + value + <span class="string">&quot; to 3&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread1 update fail!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="type">int</span>[] stampHolder = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> (<span class="type">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class="line">            <span class="type">int</span> <span class="variable">stamp</span> <span class="operator">=</span> stampHolder[<span class="number">0</span>];</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread2 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">            <span class="comment">// Thread2通过CAS修改value值为2</span></span><br><span class="line">            <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">2</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 update from &quot;</span> + value + <span class="string">&quot; to 2&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// do something</span></span><br><span class="line"></span><br><span class="line">                value = (<span class="type">int</span>) atomicStampedReference.get(stampHolder);</span><br><span class="line">                stamp = stampHolder[<span class="number">0</span>];</span><br><span class="line">                System.out.println(<span class="string">&quot;Thread2 read value: &quot;</span> + value + <span class="string">&quot;, stamp: &quot;</span> + stamp);</span><br><span class="line">                <span class="comment">// Thread2通过CAS修改value值为1</span></span><br><span class="line">                <span class="keyword">if</span> (atomicStampedReference.compareAndSet(value, <span class="number">1</span>, stamp, stamp + <span class="number">1</span>)) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;Thread2 update from &quot;</span> + value + <span class="string">&quot; to 1&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;Thread2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">Thread1 read value: 1, stamp: 1</span><br><span class="line">Thread2 read value: 1, stamp: 1</span><br><span class="line">Thread2 update from 1 to 2</span><br><span class="line">Thread2 read value: 2, stamp: 2</span><br><span class="line">Thread2 update from 2 to 1</span><br><span class="line">Thread1 update fail!</span><br></pre></td></tr></table></figure>
<p>这里就可以看到，ABB问题得到解决。A线程没有修改成功</p>
<blockquote>
<p><code>AtomicMarkableReference</code>可以理解为上面<code>AtomicStampedReference</code>的简化版</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221219191150048.png" alt="image-20221219191150048"></p>
<p>就是不关心修改过几次，仅仅关心是否修改过</p>
<p>因此变量<code>mark</code>是<code>boolean</code>类型，仅记录值是够有过修改</p>
</blockquote>
<h2 id="原子类操作"><a class="header-anchor" href="#原子类操作">¶</a>原子类操作</h2>
<p>在并发编程中很容易出现并发安全的问题</p>
<blockquote>
<p>有一个很简单的例子就是多线程更新变量 <code>i=1</code>，比如多个线程执行<code>i++</code>操作，就有可能获取不到正确的值，而这个问题，最常用的方法是通过<code>synchronized</code>进行控制来达到线程安全的目的。但是由于<code>synchronized</code>是采用的悲观锁策略，并不是特别高效的一种解决方案，实际上，在JUC下的atomic包提供了一系列的操作简单，性能高效，并能保证线程安全的类去更新基本类型变量，数组元素，应用类型，以及更新对象中的字段类型，atomic包下的这些类都是采用的是乐观锁策略去原子更新数据，在java中则是使用CAS操作具体实现。</p>
</blockquote>
<p>在<code>java.util.concurrent.atomic</code>包下提供了一组原子操作类：</p>
<ul>
<li>基本类型：<code>AtomicInteger、AtomicLong、AtomicBoolean</code></li>
<li>引用类型：<code>AtomicReference、AtomicStampedRerence、AtomicMarkableReference</code></li>
<li>数组类型：<code>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray</code></li>
<li>对象属性原子修改器：<code>AtomicIntegerFieldUpdater、AtomicLongFieldUpdater、 AtomicReferenceFieldUpdater</code></li>
<li>原子类型累加器(jdk1.8过后出来的)：<code>DoubleAccumulator、DoubleAdder、 LongAccumulator、LongAdder、Striped64</code></li>
</ul>
<h3 id="原子更新基本数据"><a class="header-anchor" href="#原子更新基本数据">¶</a>原子更新基本数据</h3>
<p>以<code>AtomicInteger</code>总结下常用方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以原子的方式将实例中的原值加1，返回的是自增前的旧值；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getAndSet(int newValue)：将实例中的值更新为新值，并返回旧值；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">getAndSet</span><span class="params">(<span class="type">boolean</span> newValue)</span> &#123;</span><br><span class="line">    <span class="type">boolean</span> prev;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        prev = get();</span><br><span class="line">    &#125; <span class="keyword">while</span> (!compareAndSet(prev, newValue));</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//incrementAndGet() ：以原子的方式将实例中的原值进行加1操作，并返回最终相加后的结果；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">incrementAndGet</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//addAndGet(int delta) ：以原子方式将输入的数值与实例中原本的值相加，并返回最后的结果；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="built_in">this</span>, valueOffset, delta) + delta;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试一下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) &#123;<span class="comment">// 原子自增 CAS</span></span><br><span class="line">                    sum.incrementAndGet();</span><br><span class="line">                    <span class="comment">//TODO</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum.get());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行完过后，值为10000的结果呈现在面前……</p>
<blockquote>
<p><code>incrementAndGet()</code>方法通过CAS自增实现，如果CAS失败，自旋直到成功+1。</p>
</blockquote>
<h3 id="原子更新数组类型"><a class="header-anchor" href="#原子更新数组类型">¶</a>原子更新数组类型</h3>
<p>以<code>AtomicIntegerArray</code>为例总结常用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//addAndGet(int i, int delta)：以原子更新的方式将数组中索引为i的元素与输入值相加；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">addAndGet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> delta)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, delta) + delta;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//getAndIncrement(int i)：以原子更新的方式将数组中索引为i的元素自增加1；</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">int</span> <span class="title function_">getAndIncrement</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getAndAdd(i, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//compareAndSet(int i, int expect, int update)：将数组中索引为i的位置的元素进行更</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">compareAndSet</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> expect, <span class="type">int</span> update)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> compareAndSetRaw(checkedByteOffset(i), expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>测试一下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//首先创建数组</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span>[] value = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//将其放在AtomicIntegerArray构造器中</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">AtomicIntegerArray</span> <span class="variable">atomicIntegerArray</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicIntegerArray</span>(value);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="comment">//设置索引0的元素为100</span></span><br><span class="line">    atomicIntegerArray.set(<span class="number">0</span>, <span class="number">100</span>);</span><br><span class="line">    System.out.println(atomicIntegerArray.get(<span class="number">0</span>));</span><br><span class="line">    <span class="comment">//以原子更新的方式将数组中索引为1的元素与输入值相加</span></span><br><span class="line">    atomicIntegerArray.getAndAdd(<span class="number">1</span>, <span class="number">5</span>);</span><br><span class="line">    System.out.println(atomicIntegerArray);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到输出结果</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">100</span><br><span class="line">[100, 7, 3, 4, 5]</span><br></pre></td></tr></table></figure>
<h3 id="原子更新引用类型"><a class="header-anchor" href="#原子更新引用类型">¶</a>原子更新引用类型</h3>
<p><code>AtomicReference</code>作用是对普通对象的封装，他可以保证你在修改对象时的线程安全性</p>
<p><strong>测试一下</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;张三&quot;</span>, <span class="number">23</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;李四&quot;</span>, <span class="number">25</span>);</span><br><span class="line">    <span class="type">User</span> <span class="variable">user3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;王五&quot;</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化为 user1</span></span><br><span class="line">    AtomicReference&lt;User&gt; atomicReference = <span class="keyword">new</span> <span class="title class_">AtomicReference</span>&lt;&gt;();</span><br><span class="line">    atomicReference.set(user1);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 user2 赋给 atomicReference</span></span><br><span class="line">    atomicReference.compareAndSet(user1, user2);</span><br><span class="line">    System.out.println(atomicReference.get());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把 user3 赋给 atomicReference</span></span><br><span class="line">    atomicReference.compareAndSet(user1, user3);</span><br><span class="line">    System.out.println(atomicReference.get());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">25</span>&#125;</span><br><span class="line">User&#123;name=<span class="string">&#x27;李四&#x27;</span>, age=<span class="number">25</span>&#125;</span><br></pre></td></tr></table></figure>
<h3 id="对象属性原子修改器"><a class="header-anchor" href="#对象属性原子修改器">¶</a>对象属性原子修改器</h3>
<p><code>AtomicIntegerFieldUpdater</code>可以线程安全地更新对象中的整形变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AtomicIntegerFieldUpdaterTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Candidate</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">AtomicInteger</span> <span class="variable">score2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicIntegerFieldUpdater&lt;Candidate&gt; scoreUpdater =</span><br><span class="line">            AtomicIntegerFieldUpdater.newUpdater(Candidate.class, <span class="string">&quot;score&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">AtomicInteger</span> <span class="variable">realScore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AtomicInteger</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="type">Candidate</span> <span class="variable">candidate</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Candidate</span>();</span><br><span class="line"></span><br><span class="line">        Thread[] t = <span class="keyword">new</span> <span class="title class_">Thread</span>[<span class="number">10000</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i] = <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (Math.random() &gt; <span class="number">0.4</span>) &#123;</span><br><span class="line">                        candidate.score2.incrementAndGet();</span><br><span class="line">                        scoreUpdater.incrementAndGet(candidate);</span><br><span class="line">                        realScore.incrementAndGet();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            t[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            t[i].join();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicIntegerFieldUpdater Score=&quot;</span> + candidate.score);</span><br><span class="line">        System.out.println(<span class="string">&quot;AtomicInteger Score=&quot;</span> + candidate.score2.get());</span><br><span class="line">        System.out.println(<span class="string">&quot;realScore=&quot;</span> + realScore.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对于 <code>AtomicIntegerFieldUPdater</code>的使用稍微有一些限制和约束：</p>
<ol>
<li>字段必须是volatile类型的，在线程之间共享变量时保证立即可见</li>
<li>字段的描述类型(修饰符public/protect/default/private)与调用者与操作对象字段的关系一致，也就是说调用者能够直接操作对象字段，那么就可以反射进行原子操作。但是对于父类的字段，子类是不能直接操作的，尽管子类可以访问父类的字段</li>
<li>只能是实例变量，不能是类变量。也就是说不能加<code>static</code>关键字</li>
<li>只能是可修改变量，不能是<code>final</code>变量，因为<code>final</code>的语义就是不可修改。实际上<code>final</code>的语义和<code>volatile</code>是有冲突的，这两个关键字不能同时存在。</li>
<li>对于<code>AtomicIntegerFieldUpdatert</code>和<code>AtomicLongFIeldUpdater</code>只能修改int/long类型字段，不能修改器包装类型(Integer/Long)。如果要修改包装类型就需要使用<code>AtomicReferenceFieldUpdater</code></li>
</ol>
<blockquote>
<p><code>LongAdder</code>还没研究，等以后有时间了来再研究(💩)</p>
</blockquote>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
