<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="¶JVM整体结构&#x2F;内存模型 最开始，先放图：  ¶💻程序计数器  程序计数寄存器(Program Counter Register)，存储指令的相关线程信息，CPU只有吧数据装载到寄存器才能够运行 这里，并非是广义上所致的物理寄存器 程序计数器时一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器  ¶作用 用来存储指向下一条指令的物理地址，即将要执行的指令代码。由执行引擎读取下一条">
<meta property="og:type" content="website">
<meta property="og:title" content="JVM内存结构">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="¶JVM整体结构&#x2F;内存模型 最开始，先放图：  ¶💻程序计数器  程序计数寄存器(Program Counter Register)，存储指令的相关线程信息，CPU只有吧数据装载到寄存器才能够运行 这里，并非是广义上所致的物理寄存器 程序计数器时一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器  ¶作用 用来存储指向下一条指令的物理地址，即将要执行的指令代码。由执行引擎读取下一条">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230101150337046.png">
<meta property="article:published_time" content="2022-12-31T13:20:56.000Z">
<meta property="article:modified_time" content="2022-12-31T13:20:56.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="内存结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230101150337046.png">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>JVM内存结构</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h2 id="JVM整体结构-内存模型"><a class="header-anchor" href="#JVM整体结构-内存模型">¶</a>JVM整体结构/内存模型</h2>
<p>最开始，先放图：</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20230101150337046.png" alt="image-20230101150337046"></p>
<h3 id="💻程序计数器"><a class="header-anchor" href="#💻程序计数器">¶</a>💻程序计数器</h3>
<blockquote>
<p>程序计数寄存器(Program Counter Register)，存储指令的相关线程信息，CPU只有吧数据装载到寄存器才能够运行</p>
<p>这里，并非是广义上所致的物理寄存器</p>
<p>程序计数器时一块较小的内存空间，可以看做是当前线程所执行的字节码的行号指示器</p>
</blockquote>
<h4 id="作用"><a class="header-anchor" href="#作用">¶</a>作用</h4>
<p>用来存储指向下一条指令的物理地址，即将要执行的指令代码。由执行引擎读取下一条指令</p>
<h4 id="总结"><a class="header-anchor" href="#总结">¶</a>总结</h4>
<ul>
<li>他是一块很小的内存空间，几乎可以忽略不计，也是运行速度最快的存储区域</li>
<li>在JVM规范中，每个线程都有他自己的程序计数器，是线程私有的，声明周期与线程的生命周期一致</li>
<li>如何时间一个线程都只有一个方法在执行，也就是所谓的当前方法。如果当前线程整在执行的是Java方法，程序计数器记录的是JVM字节码指令地址；如果执行的是native方法，则是未指定值</li>
<li>他是程序控制流的指示器、分支、循环、跳转、异常处理，线程恢复、等基础功能都需要依赖这个计数器来完成</li>
<li>字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令</li>
<li>他是唯一一个在<strong>Jvm</strong>规范中没有规定任何<code>OutOfMemoryError</code>情况的区域</li>
</ul>
<h3 id="📧虚拟机栈-线程栈"><a class="header-anchor" href="#📧虚拟机栈-线程栈">¶</a>📧虚拟机栈(线程栈)</h3>
<blockquote>
<p>Java虚拟机栈，早起也叫Java栈。每个线程在创建的时候都会创建一个虚拟机栈，其内部保存一个个<strong>栈帧(Stack Frame)</strong>，对应着一个个Java方法调用，是线程稀有的，生命周期与线程一致</p>
</blockquote>
<p>**作用：**主管Java程序的运行，他保存方法的局部变量、部分结果、并参与方法的调用与返回</p>
<p><strong>特点：</strong></p>
<ul>
<li>栈是一种快速有效的分配存储的方式，访问速度仅次于程序计数器</li>
<li>JVM直接对虚拟机栈的操作只有两个：每个方法执行，伴随着入栈；方法执行结束出栈</li>
<li>栈不存在垃圾回收问题，毕竟站内存储的，在方法调用完后，自动回收。这个连那个狗屁C++都做得到</li>
</ul>
<h4 id="栈运行原理"><a class="header-anchor" href="#栈运行原理">¶</a>栈运行原理</h4>
<p>JVM直接对Java栈的操作只有两个，对栈帧的压栈和出栈，遵循“先进后出，后进先出”原则</p>
<p>在一条活动线程中，一个时间点上，只会有一个活动的栈帧。即只有当前正在执行方法的栈帧**(栈顶栈帧)<strong>是有效的，这个栈帧被称之为</strong>当前栈帧**，与当前栈帧对应的是<strong>当前方法</strong>，定义这个方法的类就是<strong>当前类</strong></p>
<p>执行引擎运行的所有字节码指令只对当前栈帧进行操作</p>
<p>如果在该方法中调用了其他方法，对应的新的栈帧就会被创建出来，放在栈的栈顶，被称之为新的当前栈帧</p>
<p>不同线程中所包含的栈帧是不允许存在相互引用的，即不可能在一个栈帧中引用另外一个线程的栈帧</p>
<p>如果当前方法调用了其他方法，方法返回之际，当前栈帧会传回此方法的执行结果给前一个栈帧，接着，虚拟机会丢弃当前栈帧，使得前一个栈帧重新成为当前栈帧</p>
<h4 id="栈帧内部结构"><a class="header-anchor" href="#栈帧内部结构">¶</a>栈帧内部结构</h4>
<p>每个栈帧中存储着：</p>
<ul>
<li><strong>局部变量表(Local Variables)</strong></li>
<li><strong>操作数栈(Operand Stack)</strong></li>
<li><strong>动态链接(Dynamic Linking)</strong></li>
<li><strong>方法返回地址(方法出口)(Return Address)</strong></li>
</ul>
<h5 id="📝局部变量表"><a class="header-anchor" href="#📝局部变量表">¶</a>📝局部变量表</h5>
<p>局部变量表也被成为布局变量数组，或者本地变量表。是一组变量值存储的空间，主要用于存储方法参数和定义在方法体内的局部变量，包括编译器可知的各种Java虚拟机基本数据类型(boolean、byte、char、short、int、float、long、double)、<strong>对象引用(reference类型)</strong></p>
<p>由于局部变量表是建立在线程的栈上，是线程的私有数据，因此<strong>不存在线程安全问题</strong></p>
<p>局部变量表所需要的容量大小是编译期间确定下来的，并保存在方法的Code属性中的<code>maximum local variable</code>数据项中。在方法运行期间是不会改变局部变量表的大小的</p>
<p><strong>局部变量表中的变量只在当前方法调用中有效</strong>。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程，当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。</p>
<h5 id="🎬操作数栈"><a class="header-anchor" href="#🎬操作数栈">¶</a>🎬操作数栈</h5>
<p>每个独立的栈帧中除了包含局部变量表之外，害包含一个后进先出的操作数栈，也可以成为<strong>表达式栈</strong></p>
<p>在方法执行过程中根据字节码指令，往操作数栈中<strong>写数据</strong>或者<strong>提取数据</strong>，即，<strong>入栈</strong>，<strong>出栈</strong></p>
<blockquote>
<p>操作数栈，主要用于保存计算过程的中间结果，同时作为计算过程中变量临时的存储空间</p>
<p>操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，<strong>此时这个方法的操作数栈是空的</strong></p>
<p>每个操作数栈都会拥有一个明确的栈深度，用于存储数值，其所需的最大深度在编译期间就已经定义好了，保存在方法的Code属性的<code>max_stack</code>数据项中</p>
</blockquote>
<p>比如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b; </span><br></pre></td></tr></table></figure>
<p>在操作数栈里面呈现的，都是<code>1,2,1+2</code>这样的数据</p>
<p>另外，我们所说的<strong>Java虚拟机的解释引擎是基于栈的执行引擎</strong>，其中的栈指的就是操作数栈</p>
<h5 id="🎹动态链接"><a class="header-anchor" href="#🎹动态链接">¶</a>🎹动态链接</h5>
<p><strong>每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。<strong>包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接</strong>(Dynamic Likning)。</strong></p>
<p>在Java源文件被编译到字节码文件中的时候，所有的变量和方法引用都作为符号应用**(Symbolic Reference)<strong>保存在Class文件的常量池中。比如：描述一个方法调用了另外的其他方法的时候，就是通过常量池中指向调方法的符号引用来表示的，那么</strong>动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用**</p>
<h5 id="📮方法出口-方法返回地址return-address"><a class="header-anchor" href="#📮方法出口-方法返回地址return-address">¶</a>📮方法出口(方法返回地址return address)</h5>
<p>用来存放调用该方法的<strong>PC寄存器</strong>的值</p>
<p>一个方法的结束，有两种方式</p>
<ul>
<li>正常执行完成</li>
<li>出现未处理的异常，非正常退出</li>
</ul>
<p>无论通过那种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的PC计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定的，栈帧中一般不会保存这部分信息</p>
<p>当一个方法开始执行后，只有两个方式可以退出这个方法：</p>
<ol>
<li><strong>执行引擎</strong>遇到任意一个方法返回的字节码指令，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong><br>
一个方法的正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定</li>
<li>在方法执行的过程中遇到了异常，并且这个异常没有在方法内进行处理，也就是只要在本方法的异常表中没有搜索匹配的异常处理器，就会导致方法退出。简称<strong>异常完成出口</strong></li>
</ol>
<p>本质上，<strong>方法的退出就是当前栈帧出栈的过程</strong>，此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</p>
<p><strong>正常完成出口</strong>和<strong>异常完成出口</strong>的区别在于：通过<strong>异常完成出口</strong>退出的不会给他的上层调用者产生任何的返回值</p>
<h3 id="📡本地方法栈"><a class="header-anchor" href="#📡本地方法栈">¶</a>📡本地方法栈</h3>
<h4 id="本地方法接口"><a class="header-anchor" href="#本地方法接口">¶</a>本地方法接口</h4>
<p>简单的讲，一个<strong>Native Method</strong>就以一个Java调用非Java代码的接口。我们知道的<strong>Unsafe</strong>类就有很多本地方法。</p>
<blockquote>
<p>那么为什么要是用本地方法呢？</p>
</blockquote>
<p>Java使用起来非常方便，然而有些层次的任务用Java实现起来也不容易，或者我们对查询的执行效率很在意的时候，问题就出现了</p>
<ul>
<li>与Java环境外交互：有时Java应用需要与Java外面的环境交互，这就是本地方法存在的主要原因</li>
<li>与操作系统的交互：JVM支持Java语言本身和Runtime Lib，但是有时候任需要依赖一些底层系统的支持。JVM的一些部分就是C语言编写的……</li>
</ul>
<h4 id="本地方法栈"><a class="header-anchor" href="#本地方法栈">¶</a>本地方法栈</h4>
<p>用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用，本地方法栈也是线程私有的哦，并且运行线程固定或者可动态扩展的内存大小</p>
<ul>
<li>如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机就会抛出一份<code>StackoverflowError</code></li>
<li>如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个<code>OutOfMemoryError</code>异常</li>
</ul>
<p>并不是所有JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈</p>
<blockquote>
<p>栈是运行时的单位，堆是存储的单位</p>
<p>栈解决查询的运行问题，即程序如何执行，或者说如何处理数据<br>
堆解决的是数据存储的问题，即数据怎么放、放在哪</p>
</blockquote>
<h3 id="🚿堆内存"><a class="header-anchor" href="#🚿堆内存">¶</a>🚿堆内存</h3>
<p>仅从内存划分角度谈</p>
<p>对于大多数应用，Java堆是Java虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域唯一目的就是存放对象实例、几乎所有的对象实例以及数据都在这里分配内存。</p>
<p>为了进行高效的垃圾回收吗，虚拟机吧堆内存<strong>逻辑上</strong>划分成三块区域(分代的唯一理由就是优化GC性能)：</p>
<ul>
<li>新生代(年轻代)：新对象和没达到一定年龄的对象都在新生代</li>
<li>老年代(养老区)：被长时间使用的对象，老年代的内存空间应该要比年轻代更大</li>
<li>元空间(JDK1.8之前叫做永久代)：像一些方法中的操作临时对象等，JDK1.8之前是占用JVM内存，JDK1.8之后，直接使用物理内存</li>
</ul>
<h4 id="📀年轻代-Young-Generation"><a class="header-anchor" href="#📀年轻代-Young-Generation">¶</a>📀年轻代(Young Generation)</h4>
<p>年轻代是所有新对象创建的地方。当填充年轻代时，执行垃圾收集。这种垃圾收集称之为<strong>Minor GC</strong>。年轻一代被分为三个部分</p>
<ul>
<li>伊甸园(Eden Memory)</li>
<li>幸存区1(Survivor Memory1)</li>
<li>幸存区2(Survivor  Memory2)</li>
<li>默认比例是：<code>8:1:1</code></li>
</ul>
<p>大多数新创建的对象都位于Eden内存空间中，当Eden空间被对象填充时，执行<code>Minor GC</code>，并将所有幸存者对象移动到一个幸存者空间中</p>
<p><code>Minor GC</code>检查幸存者对象，并将他们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的</p>
<p>通过多次GC(Minor GC)循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，一般默认是15代，最大也是15代</p>
<h4 id="💿老年代-Old-Generation"><a class="header-anchor" href="#💿老年代-Old-Generation">¶</a>💿老年代(Old Generation)</h4>
<p>旧的一代内存包含那些经过许多轮<code>Minor GC</code>后仍然存活的对象。通常，垃圾收集实在老年代内存满时执行的。老年代垃圾收集成为主GC(<strong>Major GC</strong>)，通常也需要更长的时间</p>
<p>大对象直接进入老年代(大对象是指需要大量内存空间的对象，这时显然前面的年轻代的内存空间就不够他放的)。这样做的目的是避免在Eden去和两个Survivor去之间发生大量地方内存拷贝</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000040695861">JVM内存模型，你看这一篇就够了</a></p>
</blockquote>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
