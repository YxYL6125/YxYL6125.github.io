<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="Redis是一种支持key-value等多种数据类型的存储系统。">
<meta property="og:type" content="website">
<meta property="og:title" content="Redis-数据结构与高性能">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/Redis-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E9%AB%98%E6%80%A7%E8%83%BD.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="Redis是一种支持key-value等多种数据类型的存储系统。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-10T12:38:19.000Z">
<meta property="article:modified_time" content="2023-01-11T12:46:37.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="Redis">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>Redis-数据结构与高性能</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h2 id="什么是Redis"><a class="header-anchor" href="#什么是Redis">¶</a>什么是Redis</h2>
<p>Redis是一种支持key-value等多种数据类型的存储系统。可以用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化</p>
<ul>
<li>读写性能优异：Redis能读的速度时110000次/s，写的速度时81000次/s</li>
<li>数据类型丰富：Redis支持二进制案例的String，List，Hash，Set，以及Ordered Set数据类型的操作</li>
<li>原子性：Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行</li>
<li>丰富的特性：Redis支持publish/subscribe，通知，key过期等特性</li>
<li>持久化：Redis支持RDB，AOF等持久化方式</li>
<li>发布订阅：Redis支持发布/订阅模式</li>
<li>分布式：Redis Cluster</li>
</ul>
<h3 id="数据Redis结构结构"><a class="header-anchor" href="#数据Redis结构结构">¶</a>数据Redis结构结构</h3>
<blockquote>
<p>推荐直接看<a target="_blank" rel="noopener" href="https://redis.io/topics/data-types/">官方文档</a></p>
</blockquote>
<p>首先对redis来说，所有的key都是字符串。我们在谈基础数据类型的时候，讨论的是存储值的数据类型，主要包括常见的5中数据类型：</p>
<ul>
<li>String</li>
<li>List</li>
<li>Hash</li>
<li>Set</li>
<li>ZSet</li>
</ul>
<table>
<thead>
<tr>
<th>结构类型</th>
<th>结构存储的值</th>
<th>结构的读写能力</th>
</tr>
</thead>
<tbody>
<tr>
<td>String字符串</td>
<td>可以是字符串、证书或浮点数</td>
<td>对整个字符串或字符串的一步分进行操作；对整形或浮点数进行自增或自减操作</td>
</tr>
<tr>
<td>List列表</td>
<td>一个链表，链表上的每个节点都包括一个字符串</td>
<td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素</td>
</tr>
<tr>
<td>Set集合</td>
<td>包含字符串的无序集合</td>
<td>字符串的集合，包含基础的方法有看是否存在、添加、获取、删除；还包含计算交集、并集、差集等</td>
</tr>
<tr>
<td>Hash散列</td>
<td>包含键值对的无序散列表</td>
<td>包含方法有：添加、获取、删除单个元素</td>
</tr>
<tr>
<td>ZSet有序集合</td>
<td>和散列一样，用于存储键值对</td>
<td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序有分数的大小决定；包含方法有添加、获取、删除单个元素、以及根据分值范围或成员来获取元素</td>
</tr>
</tbody>
</table>
<h4 id="String字符串"><a class="header-anchor" href="#String字符串">¶</a>String字符串</h4>
<blockquote>
<p>String是Redis总最基本的数据类型，一个key对应一个value</p>
</blockquote>
<p>String类型是二进制安全的，意思是redis的string可以包含任何数据。如数字、字符串、jpg图片或者序列化的对象</p>
<ul>
<li><strong>命令的使用</strong></li>
</ul>
<table>
<thead>
<tr>
<th>命令</th>
<th>简书</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>获取存储在给定键中的值</td>
<td>GET name</td>
</tr>
<tr>
<td>SET</td>
<td>设置存储在给定键中的值</td>
<td>SET name value</td>
</tr>
<tr>
<td>DEL</td>
<td>删除存储在给定键中的值</td>
<td>DEL name</td>
</tr>
<tr>
<td>INCR</td>
<td>将键存储的值加1</td>
<td>INCR key</td>
</tr>
<tr>
<td>DECR</td>
<td>将键存储的值减1</td>
<td>DECR key</td>
</tr>
<tr>
<td>INCRBY</td>
<td>将键存储的值加上整数</td>
<td>INCRBY key amount</td>
</tr>
<tr>
<td>DECRBY</td>
<td>将键存储的值减去整数</td>
<td>DECRBY key amount</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; set hello world</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">&quot;world&quot;</span><br><span class="line">127.0.0.1:6379&gt; del hello</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; get hello</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; set counter 2</span><br><span class="line">OK</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line">&quot;2&quot;</span><br><span class="line">127.0.0.1:6379&gt; incr counter</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line">&quot;3&quot;</span><br><span class="line">127.0.0.1:6379&gt; incrby counter 100</span><br><span class="line">(integer) 103</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line">&quot;103&quot;</span><br><span class="line">127.0.0.1:6379&gt; decr counter</span><br><span class="line">(integer) 102</span><br><span class="line">127.0.0.1:6379&gt; get counter</span><br><span class="line">&quot;102&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>实战场景</strong>
<ul>
<li>缓存：经典的使用场景，吧常用的信息、字符串、图片或者视频等信息放在redis中，redis作为缓存层，mysql做持久层，降低mysql的读写压力</li>
<li>计数器：redis是单线程模型(并不是严格意义上的单线程，只是执行命令用的一个线程执行)，一个命令执行完成后才会执行下一个，同时数据可以一步落地到其他的数据源</li>
<li>session：常见方案 spring session + redis实现session共享</li>
</ul>
</li>
</ul>
<h4 id="List列表"><a class="header-anchor" href="#List列表">¶</a>List列表</h4>
<blockquote>
<p>Redis中的List其实就是链表(Redis用双端链表实现List)</p>
</blockquote>
<p>使用List结构，我们可以轻松地实现最新消息排队功能(比如weibo的TimeLine)。List的另一个应用就是消息队列，可以利用List的PUSH操作，将任务存放在List中，然后工作线程再用POP操作将任务取出进行执行</p>
<ul>
<li>
<p><strong>命令的使用</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH</td>
<td>将给定值推入列表右端</td>
<td>RPUSH key value</td>
</tr>
<tr>
<td>LPUSH</td>
<td>将给定值推入列表左端</td>
<td>LPUSH key value</td>
</tr>
<tr>
<td>RPOP</td>
<td>从列表的右端弹出一个值，并返回被弹出的值</td>
<td>RPOP key</td>
</tr>
<tr>
<td>LPOP</td>
<td>从列表的左端弹出一个值，并返回被弹出的值</td>
<td>LPOP key</td>
</tr>
<tr>
<td>LRANGE</td>
<td>获取列表在给定范围上的所有值</td>
<td>LRANGE key 0-1</td>
</tr>
<tr>
<td>LINDEX</td>
<td>通过索引获取列表中的元素</td>
<td>LINDED key index</td>
</tr>
</tbody>
</table>
</li>
<li>
<p><strong>使用的技巧</strong></p>
<ul>
<li>lpush + lpop = Stack(栈)</li>
<li>lpush + rpop = Queue(队列)</li>
<li>lpush + ltrim = Capped Collection(有限集合)</li>
<li>lpush + brpop = MQ(消息队列)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; lpush mylist 1 2 ll ls men</span><br><span class="line">(integer) 5</span><br><span class="line">127.0.0.1:6379&gt; LRANGE mylist 0 -1</span><br><span class="line">1) &quot;men&quot;</span><br><span class="line">2) &quot;ls&quot;</span><br><span class="line">3) &quot;ll&quot;</span><br><span class="line">4) &quot;2&quot;</span><br><span class="line">5) &quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylist -1</span><br><span class="line">&quot;1&quot;</span><br><span class="line">127.0.0.1:6379&gt; LINDEX mylit 10</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>实战场景</strong>：</p>
<ul>
<li>微博TimeLine：有人发微博，用<code>lpush</code>加入时间轴，展示新的列表信息</li>
<li>消息队列</li>
</ul>
</li>
</ul>
<h4 id="Set集合"><a class="header-anchor" href="#Set集合">¶</a>Set集合</h4>
<blockquote>
<p>Redis的Set是String类型的无序集合。集合成员是唯一的，这就意味着集合中不能出现重复的数据</p>
<p>Redis中的集合是通过哈希表实现的，所以添加、删除、查找的复杂度就是O(1)</p>
</blockquote>
<ul>
<li>
<p><strong>命令的使用</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD</td>
<td>向集合添加一个或多个成员</td>
<td>SADD key value</td>
</tr>
<tr>
<td>SCARD</td>
<td>获取集合的成员数</td>
<td>SCARD key</td>
</tr>
<tr>
<td>SMEMBERS</td>
<td>返回集合中的所有成员</td>
<td>SMEMBERS key member</td>
</tr>
<tr>
<td>SISMEMBER</td>
<td>判断member元素是否是集合key的成员</td>
<td>SISMEMBER key member</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; sadd myset hao hao1 xiaohao hao</span><br><span class="line">(integer) 3</span><br><span class="line">127.0.0.1:6379&gt; SMEMBERS myset</span><br><span class="line">1) &quot;hao1&quot;</span><br><span class="line">2) &quot;xiaohao&quot;</span><br><span class="line">3) &quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset hao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; SISMEMBER myset xiaoha</span><br><span class="line">(integer) 0</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>实战场景</strong></p>
<ul>
<li><strong>标签</strong>(tag)：给用户添加标签，或者用户给消息添加标签，这样同一标签或者类似标签的可以给推荐关注的事或关注的人</li>
<li>点赞、点踩、收藏等，可以放在set中实现</li>
</ul>
</li>
</ul>
<h4 id="Hash散列"><a class="header-anchor" href="#Hash散列">¶</a>Hash散列</h4>
<blockquote>
<p>Redis hash 是一个string类型的field字段和value值的映射表，hash特别适合用于存储对象</p>
</blockquote>
<ul>
<li>
<p><strong>命令使用</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET</td>
<td>添加键值对</td>
<td>HSET hash-key sub-key1 value1</td>
</tr>
<tr>
<td>HGET</td>
<td>获取指定散列键的值</td>
<td>HGET hash-key key1</td>
</tr>
<tr>
<td>HGETALL</td>
<td>获取散列中包含的所有键值对</td>
<td>HGETALL hash-key</td>
</tr>
<tr>
<td>HDEL</td>
<td>如果给定键存在于散列中，那么就移除这个键</td>
<td>HDEL hash-key sub-key1</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HSET user name1 hao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET user email1 hao@yxyl.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">3) &quot;email1&quot;</span><br><span class="line">4) &quot;hao@yxyl.com&quot;</span><br><span class="line">127.0.0.1:6379&gt; HGET user user</span><br><span class="line">(nil)</span><br><span class="line">127.0.0.1:6379&gt; HGET user name1</span><br><span class="line">&quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; HSET user name2 xiaohao</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HSET user email2 xiaohao@yxyl.com</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; HGETALL user</span><br><span class="line">1) &quot;name1&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">3) &quot;email1&quot;</span><br><span class="line">4) &quot;hao@yxyl.com&quot;</span><br><span class="line">5) &quot;name2&quot;</span><br><span class="line">6) &quot;xiaohao&quot;</span><br><span class="line">7) &quot;email2&quot;</span><br><span class="line">8) &quot;xiaohao@yxyl.com&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p><strong>实战场景</strong></p>
<ul>
<li>缓存：能直观，相比string更节省空间的维护缓存信息，如用户信息，视频信息等</li>
</ul>
</li>
</ul>
<h4 id="Zset有序集合"><a class="header-anchor" href="#Zset有序集合">¶</a>Zset有序集合</h4>
<blockquote>
<p>Redis有序集合和集合一样也是string类型元素的集合，且不允许重复的成员。不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序</p>
</blockquote>
<p>有序集合的成员是唯一的，但是分数(score)却是可以重复的。有序集合是通过2种数据结构是实现的：</p>
<ol>
<li><strong>压缩列表(ziplist)</strong> ：ziplist是为了提高存储效率而设计的一种特殊编码的双向链表。他可以存储字符串或者整数，存储整数时是采用整数的二进制而不是字符串形式存储的。他能在O(1)的时间复杂度下完成list双端的<code>push</code>和<code>pop</code>操作。但是因为每次操作都需要重新分配ziplist的内存，所以实际复杂度和ziplist的内存使用量相关</li>
<li><strong>跳跃表(zSkiplist)</strong> ：跳跃表的性能是可以保证在查找，删除，添加等操作的时候在对数期望时间内完成，这个性能是可以和平衡树来相比较的，而且实现方面比平衡树要优雅，这是采用跳跃表的主要原因</li>
</ol>
<ul>
<li>
<p>命令使用</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>简述</th>
<th>使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD</td>
<td>将一个带有给定分值的成员添加到有序集合里面</td>
<td>ZADD zset-key 178 member1</td>
</tr>
<tr>
<td>ZRANGE</td>
<td>根据元素在有序集合中所处的位置，从有序集合中获取多个元素</td>
<td>ZRANGE zset-key 0-1 withscores</td>
</tr>
<tr>
<td>ZREM</td>
<td>如果给定元素成员存在有序集合中，那么就移除这个元素</td>
<td>ZREM zset-key member1</td>
</tr>
</tbody>
</table>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; ZADD myscoreset 100 hao 90 xiaohao</span><br><span class="line">(integer) 2</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset</span><br><span class="line">(error) ERR wrong number of arguments for &#x27;zrange&#x27; command</span><br><span class="line">127.0.0.1:6379&gt; ZRANGE myscoreset 0 -1</span><br><span class="line">1) &quot;xiaohao&quot;</span><br><span class="line">2) &quot;hao&quot;</span><br><span class="line">127.0.0.1:6379&gt; ZSCORE myscoreset hao</span><br><span class="line">&quot;100&quot;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>实战场景</p>
<ul>
<li>排行榜：有序集合经典使用场景。例如小说视频等网站需要对用户上传的小说视频做排行榜，榜单可以按照用户关注数，更新时间，字数等打分，做排行榜</li>
</ul>
</li>
</ul>
<h2 id="Redis这么快？"><a class="header-anchor" href="#Redis这么快？">¶</a>Redis这么快？</h2>
<ul>
<li><strong>redis完全基于内存</strong>，绝大部分请求是纯粹的内存操作，非常快速</li>
<li><strong>数据结构简单</strong>，对数据操作也简单，redis中的数据结构是专门进行设计的</li>
<li>采用<strong>单线程模型</strong>，避免了不必要的上下文切换和竞争条件，也不存在多线程或者多线程切换而消耗CPU，不用考虑各种锁的问题，不存在加锁，释放锁的操作，没有因为可能出现死锁而导致性能消耗</li>
<li>使用了<strong>多路IO复用</strong>模型，<strong>非阻塞IO</strong></li>
<li>使用<strong>底层模型不同</strong>，他们之间底层实现方式及与客户端之间的通信的应用协议不一样，Redis直接构建了自己的VM机制，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求</li>
</ul>
<h2 id="Redis一般有哪些使用场景"><a class="header-anchor" href="#Redis一般有哪些使用场景">¶</a>Redis一般有哪些使用场景</h2>
<blockquote>
<p>可以结合项目的业务特点</p>
<p>比如：</p>
</blockquote>
<ul>
<li><strong>热点数据的缓存</strong><br>
缓存是Redis最常见的应用场景，主要是因为Redis读写性能优异，而且主键有取代memcached，成为首选的服务端缓存的组件。而且，Redis内部是支持事务的，在使用的时候能有效的保证数据的一致性</li>
<li><strong>限时业务的运用</strong><br>
redis中可以使用<code>expire</code>命令设置一个键的生存时间，到时间后redis会删除他，利用这一特征可以运用在限时的优惠活动信息、手机验证码等业务场景</li>
<li><strong>计数器的相关问题</strong><br>
redis由于<code>INCRBY</code>命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务害体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等……</li>
<li><strong>分布式锁</strong><br>
这个主要利用redis的<code>setnx</code>命令实现，<br>
<code>setnx</code>：&quot;set if not exist&quot;就是如果不存在就成功设置缓存同时返回1，否则返回0。因为我们的服务器是集群的，定时任务可能在两台机器上都会执行，所以在定时任务中首先，通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明这个倒是任务已执行。还有一堆细节就不在这里讲了……</li>
<li><strong>……</strong></li>
</ul>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
