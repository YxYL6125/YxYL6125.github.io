<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="开源的Java Web 应用服务器，实现了Java EE(Java Platform Enterprise Edition)的部分技术规范">
<meta property="og:type" content="website">
<meta property="og:title" content="Tomcat架构设计">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/Tomcat%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="开源的Java Web 应用服务器，实现了Java EE(Java Platform Enterprise Edition)的部分技术规范">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227205006567.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/tomcat-x-design-2-1.jpeg">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227211249505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227211741666.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221228093700916.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221228095237603.png">
<meta property="article:published_time" content="2022-12-27T12:45:49.000Z">
<meta property="article:modified_time" content="2022-12-28T05:48:16.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="Tomcat">
<meta property="article:tag" content="架构">
<meta property="article:tag" content="服务器">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227205006567.png">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>Tomcat架构设计</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h2 id="Tomcat整体架构"><a class="header-anchor" href="#Tomcat整体架构">¶</a>Tomcat整体架构</h2>
<blockquote>
<p>Tomcat核心：Http服务器+Servlet容器</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227205006567.png" alt="image-20221227205006567"></p>
<p>这里通过<code>server.xml</code>配置文件来加深对Tomcat架构的理解</p>
<p>Tomcat采用了组件化的设计，它的构成组件都是可配置的，其中最外层的是Server，其他组件按照一定的要求配置在这个顶级容器中，<code>server.xml</code>：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Server</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Service</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Connector</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Host</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Context</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Host</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="name">Engine</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Service</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Server</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Tomcat启动期间回通过解析xml文件，利用反射来创建相应的组件，所以xml中的标签与源码一一对应</p>
<p>以下是架构图：</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/tomcat-x-design-2-1.jpeg" alt="tomcat架构图"></p>
<p>根据上述的**“Tomcat核心”**以及Tomcat架构图，我们可以得到：</p>
<p>Tomcat要实现2个核心功能：</p>
<ul>
<li>处理Socket连接，负责网络字节流与Request和Response对象的在转化</li>
<li>加载和管理Servlet，以及具体处理ServletRequest请求</li>
</ul>
<p>因此，Tomcat设计了2个核心组件：连接器(Connector)和容器(Container)来分别做上两个核心功能</p>
<ul>
<li>连接器负责对外交流</li>
<li>容器负责内部处理请求响应</li>
</ul>
<h2 id="核心组件"><a class="header-anchor" href="#核心组件">¶</a>核心组件</h2>
<h3 id="Server"><a class="header-anchor" href="#Server">¶</a>Server</h3>
<p>指的就是整个Tomcat服务器，包含多组服务(Service)，负责管理和启动各个Service，同时监听8005端口发过来的 <code>shutdown</code> 命令</p>
<h3 id="Service"><a class="header-anchor" href="#Service">¶</a>Service</h3>
<p>每个Service组件都包含了若干用于接收客户端消息的<strong>Connecotr组件</strong>和处理请求的<strong>容器</strong>ervice组件还包含了若干个<code>Executor</code>组件，每个Executor组件都是一个线程池，它可以为Service内所有组件提供线程池执行任务</p>
<p>模型图：</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227211249505.png" alt="image-20221227211249505"></p>
<p>Tomcat为了实现支持多种I/O模型和应用层协议，一个容器可能对接多个连接器，就是好比一个房间有多个们，但是单独的连接器或者容器都不能对外提供服务，需要把他们组装起来才能工作，<strong>组装后的这个整体叫做Service组件</strong></p>
<p>Service本身没有做什么重要的事情，只是在连接器和容器外面夺宝了一层，把它们组装在一起。Tomcat内可能有多个Service，这样的设计也是出于灵活性的考虑</p>
<p>通过Tomcat中配置多个Service，可以实现通过不通过的端口号来访问同一太机器上部署的不同应用</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221227211741666.png" alt="image-20221227211741666"></p>
<p>从上图可以看出，最顶层的是Server，这里的Server指的就是一个Tomcat实例。一个Server中有一个或者多个Service，一个Service里面有多个连接器和一个容器连接器与容器之间通过标准的ServletRequest和ServletResponse通信</p>
<h3 id="Connector"><a class="header-anchor" href="#Connector">¶</a>Connector</h3>
<p>Tomcat与外部世界的连接器，监听固定端口、接收外部请求，传递给Container，并将Container处理的结构返回给外部。</p>
<p>连接器对Servlet容器屏蔽了不同的应用层协议以及I/O模型，无论是HTTP还是AJP，在容器中获取到的都是一个标准的<code>ServletRequest</code>对象</p>
<p>根据以上，连接器需要实现的功能有：</p>
<ul>
<li>监听网络端口</li>
<li>接收网络连接请求</li>
<li>读取请求网络字节流数据</li>
<li>根据具体的应用层协议(HTTP/AJP)解析字节流，生成统一的Tomcat Request对象</li>
<li>将Tomcat Request 对象转成标准的<code>ServletRequest</code></li>
<li>调用Servlet容器，得到ServletResponse</li>
<li>将ServletResponse转成Tomcat Response 对象</li>
<li>将Tomcat Response 对象转成网络字节流</li>
<li>将响应字节流写回给浏览器</li>
</ul>
<p>说是功能，倒不如说是，整个过程中Connector所做的事情，理解起来就像是个闭环一样</p>
<p>分析连接器详细功能列表，我们会发现连接器需要完成3个高内聚的功能：</p>
<ul>
<li>网络通信</li>
<li>应用层协议解析</li>
<li>Tomcat Request/Response 与ServletRequest/ServletResponse 的转化</li>
</ul>
<p>因此Tomcat的设计者设计了3个组件来实现这3个功能，分别是：EndPoint、Processor、Adapter</p>
<ul>
<li>EndPoint负责提供字节流给Processor</li>
<li>Processor分组提供Tomcat Request 对象给Adapter</li>
<li>Adapter负责提供ServletRequest对象给Containert容器</li>
</ul>
<h4 id="ProtocolHandler"><a class="header-anchor" href="#ProtocolHandler">¶</a>ProtocolHandler</h4>
<p>连接器用<strong>ProtocolHandler</strong>来处理网络连接和应用层协议，包含了2个重要部件：EndPoint、Processor</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221228093700916.png" alt="image-20221228093700916"></p>
<ul>
<li>EndPoint：EndPoint是通信端点，即，通信监听的接口，是具体的Socket接收和发送处理器，<strong>是对传输层的抽象</strong>，因此EndPoint是用来实现TCP/IP协议的</li>
<li>Processor：Processor用来实现HTTP/AJP协议，Processor接收来自EndPoint的Socket，读取字节流解析成Tomcat Request 和Response 对象，并通过Adapter 将其提交到容器处理。<strong>Processor是对应用层协议的抽象</strong></li>
</ul>
<h4 id="Adapter"><a class="header-anchor" href="#Adapter">¶</a>Adapter</h4>
<p>由于协议不同客户端发了过来的请求信息也不尽相同，Tomcat定义了自己的Request类来**“存放”**这些请求消息。ProtocolHandler接口负责解析请求并生成Tomcat Request类。但是这个Request对象不是标准的ServletRequest，也就意味着，不能用Tomcat Request作为参数来调用容器</p>
<blockquote>
<p>Tomcat设计者的解决方案是映入<code>CoyoteAdapter</code>，这是适配器模式的经典运用~</p>
</blockquote>
<h3 id="Container"><a class="header-anchor" href="#Container">¶</a>Container</h3>
<p>容器，顾名思义就是用来装载东西的器具，在Tomcat里，容器就是用来装载Servlet的。Tomcat通过一种分层的架构，使得Servlet容器具有很好的灵活性。Toma设计了4中容器，分别是：Engine，Host，Context，Wrapper。这4种容器不是平行关系，而是父子关系。(没错，就是你与我之间的关系。)</p>
<ul>
<li>Engine：引擎，Servlet的顶层容器，用来管理多个虚拟站点，一个Service最多只能有一个Engine</li>
<li>Host：虚拟主机，负责web应用的部署和Context的创建。可以给Tomcat配置多个虚拟主机地址，而一个虚拟主机下可以部署多个Web应用程序</li>
<li>Context：Web 应用上下文，包含多个Wrapper，负责Web配置的解析、管理所有的Web 资源。一个Context对应一个Web应用程序</li>
<li>Wrapper：宝石一个Servlet最底层的容器，是对Servlet封装，负责Servlet实例的创建、执行和销毁</li>
</ul>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221228095237603.png" alt="image-20221228095237603"></p>
<p>那么这些容器，Tomcat是如何来管理的呢：</p>
<p><strong>Tomcat采用组合模式来管理这些容器</strong>。具体实现方式是，所有容器组件都实现了<code>Container</code>接口，一次组合模式可以使得用户对单容器对象和组合容器对象的使用具有一致性</p>
<p><code>Container</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Container</span> <span class="keyword">extends</span> <span class="title class_">Lifecycle</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span>;</span><br><span class="line">	<span class="keyword">public</span> Container <span class="title function_">getParent</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setParent</span><span class="params">(Container container)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addChild</span><span class="params">(Container child)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeChild</span><span class="params">(Container child)</span>;</span><br><span class="line">	<span class="keyword">public</span> Container <span class="title function_">findChild</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工作原理"><a class="header-anchor" href="#工作原理">¶</a>工作原理</h2>
<h3 id="请求定位Servlet的过程"><a class="header-anchor" href="#请求定位Servlet的过程">¶</a>请求定位Servlet的过程</h3>
<p>Tomcat是用<code>Mapper</code>这个组件来完成这个任务的。Mapper组件的功能就是将用户请求的URL定位到个Servlet。</p>
<p>他的工作原理是：Mapper组件里保存了Web应用的配置信息，其实就是容器组件与访问路径的映射关系，比如Host如里面配置的域名‘Context容器里的Web应用路径，以及Wrapper容器里面的Servlet映射的路径</p>
<p>你可以想象这些配置信息就是一个多层次的Map。当一个请求到来时，Mapper组件通过解析请求去URL里的域名和路径，再到自己保存的Map里去查找，就能定位到一个Servlet。一个请求URL最后只会定位到一个Wrapper容器，也就是一个Servlet</p>
<h3 id="请求在容器中的调用过程"><a class="header-anchor" href="#请求在容器中的调用过程">¶</a>请求在容器中的调用过程</h3>
<p>连接器中的Adapter会调用容器的Service方法来执行Servlet，最先拿到的请求是Engine容器，Engine容器对请求做一些处理后，会把请求传给自己子容器Host来自己处理，以此类推，最后这个请求会传给Wrapper容器，Wrapper会调用最终的Servlet来处理，那么这个调用过程具体是怎么实现的呢：</p>
<blockquote>
<p><strong>Pipeline-Valve</strong> 管道</p>
</blockquote>
<p>Pipeline-Valve 是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者一次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将再调用下一个处理者继续处理</p>
<p>Valve表示一个处理点，比如权限认证和记录日志</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Valve</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> Valve <span class="title function_">getNext</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNext</span><span class="params">(Valve valve)</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoke</span><span class="params">(Request request, Response response)</span> <span class="keyword">throws</span> IOExceptio,ServletException;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Pipeline</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getBasic</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setBasic</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addValve</span><span class="params">(Valve valve)</span>;</span><br><span class="line">    <span class="keyword">public</span> Valve <span class="title function_">getFirst</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Pipeline中维护了 Valve链表，Valve可以插入到Pipeline中，对请求做某些处理。整个调用链的出发是Valve来完成的，Valve完成自己的处理后，调用<code>getNext().incoke()</code>来触发下一个Valve调用。<strong>每个容器都有一个Pipeline对象</strong>，只要出发这个Pipeline的第一个Valve，这个容器里Pipeline中的Valve就都会被调用到。</p>
<p><strong>Basic Valve</strong>处于Valve链表的末端，他是Pipeline中比不可少的一个Valve，负责调用下层容器的Pipeline里的第一Valve</p>
<h2 id="Tomcat基础调优"><a class="header-anchor" href="#Tomcat基础调优">¶</a>Tomcat基础调优</h2>
<ul>
<li>清理不必要的Web应用</li>
<li>清理不必要的xml文件</li>
<li>静止Tomcat TLD扫描</li>
<li>关闭WebSocket支持</li>
<li>关闭JSP支持</li>
<li>静止Servlet注解扫描</li>
<li>并行启动多个Web应用</li>
<li>……</li>
</ul>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
