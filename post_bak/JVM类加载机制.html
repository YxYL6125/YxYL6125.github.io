<!DOCTYPE html>
<html lang=zh>
<head>
    <!-- so meta -->
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="HandheldFriendly" content="True">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5" />
    <meta name="description" content="当我们用java命令运行某个类的main函数启动程序的时候，首先需要通过**类加载器**吧主类加载到JVM">
<meta property="og:type" content="website">
<meta property="og:title" content="JVM类加载机制">
<meta property="og:url" content="https://www.yxyl6125.eu.org/post_bak/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html">
<meta property="og:site_name" content="YxYL🥝">
<meta property="og:description" content="当我们用java命令运行某个类的main函数启动程序的时候，首先需要通过**类加载器**吧主类加载到JVM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230100805505.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230143652368.png">
<meta property="og:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230194832606.png">
<meta property="article:published_time" content="2022-12-30T02:00:24.000Z">
<meta property="article:modified_time" content="2022-12-30T02:00:24.000Z">
<meta property="article:author" content="YxYL">
<meta property="article:tag" content="JVM">
<meta property="article:tag" content="类加载">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230100805505.png">
    
    
      
        
          
            <link rel="shortcut icon" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=48">
          
        
      
      
        
          
            <link rel="icon" type="image/png" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=192" sizes="192x192">
          
        
      
      
        
          
            <link rel="apple-touch-icon" sizes="180x180" href="https://www.gravatar.com/avatar/1c0ccb80f18de6871d3fd37b97cd3594?s=180">
          
        
      
    
    <!-- title -->
    <title>JVM类加载机制</title>
    <!-- async scripts -->
    <!-- Google Analytics -->


    <!-- Umami Analytics -->

    <script async defer
            data-website-id="e77e68be-f6e4-4br3-9365-2b76b57cd571"
            src="https://analytics.domain.com/umami.js">
    </script>


    <!-- styles -->
    
<link rel="stylesheet" href="/css/style.css">

    <!-- persian styles -->
    
    <!-- rss -->
    
    
	<!-- mathjax -->
	
		<script type="text/x-mathjax-config">
		  MathJax.Hub.Config({
			tex2jax: {
			  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
			  inlineMath: [['$','$']]
			}
		  });
		</script>
		<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-MML-AM_CHTML' async></script>
	
<!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head>

<body class="max-width mx-auto px3 ltr">
    
    <div class="content index py4 ">
        
          <header id="header">
  <a class="u-url u-uid" href="/">
  
    
      <img id="logo" alt class="u-logo" src="/images/logo.png" />
    
  
    <div id="title">
      <h1 class="p-name">YxYL🥝</h1>
    </div>
  </a>
  <div id="nav">
    <ul>
      <li class="icon">
        <a href="#" aria-label="目录"><i class="fa-solid fa-bars fa-2x"></i></a>
      </li>
      <!--
     --><li><a href="/">首页</a></li><!--
   --><!--
     --><li><a href="/about/">关于</a></li><!--
   --><!--
     --><li><a href="/archives/">归档</a></li><!--
   --><!--
     --><li><a href="/category/">分类</a></li><!--
   --><!--
     --><li><a href="/tags/">tags</a></li><!--
   --><!--
     --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
   -->
    </ul>
  </div>
</header>

        
        <article class="post" itemscope itemtype="http://schema.org/BlogPosting">
  

  <div class="content" itemprop="articleBody">
      
          <h2 id="类加载运行全过程"><a class="header-anchor" href="#类加载运行全过程">¶</a>类加载运行全过程</h2>
<p>当我们用java命令运行某个类的main函数启动程序的时候，首先需要通过<strong>类加载器</strong>吧主类加载到JVM</p>
<p>通过Java指令执行代码的大体流程如下：</p>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230100805505.png" alt="image-20221230100805505"></p>
<ul>
<li>其中在C++层面的：
<ul>
<li>通过java.exe调用底层的<code>jvm.dll</code>文件创建Java虚拟机</li>
<li>创建一个<strong>引导类加载器实例</strong>(C++)</li>
</ul>
</li>
<li>Java层面：
<ul>
<li>由加载完所有需要使用到的类</li>
<li>执行<code>main</code>方法</li>
<li>java程序执行结束，JVM销毁</li>
</ul>
</li>
</ul>
<p>其中<code>loadClass</code>的类加载过程有如下几步：</p>
<blockquote>
<p>**加载&gt;&gt;验证&gt;&gt;准备&gt;&gt;解析&gt;&gt;初始化&gt;&gt;**使用&gt;&gt;卸载</p>
</blockquote>
<ul>
<li>加载：在磁盘上查找并通过IO读入字节码文件</li>
<li>验证：校验字节码文件的正确性</li>
<li>准备：给类的静态变量分配内存，<strong>并赋予默认值</strong></li>
<li>解析：将符号引用替换为直接引用，这个阶段会把一些静态方法替换为执行数据所存内存的指针或句柄等，这是所谓的静态链接过程(类加载器期间完成)，<strong>动态链接</strong>是指在程序运行期间完成的将符号引用替换为直接引用</li>
<li>初始化：对垒的静态变量初始化为指定的值(即在代码中的赋值操作)，执行静态代码块(<code>static</code>)</li>
</ul>
<h2 id="双亲委派机制"><a class="header-anchor" href="#双亲委派机制">¶</a>双亲委派机制</h2>
<p>Jvm类加载器是有亲子层级关系结构的：<br>
<img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230143652368.png" alt="image-20221230143652368"></p>
<p>这里类加载其实就有一个<strong>双亲委派机制</strong>，加载某个类时会先委托附加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径都找不到目标类，则在自己的类加载路径中查找并载入目标类</p>
<p>双亲委派机制简单来说就是：</p>
<blockquote>
<p>先找父类加载，找不到再由子类自己加载</p>
</blockquote>
<p><strong>AppClassLoader</strong>的<code>loadClass</code>方法最终会调用其父类<strong>ClassLoader</strong>的<code>loadClass</code>方法，该方法的大体逻辑：</p>
<ol>
<li>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回</li>
<li>如果这个类没有被加载过，那么再判断一下是否有父加载器；如果有父加载器，则由附加器加载(即调用<code>parent.loadClass(name,false);</code>)。或者是调用<code>Bootstrap类加载器</code>来加载</li>
<li>如果父加载器及Bootstrap加载器都没有找到指定类，那么则调用当前类加载器了的<code>findClass</code>方法来完成类加载</li>
</ol>
<blockquote>
<p>整体来说就像是个闭环</p>
<p>第一个去趟是必经的，</p>
<p>后面如果发现指定类已经被加载过了，就直接返回；</p>
<p>如果没有，最多不过回来的那一趟最后返回；</p>
<p>之后的在后面去的那一趟必返回指定类，因为肯定被加载过了</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">	<span class="comment">// 检查当前类加载器是否已经加载了该类</span></span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123; <span class="comment">//如果当前加载器父加载器不为空则委托父加载器加载该类</span></span><br><span class="line">                    c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">//如果当前加载器父加载器为空则委托引导类加载器加载该类</span></span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                <span class="comment">// from the non‐null parent class loader</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="comment">//都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span></span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 ‐ t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (resolve) &#123; <span class="comment">//不会执行</span></span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原因"><a class="header-anchor" href="#原因">¶</a>原因</h3>
<p>那么为什么要设计双亲委派机制呢：</p>
<ul>
<li>沙箱安全机制：比如，自己写的<strong>java.lang.String.class</strong>类不会被加载，这样就可以防止核心API库被随意纂改，防止黑客写后门</li>
<li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子<strong>ClassLoader</strong>在加载一次，保证被加载类的唯一性</li>
</ul>
<p>以下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">String</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;**************My String Class**************&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">运行结果：</span><br><span class="line"> 错误: 在类 java.lang.String 中找不到 main 方法, 请将 main 方法定义为:</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span></span><br><span class="line"> 否则 JavaFX 应用程序类必须扩展javafx.application.Application</span><br></pre></td></tr></table></figure>
<h3 id="全盘负责委托机制"><a class="header-anchor" href="#全盘负责委托机制">¶</a>全盘负责委托机制</h3>
<p><strong>“全盘负责”<strong>是指当一个</strong>ClassLoader</strong>装载一个类的时候，除非显式的使用另一个<strong>ClassLoader</strong>，该类所依赖及其引用的类也由这个<strong>ClassLoader</strong>加载/载入</p>
<h3 id="自定义类加载器"><a class="header-anchor" href="#自定义类加载器">¶</a>自定义类加载器</h3>
<p>自定义类加载器只需要继承<code>java.lang.ClassLoader</code>类，这个类有两个核心方法</p>
<ul>
<li><code>loadClass(String, boolean)</code>：实现了双亲委派机制</li>
<li><code>findClass</code>：默认是现实空方法，所以我们自定义类加载器主要是重写<code>findClass</code>方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@program</span>: GroovyProject</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>:</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: YxYL</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@create</span>: 2022-12-30 13:34</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyClassLoader</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String classPath;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyClassLoader</span><span class="params">(String classPath)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.classPath = classPath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">byte</span>[] loadByte(String name) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        name = name.replaceAll(<span class="string">&quot;\\.&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(classPath + <span class="string">&quot;/&quot;</span> + name + <span class="string">&quot;.class&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> fis.available();</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[len];</span><br><span class="line">        fis.read(data);</span><br><span class="line">        fis.close();</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="type">byte</span>[] data = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            data = loadByte(name);</span><br><span class="line">            <span class="keyword">return</span> defineClass(name, data, <span class="number">0</span>, data.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClassNotFoundException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">MyClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyClassLoader</span>(<span class="string">&quot;C:\\Users\\雷神战机\\Desktop&quot;</span>);</span><br><span class="line">        <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;AtomicIntegerFieldUpdaterTest&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;sout&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">        method.invoke(obj, <span class="literal">null</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;clazz.getClassLoader().getClass().getName() = &quot;</span> + clazz.getClassLoader().getClass().getName());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过debug我们会发现，在加载的时候，最终会调到我们自定义的findClass方法，通过调用loadClass方法，得到指定类信息。</p>
<blockquote>
<p>根据双亲委派机制我们知道，首先会让<strong>BootstrapClassLoader</strong>去加载，再<strong>ExtClassLoader</strong>，再<strong>APPClassLoder</strong>，最后再是自己定义的类加载器，</p>
<p>所以，我们测试的时候，需要将指定类的class字节码文件放到扫描路径下，并把指定类从项目中删除</p>
<p>这样，才不会被开始的<strong>APPClassLoader</strong>索扫描到</p>
</blockquote>
<h3 id="打破双亲委托机制"><a class="header-anchor" href="#打破双亲委托机制">¶</a>打破双亲委托机制</h3>
<p>由上面自定义类加载器可以知道，最终调用我们自定义的<code>findClass</code>方法的时候，是会调用<code>loadClass</code>方法以来获得指定类的信息的</p>
<p>这里的<strong>loadClass方法</strong>就实现了双亲委托机制，所以，要打破双亲委托机制，只需要重写一遍<code>loadClass</code>方法就行了</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> resolve</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                <span class="comment">// to find the class.</span></span><br><span class="line">                <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//非自定义的类还是走双亲委派加载</span></span><br><span class="line">                <span class="keyword">if</span> (!name.startsWith(<span class="string">&quot;自己定义的包名&quot;</span>)) &#123;</span><br><span class="line">                    c = <span class="built_in">this</span>.getParent().loadClass(name);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    c = findClass(name);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Tomcat打破双亲委托机制"><a class="header-anchor" href="#Tomcat打破双亲委托机制">¶</a>Tomcat打破双亲委托机制</h2>
<p>以Tomcat类加载为例，Tomcat如果使用默认的双亲委托机制的话：</p>
<p>首先想一下：Tomcat是一个容器，他需要解决：</p>
<ol>
<li>一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖用一个第三方类库的不同版本</strong>，不能要求同一个类库在一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证互相隔离</li>
<li>部署在同一个web容器中<strong>相同的版本可以共享</strong>。否则如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机</li>
<li><strong>web容器也要有自己的依赖的类库，不能与应用程序类库混淆</strong>。基于安全考虑，应该让容器的类库和程序的类库隔离开来</li>
<li>web容器要支持jsp的修改，我们知道，jps文件最终也是要编译成class文件才能再虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，web容器需要支持jsp修改后不用重启</li>
</ol>
<p>所以，如果Tomcat使用的默认的双亲委派类加载机制，是不行的：</p>
<ol>
<li>第一个问题：如果使用默认的类加载机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份</li>
<li>第二个问题：默认的类加载器是能够实现的，因为他的职责就是保证唯一性</li>
<li>第三个问题跟第一个问题一样</li>
</ol>
<h3 id="Tomcat的类加载"><a class="header-anchor" href="#Tomcat的类加载">¶</a>Tomcat的类加载</h3>
<p>Tomcat的几个主要类加载器：</p>
<ul>
<li><strong>commonLoader</strong>：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问</li>
<li><strong>catalinaLoader</strong>：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见</li>
<li><strong>sharedLoader</strong>：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见</li>
<li><strong>WebappClassLoader</strong>：各个Webapp似有意的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入不用的spring版本，这样实现就能加载各自的sprin版本</li>
</ul>
<p><img src="https://raw.githubusercontent.com/YxYL6125/imgBad/main/img/image-20221230194832606.png" alt="image-20221230194832606"></p>
<p>很显然，Tomcat这种类加载机制未被了Java推荐的双亲委派模型</p>
<p>Tomcat为了实现隔离性，没有遵守这个约定，每个<code>webappClassLoader</code>加载自己的目录先的class文件，不会传递给父类加载器，打破了双亲委派机制</p>
<blockquote>
<p>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，</p>
<p>因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，</p>
<p>除了看类的包名和类名是否都相同之外，</p>
<p>还需要看他们的类加载器也是同一个才能认为他们是同一个</p>
</blockquote>

        
  </div>
</article>

        
        <footer id="footer">
  <div class="footer-left">
    Copyright &copy;
    
    
    2021-2023
    YxYL
  </div>
  <div class="footer-right">
    <nav>
      <ul>
        <!--
       --><li><a href="/">首页</a></li><!--
     --><!--
       --><li><a href="/about/">关于</a></li><!--
     --><!--
       --><li><a href="/archives/">归档</a></li><!--
     --><!--
       --><li><a href="/category/">分类</a></li><!--
     --><!--
       --><li><a href="/tags/">tags</a></li><!--
     --><!--
       --><li><a target="_blank" rel="noopener" href="https://github.com/YxYL6125">项目</a></li><!--
     -->
      </ul>
    </nav>
  </div>
</footer>

    </div>
    <!-- styles -->



  <link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload="this.onload=null;this.rel='stylesheet'"/>


    <!-- jquery -->

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script>




<!-- clipboard -->


<script src="/js/main.js"></script>

<!-- search -->

<!-- Baidu Analytics -->

<!-- Cloudflare Analytics -->

<!-- Disqus Comments -->

<!-- utterances Comments -->

</body>
</html>
